<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot红包小程序</title>
    <url>/2022/04/08/Spring-Boot%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="DOS操作"><a href="#DOS操作" class="headerlink" title="DOS操作"></a>DOS操作</h1><p>打包：mvn clean package</p>
<p>启动：java -jar target&#x2F;luckymoney-0.0.1-SNAPSHOT.jar</p>
<p>启动：java -jar target&#x2F;luckymoney-0.0.1-SNAPSHOT.jar</p>
<p>启动prod配置：java -jar -Dspring.profiles.active&#x3D;prod target&#x2F;luckymoney-0.0.1-SNAPSHOT.jar</p>
<span id="more"></span>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><strong>软件版本：java1.8，maven3.5.4，mysql5.7.25</strong></p>
<p>单个配置@Value</p>
<p>配置很多，并且配置之间有联系，则把配置放到类里面去，然后使用@Component</p>
<p>将类连接yml配置@ConfigurationProperties</p>
<h1 id="Controller的使用"><a href="#Controller的使用" class="headerlink" title="Controller的使用"></a>Controller的使用</h1><p>@Controller：处理http请求</p>
<p>@RestController：Spring4之后新加的注解，原来返回json需要@ResponseBody配合@Controller</p>
<p>@RequestMapping：配置url映射（旧版注解，新版可以使用@GetMapping）</p>
<p>@Controller + @ResponseBody &#x3D; @RestController</p>
<p>@GetMapping：只支持GET请求访问</p>
<p>@PostMapping：只支持POST请求访问</p>
<p>@RequestMapping：GET、POST都支持（最好指定POST或者GET，最好不要用@RequestMapping）</p>
<p>@PathVariable：获取url中的数据</p>
<p>@RequestParam：获取请求参数的值</p>
<h1 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h1><h2 id="LuckymoneyApplication"><a href="#LuckymoneyApplication" class="headerlink" title="LuckymoneyApplication"></a>LuckymoneyApplication</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckymoneyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LuckymoneyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="练习配置"><a href="#练习配置" class="headerlink" title="练习配置"></a>练习配置</h1><h2 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LimitConfig limitConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/say&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;)</span> Integer myId)</span> &#123;</span><br><span class="line"><span class="comment">//		return &quot;说明：&quot; + limitConfig.getDescription();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span> + myId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LimitConfig"><a href="#LimitConfig" class="headerlink" title="LimitConfig"></a>LimitConfig</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;limit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal minMoney;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal maxMoney;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getMinMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinMoney</span><span class="params">(BigDecimal minMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minMoney = minMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getMaxMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxMoney</span><span class="params">(BigDecimal maxMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxMoney = maxMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDescription</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h1><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<h2 id="application-dev-yml"><a href="#application-dev-yml" class="headerlink" title="application-dev.yml"></a>application-dev.yml</h2><p><strong>注意：在<code>url</code>结尾一定要加<code>&amp;serverTimezone=Asia/Shanghai</code>，不然Spring Boot连接数据库的时候会报错</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/luckymoney</span></span><br><span class="line"></span><br><span class="line"><span class="attr">limit:</span></span><br><span class="line">  <span class="attr">minMoney:</span> <span class="number">0.01</span></span><br><span class="line">  <span class="attr">maxMoney:</span> <span class="number">9999</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">最少要发$&#123;limit.minMoney&#125;元,</span> <span class="string">最多$&#123;limit.maxMoney&#125;元</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/luckymoney?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="application-prov-yml"><a href="#application-prov-yml" class="headerlink" title="application-prov.yml"></a>application-prov.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/luckymoney</span></span><br><span class="line"></span><br><span class="line"><span class="attr">limit:</span></span><br><span class="line">  <span class="attr">minMoney:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxMoney:</span> <span class="number">9999</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">最少要发$&#123;limit.minMoney&#125;元,</span> <span class="string">最多$&#123;limit.maxMoney&#125;元</span></span><br></pre></td></tr></table></figure>

<h1 id="红包类定义参数"><a href="#红包类定义参数" class="headerlink" title="红包类定义参数"></a>红包类定义参数</h1><h2 id="Luckymoney"><a href="#Luckymoney" class="headerlink" title="Luckymoney"></a>Luckymoney</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.DynamicUpdate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Luckymoney</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送方</span></span><br><span class="line">    <span class="keyword">private</span> String producer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收方</span></span><br><span class="line">    <span class="keyword">private</span> String consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Luckymoney</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(BigDecimal money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProducer</span><span class="params">(String producer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.producer = producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConsumer</span><span class="params">(String consumer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.consumer = consumer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dependency配置"><a href="#dependency配置" class="headerlink" title="dependency配置"></a>dependency配置</h1><h2 id="pom-xml配置"><a href="#pom-xml配置" class="headerlink" title="pom.xml配置"></a>pom.xml配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>luckymoney<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>luckymoney<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="RESTful-API设计"><a href="#RESTful-API设计" class="headerlink" title="RESTful API设计"></a>RESTful API设计</h1><p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220408172153989.png" alt="image-20220408172153989"></p>
<h2 id="LuckymoneyController"><a href="#LuckymoneyController" class="headerlink" title="LuckymoneyController"></a>LuckymoneyController</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckymoneyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LuckmoneyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LuckymoneyService service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取红包列表</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/luckymoneys&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Luckymoney&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 查询所有的列表</span></span><br><span class="line">        <span class="keyword">return</span> repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建红包(发红包)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/luckymoneys&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Luckymoney <span class="title function_">create</span><span class="params">(<span class="meta">@RequestParam(&quot;producer&quot;)</span> String producer,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span> &#123;</span><br><span class="line">        <span class="type">Luckymoney</span> <span class="variable">luckymoney</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Luckymoney</span>();</span><br><span class="line">        luckymoney.setProducer(producer);</span><br><span class="line">        luckymoney.setMoney(money);</span><br><span class="line">        <span class="keyword">return</span> repository.save(luckymoney);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过id查询红包</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/luckymoneys/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Luckymoney <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">// orElse(null) 查到了返回Luckymoney对象，查不到返回null</span></span><br><span class="line">        <span class="keyword">return</span> repository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新红包(领红包)</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/luckymoneys/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Luckymoney <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(&quot;consumer&quot;)</span> String consumer)</span> &#123;</span><br><span class="line">        Optional&lt;Luckymoney&gt; optional = repository.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">            <span class="type">Luckymoney</span> <span class="variable">luckymoney</span> <span class="operator">=</span> optional.get();</span><br><span class="line">            luckymoney.setConsumer(consumer);</span><br><span class="line">            <span class="keyword">return</span> repository.save(luckymoney);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/luckymoneys/two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        service.createTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LuckmoneyRepository"><a href="#LuckmoneyRepository" class="headerlink" title="LuckmoneyRepository"></a>LuckmoneyRepository</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LuckmoneyRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Luckymoney, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="LuckymoneyService"><a href="#LuckymoneyService" class="headerlink" title="LuckymoneyService"></a>LuckymoneyService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckymoneyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LuckmoneyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务 指数据库事务 数据库引擎要更换成InnoDB才支持事务</span></span><br><span class="line">    <span class="comment">// 可以用于 扣库存 &gt; 创建订单 的同时性</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Luckymoney</span> <span class="variable">luckymoney1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Luckymoney</span>();</span><br><span class="line">        luckymoney1.setProducer(<span class="string">&quot;大毛&quot;</span>);</span><br><span class="line">        luckymoney1.setMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;520&quot;</span>));</span><br><span class="line">        repository.save(luckymoney1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Luckymoney</span> <span class="variable">luckymoney2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Luckymoney</span>();</span><br><span class="line">        luckymoney2.setProducer(<span class="string">&quot;大毛&quot;</span>);</span><br><span class="line">        luckymoney2.setMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1314&quot;</span>));</span><br><span class="line">        repository.save(luckymoney2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>红包程序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeedCode 1 ~ 50</title>
    <url>/2022/03/27/LeedCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%951-50/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p>
<p><strong>思路：</strong><br>用哈希表储存已经遍历过的值，再通过<code>int r = target - nums[i];</code>查看哈希表中是否存在一个值，与<code>nums[i]</code>之和为<code>target</code></p>
<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, hash[r]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> r = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;i, hash[r]&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">9</span>;</span><br><span class="line">    ans = <span class="built_in">twoSum</span>(nums, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p>
<p><strong>思路：</strong><br>遍历一遍即可，注意进位<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 当前尾节点位置</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            t = l1-&gt;val + l2-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            t = l1-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            t = l2-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看看最后是否还有进位</span></span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t);</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表的节点规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 当前尾节点位置</span></span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        t = l1-&gt;val + l2-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">        t = l1-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">        t = l2-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看最后是否还有进位</span></span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t);</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 构造第一个链表，输入-1时停止</span></span><br><span class="line">    <span class="keyword">auto</span> dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur1 = dummy1;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur1-&gt;next = p;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造第二个链表，输入-1时停止</span></span><br><span class="line">    <span class="keyword">auto</span> dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur2 = dummy2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur2-&gt;next = p;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">addTwoNumbers</span>(dummy1-&gt;next, dummy2-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = p; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<p><strong>思路：</strong><br>双指针算法 + 哈希表<br>利用指针<code>i</code>前进，同时哈希表统计是否有重复的字符。如果有重复字符，那么指针<code>j</code>也前进，直到重复字符消失为止，比较统计最大长度。<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">lengthOfLongestSubstring</span>(s);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p>
<p><strong>思路：</strong><br>分别考虑奇数回文子串和偶数回文子串即可<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="comment">// 找出最长的奇数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最长的偶数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="comment">// 找出最长的奇数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最长的偶数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">longestPalindrome</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a>Z 字形变换</h1><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/">Z 字形变换</a></p>
<p><strong>思路：</strong><br>第一行和最后一行，每个数字之间间隔是<code>2n-2</code>：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-18-20-16483439651561.png" alt="在这里插入图片描述"><br>中间行分2个队伍，分别向后相差<code>2n-2</code>，两个队伍的队头之和为<code>2n-2</code>：<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-22-39.png" alt="在这里插入图片描述"><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一行的时候直接返回s即可</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一行和最后一行，每个数字之间间隔是2n - 2</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    ans += s[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中间行分2个队伍j和k，分别向后相差2n-2，两个队伍的队头j和k之和为2n-2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - j; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// j队伍在前</span></span><br><span class="line">                    ans += s[j];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// k队伍在后，总是一个j一个k，这样轮循下去</span></span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ans += s[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一行的时候直接返回s即可</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一行和最后一行，每个数字之间间隔是2n - 2</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                ans += s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 中间行分2个队伍j和k，分别向后相差2n-2，两个队伍的队头j和k之和为2n-2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - j; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// j队伍在前</span></span><br><span class="line">                ans += s[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// k队伍在后，总是一个j一个k，这样轮循下去</span></span><br><span class="line">                <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    ans += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt;  n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">convert</span>(s, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p>
<p><strong>思路：</strong><br>将<code>ans * 10 + res[i]</code> 转化为  <code>ans &lt;= double (INT_MAX - res[i] - 1) / 10</code>即可<br><strong>时间复杂度：<em>O($log<del>10</del>n$)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	        sign = <span class="number">-1</span>;</span><br><span class="line">	        x = -x;</span><br><span class="line">	    &#125;</span><br><span class="line">	    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">	        res.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">	        x /= <span class="number">10</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (ans &lt;= <span class="built_in">double</span> (INT_MAX - res[i] - <span class="number">1</span>) / <span class="number">10</span>) &#123;</span><br><span class="line">	            ans = ans * <span class="number">10</span> + res[i];</span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ans *= sign;</span><br><span class="line">	    <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= <span class="built_in">double</span> (INT_MAX - res[i]) / <span class="number">10</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + res[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">reverse</span>(x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></p>
<p><strong>思路：</strong><br>细心点即可，小心超出long long 的范围<br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 丢弃无用的前导空格</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查下一个字符（假设还未到字符末尾）为正还是负号</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;-&#x27;</span>) k++, sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加符号</span></span><br><span class="line">        ans *= sign;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX) ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; INT_MIN) ans = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 丢弃无用的前导空格</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查下一个字符（假设还未到字符末尾）为正还是负号</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;-&#x27;</span>) k++, sign = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加符号</span></span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; INT_MAX) ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; INT_MIN) ans = INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAtoi</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p>
<p><strong>思路：</strong><br>利用字符串转换函数<code>to_string(x)</code>和字符串翻转函数<code>string(str.rbegin(), str.rend());</code><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="comment">// 字符串翻转函数</span></span><br><span class="line">        string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">return</span> str == str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">    string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="keyword">return</span> str == str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isPalindrome</span>(x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p>
<p><strong>思路：</strong><br>假设左边先到达最优解，证明右边一定会向最优解靠拢<br>也就是说当左边到达最优解时，右边在最优解之前的值，一定都比左边的值要短，从而左边不动，右边向左靠拢，直到经过右边最优解为止<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-23-41.png" alt="在这里插入图片描述"><br><strong>结论，只要左边先到达最优解，那么右边到达最优解之前的值，一定小于左边的最优解</strong><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[l], height[r]) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[l], height[r]) * (r - l));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; height = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxArea</span>(height) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h1><p><a href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> valus[] = &#123;</span><br><span class="line">            <span class="number">1000</span>,</span><br><span class="line">            <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>,</span><br><span class="line">            <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        string reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">            <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= valus[i]) &#123;</span><br><span class="line">                num -= valus[i];</span><br><span class="line">                res += reps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h1><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>, hash[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        hash[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>, hash[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        hash[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>, hash[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        hash[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; hash[s[i]] &lt; hash[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= hash[s[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += hash[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p>
<p><strong>思路：</strong><br>把最短的字符串放在第一个，然后逐位和后面的字符串相应位置比较，如果遇到不同的直接跳出双重循环<br><strong>时间复杂度：<em>O(n<sup>n</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到长度最短的字符串</span></span><br><span class="line">        <span class="type">int</span> minv = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 长度最短的字符串的下标</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].<span class="built_in">size</span>() &lt; minv) &#123;</span><br><span class="line">                minv = strs[i].<span class="built_in">size</span>();</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx) <span class="built_in">swap</span>(strs[<span class="number">0</span>], strs[idx]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                    sign = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == strs.<span class="built_in">size</span>() - <span class="number">1</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到长度最短的字符串</span></span><br><span class="line">    <span class="type">int</span> minv = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 长度最短的字符串的下标</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].<span class="built_in">size</span>() &lt; minv) &#123;</span><br><span class="line">            minv = strs[i].<span class="built_in">size</span>();</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx) <span class="built_in">swap</span>(strs[<span class="number">0</span>], strs[idx]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == strs.<span class="built_in">size</span>() - <span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;<span class="string">&quot;cir&quot;</span>,<span class="string">&quot;car&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">longestCommonPrefix</span>(strs) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></p>
<p><strong>思路：</strong><br><strong>算法：排序+双指针</strong><br>先排序，然后固定i，然后j和k相互靠拢<br>双指针做法，首先想暴力做法怎么做，然后看是否有单调性，有单调性可以考虑双指针，双指针可以优化掉一个次方的时间复杂度，从n<sup>3</sup>优化到n<sup>2</sup><br>而且j越大，k一定越小，这一点就保证了j和k一次最多只扫描了n，当j越大，k已经没必要从最右边开始扫描了，只需要从之前的地方往左就行，因为nums[j]增加，nums[k]必须不变或者变小，才有意义<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-36-23.png" alt="在这里插入图片描述"><br>题目要求不能有重复，如果nums[i]和等于nums[i - 1]的话，那么nums[i]的所有j和k，其实在nums[i - 1]已经全部枚举完了，所以得去除nums[i]&#x3D;&#x3D;nums[i - 1]的j和k，也就是跳过，一直到nums[i]和前面不一样才行<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-25-10.png" alt="在这里插入图片描述"><br>因为是有序的，如果三元组的第一个数不一样，后面肯定不一样<br>然后当i相同时，nums[j]也不能等于nums[j - 1]</p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = <span class="built_in">threeSum</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></p>
<p><strong>思路一：</strong><br>暴力解法<br><strong>时间复杂度：<em>O(n<sup>3</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">	            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">	                sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">	                <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">	                    minSum = sum;</span><br><span class="line">	                    minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">	                    <span class="keyword">if</span> (minv == <span class="number">0</span>) <span class="keyword">return</span> minSum;</span><br><span class="line">	                &#125;</span><br><span class="line">	                k--;</span><br><span class="line">	            &#125;</span><br><span class="line">	            k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> minSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong><br>排序+双指针优化掉一重循环<br>首先将 nums 数组排序，然后固定一重循环枚举起始位置 i ，这样就优化成 2 个数 j, k 之和最接近 target 的问题了<br>然后初始 j &#x3D; i + 1, k &#x3D; nums.size() - 1；如果发现 sum &#x3D;&#x3D; target，则可以直接返回 target<br>若发现 sum &lt; target，则 j++；否则 k–，这样就会向 target 逼近<br>直到 j &gt;&#x3D; k 停止，继续向后增加初始位置 i<br><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">	            sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">	            <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">	                minSum = sum;</span><br><span class="line">	                minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> target;</span><br><span class="line">	            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) j++;</span><br><span class="line">	            <span class="keyword">else</span> k--;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> minSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">                minSum = sum;</span><br><span class="line">                minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">-100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">threeSumClosest</span>(nums, target) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></p>
<p><strong>思路：</strong><br>递归<br><strong>时间复杂度：<em>O(4<sup>n</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str[k].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + str[k][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, u, path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str[k].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + str[k][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="built_in">dfs</span>(digits, u, path);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    vector&lt;string&gt; ans = <span class="built_in">letterCombinations</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (string i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><p><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></p>
<p><strong>思路：</strong><br>排序+双指针优化一层复杂度<br>注意爆 int ，要用 long long 存储四数之和<br><strong>时间复杂度：<em>O(n<sup>3</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; u - <span class="number">1</span> &amp;&amp; (<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] - target &gt;= <span class="number">0</span>) u--;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u] == target) &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span> (k &lt; u - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] - target &gt;= <span class="number">0</span>) u--;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u] == target) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = <span class="built_in">fourSum</span>(nums, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p>
<p><strong>思路：</strong><br>遍历一遍统计节点个数，在遍历一遍删除对应节点<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计链表总共有多少个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = i - n;</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表的倒数第 N 个结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计链表总共有多少个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = i - n;</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试样例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k, k != <span class="number">-1</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(k);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="built_in">removeNthFromEnd</span>(dummy-&gt;next, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p>
<p><strong>思路：</strong><br>用栈，如果是左括号，就压栈，然后<code>continue</code><br>如果是右括号，则看栈顶是不是对应的左括号，如果不是，则压栈<br>如果是右括号，栈为空，则返回<code>false</code><br>如果遍历完毕，栈为空则返回<code>true</code>，否则返回<code>false</code><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isValid</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p>
<p><strong>思路：</strong><br>遍历一遍即可<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                list1 = cur-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                list2 = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1) cur-&gt;next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2) cur-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p>
<p><strong>思路：</strong><br>左括号小于<code>n</code>，就可以加；右括号数量小于左括号数量则可以加<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lc为左括号的数量，rc为右括号的数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, res + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; lc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, res + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lc为左括号的数量，rc为右括号的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, res + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; lc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, res + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;string&gt; ans = <span class="built_in">generateParenthesis</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : ans) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></p>
<p><strong>思路：</strong><br>用临时变量<code>temp</code>储存下一个值，方便调换<br>然后用<code>before</code>存储上一个值<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* h;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next) h = head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* before = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p &amp;&amp; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = p-&gt;next;</span><br><span class="line">            before-&gt;next = temp;</span><br><span class="line">            p-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            before = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* h;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next) h = head-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* before = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p &amp;&amp; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = p-&gt;next;</span><br><span class="line">        before-&gt;next = temp;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">        before = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k, k != <span class="number">-1</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(k);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="built_in">swapPairs</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></p>
<p><strong>思路：</strong><br>双指针<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p><a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p>
<p><strong>思路：</strong><br>双指针<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></p>
<p><strong>思路：</strong><br>kmp算法<br><strong>时间复杂度：<em>O(n + m)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 字符串先补成从1开始</span></span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 求next数组，为什么从 i = 2 开始呢，因为 next[1] = 0</span></span><br><span class="line">        <span class="comment">// next 指的是非平凡的前缀和后缀相等的最大值，不包括本身，所以 next[1] = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 字符串先补成从1开始</span></span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 求next数组，为什么从 i = 2 开始呢，因为 next[1] = 0</span></span><br><span class="line">    <span class="comment">// next 指的是非平凡的前缀和后缀相等的最大值，不包括本身，所以 next[1] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s, p;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strStr</span>(s, p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p><a href="https://leetcode-cn.com/problems/divide-two-integers/">两数相除</a></p>
<p><strong>思路：</strong><br>快速幂+位运算<br><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        vector&lt;LL&gt; exp;</span><br><span class="line">        <span class="type">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) is_minus = <span class="literal">true</span>;</span><br><span class="line">        LL a = <span class="built_in">abs</span>((LL)x), b = <span class="built_in">abs</span>((LL)y);</span><br><span class="line">        <span class="keyword">for</span> (LL i = b; i &lt;= a; i = i + i) exp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = exp.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= exp[i]) &#123;</span><br><span class="line">                a -= exp[i];</span><br><span class="line">                res += <span class="number">1LL</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_minus) res = -res;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) res = INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></p>
<p><strong>思路：</strong></p>
<p>首先逆序扫描一遍数组，找到降序的点（即：图中红色的点）<br>如图：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-30_23-11-48.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k --;</span><br></pre></td></tr></table></figure>

<p>循环结束<code>k</code>的值表示红色的点<code>a</code>的下标。</p>
<p>然后重新逆序遍历，找到最小的比<code>k - 1</code>大的点。由于在图中点<code>a</code>后面的点本身就是排好序了的，所以我们逆序遍历，第一个比<code>k - 1</code>大的点就是最小的比<code>k - 1</code>大的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br></pre></td></tr></table></figure>

<p>然后交换这两个点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>最后将后面（蓝色圈出来部分）下降的折线 捋成上升的形状。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">nextPermutation</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p>
<p><strong>思路：</strong></p>
<p>二分找出分界点</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-30_23-57-39.png" alt="1"></p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                r = l - <span class="number">1</span>, l = <span class="number">0</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == nums[l]) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><strong>思路：</strong></p>
<p>两次二分即可</p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">push_back</span>(r);</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></p>
<p><strong>思路：</strong></p>
<p>二分</p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; target &gt; nums[l]) l++;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    	mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    		l = mid + <span class="number">1</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		r = mid;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; target &gt; nums[l]) l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">searchInsert</span>(nums, target) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">有效的数独</a></p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>&gt;)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[9]为行，col[9]为列</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">9</span>], col[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">            <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++res[board[i][j] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++col[board[j][i] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res[9]为九宫格</span></span><br><span class="line">        <span class="type">int</span> rc[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i += <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(rc, <span class="number">0</span>, <span class="keyword">sizeof</span> rc);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[x + i][y + j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++rc[board[x + i][y + j] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><p><a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></p>
<p><strong>思路：</strong></p>
<p>简单模拟一下即可，双指针</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, j = k; j &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == s[k]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="built_in">to_string</span>(j - k) + s[k];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></p>
<p><strong>思路：</strong></p>
<p>暴力枚举每个数选几个</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, u + <span class="number">1</span>, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, u + <span class="number">1</span>, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = s.<span class="built_in">combinationSum</span>(c, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></p>
<p><strong>思路：</strong></p>
<p>先求每个数最多能出现的次数，然后枚举每个数选几个，并且加上个数限制即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; c.<span class="built_in">size</span>() &amp;&amp; c[k] == c[u]) k++;</span><br><span class="line">        <span class="type">int</span> cnt = k - u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, k, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; c.<span class="built_in">size</span>() &amp;&amp; c[k] == c[u]) k++;</span><br><span class="line">        <span class="type">int</span> cnt = k - u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, k, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = s.<span class="built_in">combinationSum</span>(c, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></p>
<p><strong>思路一：</strong></p>
<p>假设不考虑时间复杂度，排序，去重以后，暴力对比即可</p>
<p><strong>时间复杂度：<em>O(nlogn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; INT_MAX; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>哈希表，把所有数放到哈希表里面，然后再枚举所有正整数</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (hash.<span class="built_in">count</span>(res)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路三：</strong></p>
<p>原地哈希算法：</p>
<p>原地哈希算法主要应用在范围为 [0, len(nums)] 的数组解法中，将数组元素本身作为<code>nums</code> 的下标，即 <code>nums[nums[i]]</code></p>
<p>原地哈希映射：保证1出现在nums[0]的位置上，2出现在nums[1]的位置上，…，n出现在nums[n-1]的位置上，其他的数字不管。例如[3,4,-1,1]将被排序为[1,-1,3,4]</p>
<p>遍历nums，找到第一个不在应在位置上的1到n的数。例如，排序后的[1,-1,3,4]中第一个 nums[i] !&#x3D; i + 1 的是数字2（注意此时i&#x3D;1）。</p>
<p>时间复杂度分析：代码中第二层while循环，每循环一次，会将一个数放在正确的位置上，所以总共最多执行 n 次，所以总时间复杂度 O(n)。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h1><p><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></p>
<p><strong>思路：</strong></p>
<p>将A[i] * B[j] 加到 C[i + j] 里面，最后再一起进位</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220412220151895.png" alt="image-20220412220151895"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除前导0</span></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">        <span class="comment">// 数字转字符串</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string num1, num2;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<p><strong>思路：</strong></p>
<p>动态规划+贪心</p>
<ol>
<li><p>设状态 f(i) 表示到达 i 所需要的最少步数。</p>
</li>
<li><p>f(0)&#x3D;0，其余待定。定义辅助指针 last 为第一次到达 i 时上一步的位置，last 从 0 开始。</p>
</li>
<li><p>我们会发现f[i]是具有单调性的，也就是f[i + 1] &gt;&#x3D; f[i]。</p>
<p>用反证法：假设f[i + 1] &lt; f[i]，不妨设是从k,(k &lt;&#x3D; i)点跳到i + 1，即：k + nums[k] &gt;&#x3D; i + 1，那么k + nums[k]也必然大于i，此时：f[i + 1] &#x3D; f[i]了。如果nums数组每一项都为1，则：f[i + 1] &gt; f[i]，综上：f[i + 1] &gt;&#x3D; f[i]，与假设矛盾。</p>
</li>
<li><p>根据以上得知，令 f(i)&#x3D;f(last)+1 后，f(i) 就会是最优值。</p>
<p>在动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了，这里无论是取哪一个点跳到i，其最终的结果是一样的，但是取第一个点和取最后一个点所需要的步数可能不相同，所以尽量选择靠前的点，这样步数就可能会减少，贪心的思想。</p>
</li>
<li><p>故可以根据 i 来让last 向后移动，找到最早的可以一步到达 i 的位置，然后根据 f(last) 更新 f(i)。</p>
</li>
</ol>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, last = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据i来更新last。如果last + nums[last]够不到i，那就往后移last</span></span><br><span class="line">            <span class="keyword">while</span> (last + nums[last] &lt; i) last++;</span><br><span class="line">            <span class="comment">// 根据f[last]更新f[i]，last可以一步走到i</span></span><br><span class="line">            f[i] = f[last] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></p>
<p><strong>思路一：</strong></p>
<p>next_permutation函数</p>
<p><strong>时间复杂度：<em>O(n x n!)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p><strong>时间复杂度：<em>O(n x n!)</em></strong></p>
<p><strong>核心代码：</strong></p>
<p><strong>ACM模式代码：</strong></p>
]]></content>
      <categories>
        <category>LeedCode</category>
      </categories>
      <tags>
        <tag>LeedCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记</title>
    <url>/2022/04/23/c++/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">字符型</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">整型</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">浮点型</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">双浮点型</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">无类型</td>
<td align="left">void</td>
</tr>
<tr>
<td align="left">宽字符型</td>
<td align="left">wchar_t</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>其实 wchar_t 是这样来的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure>

<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>
<p><strong>注意：</strong>不同系统会有所差异，一字节为 8 位。</p>
<p><strong>注意：</strong>默认情况下，int、short、long都是带符号的，即 signed。</p>
<p><strong>注意：</strong>long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C&#x2F;C++ 标准兼容了早期的这一设定。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+&#x2F;- 3.4e +&#x2F;- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125; c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; red &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; green &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    c = blue;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green = <span class="number">5</span>, blue &#125; c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; red &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; green &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    c = blue;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h2><p><strong>当局部变量被定义时，系统不会对其初始化</strong>，必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>下面列举几个整数常量的实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">// 合法的</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">// 合法的</span></span><br><span class="line"><span class="number">0xFee</span>L      <span class="comment">// 合法的</span></span><br><span class="line"><span class="number">078</span>         <span class="comment">// 非法的：8 不是八进制的数字</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">// 非法的：不能重复后缀</span></span><br></pre></td></tr></table></figure>

<p>以下是各种类型的整数常量的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure>

<p>经过测试c++可以long long直接转int，不会编译出错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = a;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可能会爆int</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a = <span class="number">1e13</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 10000000000000</span></span><br><span class="line">    <span class="type">int</span> n = a;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl; <span class="comment">// 1316134912</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">// 非法的：不完整的指数</span></span><br><span class="line"><span class="number">210f</span>          <span class="comment">// 非法的：没有小数或指数</span></span><br><span class="line">.e55          <span class="comment">// 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure>

<h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">\ 字符</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">‘ 字符</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">“ 字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">? 字符</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">警报铃声</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<h1 id="修饰符类型"><a href="#修饰符类型" class="headerlink" title="修饰符类型"></a>修饰符类型</h1><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>下面列出了数据类型修饰符：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>long</strong>，<strong>int</strong> 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> y;</span><br></pre></td></tr></table></figure>

<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 这个程序演示了有符号整数和无符号整数之间的差别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> i;           <span class="comment">// 有符号短整数</span></span><br><span class="line">   <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> j;  <span class="comment">// 无符号短整数</span></span><br><span class="line"> </span><br><span class="line">   j = <span class="number">50000</span>;</span><br><span class="line"> </span><br><span class="line">   i = j;</span><br><span class="line">   cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的程序运行时，会输出下列结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">-15536</span> <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>
<h2 id="C-中的类型限定符"><a href="#C-中的类型限定符" class="headerlink" title="C++ 中的类型限定符"></a>C++ 中的类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>
<table>
<thead>
<tr>
<th align="left">限定符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const</td>
<td align="left"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td align="left">restrict</td>
<td align="left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody></table>
<h1 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h1><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>
<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p>
<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure>

<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>第一个文件：main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个文件：support.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_extern</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。</p>
<p>结果<code>Count is 5</code></p>
<h2 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure>

<p>针对上面定义的函数 max()，以下是函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h2><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>
<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用函数来添加值</span></span><br><span class="line">   result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 再次调用函数</span></span><br><span class="line">   result = <span class="built_in">sum</span>(a);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Total value is :<span class="number">300</span></span><br><span class="line">Total value is :<span class="number">120</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h2><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>

<p>如果没有返回值可以表示为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125; </span><br></pre></td></tr></table></figure>

<p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>

<p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p>
<p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p>
<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>

<p>另外有一点需要注意。对于[&#x3D;]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>

<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><h2 id="C-数学运算"><a href="#C-数学运算" class="headerlink" title="C++ 数学运算"></a>C++ 数学运算</h2><p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>
<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>
<p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个浮点数的绝对值。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td>
</tr>
</tbody></table>
<h2 id="C-随机数"><a href="#C-随机数" class="headerlink" title="C++ 随机数"></a>C++ 随机数</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>
<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>( (<span class="type">unsigned</span>)<span class="built_in">time</span>( <span class="literal">NULL</span> ) );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
<h2 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C 风格字符串"></a>C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 <strong>RUNOOB</strong> 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 <strong>RUNOOB</strong> 的字符数多一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">char site[] <span class="operator">=</span> <span class="string">&quot;RUNOOB&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其实，您不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <strong>\0</strong> 放在字符串的末尾。让我们尝试输出上面的字符串：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;菜鸟教程: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; site &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title ：标题</li>
<li>Author ：作者</li>
<li>Subject ：类目</li>
<li>Book ID ：书的 ID</li>
</ul>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;</span><br><span class="line">member_type1 member_name1;</span><br><span class="line">member_type2 member_name2;</span><br><span class="line">member_type3 member_name3;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125; object_names;</span><br></pre></td></tr></table></figure>

<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 <strong>Books</strong>，变量为 <strong>book</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure>

<h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>
<p>下面的实例演示了结构的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明一个结构体类型 Books </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;前端技术&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 Book1 信息</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书标题 : &quot;</span> &lt;&lt; Book1.title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书作者 : &quot;</span> &lt;&lt; Book1.author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书类目 : &quot;</span> &lt;&lt; Book1.subject &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书 ID : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 Book2 信息</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第二本书标题 : &quot;</span> &lt;&lt; Book2.title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第二本书作者 : &quot;</span> &lt;&lt; Book2.author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第二本书类目 : &quot;</span> &lt;&lt; Book2.subject &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第二本书 ID : &quot;</span> &lt;&lt; Book2.book_id &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例中定义了结构体类型 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第一本书标题 : C++ 教程</span><br><span class="line">第一本书作者 : Runoob</span><br><span class="line">第一本书类目 : 编程语言</span><br><span class="line">第一本书 ID : <span class="number">12345</span></span><br><span class="line">第二本书标题 : CSS 教程</span><br><span class="line">第二本书作者 : Runoob</span><br><span class="line">第二本书类目 : 前端技术</span><br><span class="line">第二本书 ID : <span class="number">12346</span></span><br></pre></td></tr></table></figure>

<h2 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h2><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明一个结构体类型 Books </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;前端技术&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 Book1 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 Book2 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> &lt;&lt; book.author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">书标题 : C++ 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 编程语言</span><br><span class="line">书 ID : <span class="number">12345</span></span><br><span class="line">书标题 : CSS 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 前端技术</span><br><span class="line">书 ID : <span class="number">12346</span></span><br></pre></td></tr></table></figure>

<h2 id="单向链表结构体"><a href="#单向链表结构体" class="headerlink" title="单向链表结构体"></a>单向链表结构体</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体，定义链表的节点规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表节点的值n</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 构造虚拟头节点dummy</span></span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 当前尾节点位置</span></span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动输入要构造的节点的值n，并且当输入-1时代表终止</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// p为新构造的节点</span></span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        <span class="comment">// 上一个节点的next即为p</span></span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        <span class="comment">// 将cur后移</span></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span> *struct_pointer;</span><br></pre></td></tr></table></figure>

<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;前端技术&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数以结构指针作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书标题  : &quot;</span> &lt;&lt; book-&gt;title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> &lt;&lt; book-&gt;author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book-&gt;subject &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book-&gt;book_id &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">书标题  : C++ 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 编程语言</span><br><span class="line">书 ID : <span class="number">12345</span></span><br><span class="line">书标题  : CSS 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 前端技术</span><br><span class="line">书 ID : <span class="number">12346</span></span><br></pre></td></tr></table></figure>

<h2 id="typedef-关键字"><a href="#typedef-关键字" class="headerlink" title="typedef 关键字"></a>typedef 关键字</h2><p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;Books;</span><br></pre></td></tr></table></figure>

<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Books Book1, Book2;</span><br></pre></td></tr></table></figure>

<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> *pint32;</span><br><span class="line"> </span><br><span class="line">pint32 x, y, z;</span><br></pre></td></tr></table></figure>

<p>x, y 和 z 都是指向长整型 long int 的指针。</p>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯常用技巧</title>
    <url>/2022/04/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜bits/stdc++.h＞</span></span><br></pre></td></tr></table></figure>

<h2 id="加快输入输出"><a href="#加快输入输出" class="headerlink" title="加快输入输出"></a>加快输入输出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main函数中加入以下代码，降低时长</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="常用变量定义"><a href="#常用变量定义" class="headerlink" title="常用变量定义"></a>常用变量定义</h2><p>建议一些变量、数组、标记等定义在全局，这样就避免了初始化，因为放在全局的变量，系统自动初始化成0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">// 1061109567</span></span><br><span class="line"><span class="type">const</span> LL  INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;<span class="comment">// 4557430888798830399</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);<span class="comment">// 3.14159</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);<span class="comment">// 2.71828</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e5</span>+<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0x3f3f3f3f是一个很有用的数值，它是满足以下两个条件的最大整数。</p>
<p>1、整数的两倍不超过 0x7f7f7f7f，即int能表示的最大正整数。</p>
<p>2、整数的每8位（每个字节）都是相同的。(0011 1111 0011 1111 0011 1111 0011 1111)</p>
<p>我们在程序设计中经常需要使用 memset(a, val, sizeof a) 初始化一个数组a，该语句把数值 val（0x00~0xFF）填充到数组a 的每个字节上，所以用memset只能赋值出“每8位都相同”的 int。</p>
<p>当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 memset(a, 0x3f, sizeof(a)) 给数组赋 0x3f3f3f3f的值来代替。</p>
</blockquote>
<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//a[10]的长度其实是40byte，因为每个int是4个byte</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>],  b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">40</span>);<span class="comment">//cstring中的memset(要初始化的数组，初始化的值，要初始化的字节长度(byte))</span></span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);<span class="comment">//sizeof可以用来求数组占用的字节数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[]=<span class="string">&quot;This is a test of the memset function&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before:%s\n&quot;</span>,data);</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="string">&#x27;*&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After:%s\n&quot;</span>,data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    Before:This is a test of the memset function</span><br><span class="line">	After:**** is a test of the memset function</span><br></pre></td></tr></table></figure>

<h2 id="atoi-x2F-stoi-字符串转换为整数"><a href="#atoi-x2F-stoi-字符串转换为整数" class="headerlink" title="atoi&#x2F;stoi 字符串转换为整数"></a>atoi&#x2F;stoi 字符串转换为整数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">atoi</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitset-字符串或者整数转二进制"><a href="#bitset-字符串或者整数转二进制" class="headerlink" title="bitset 字符串或者整数转二进制"></a>bitset 字符串或者整数转二进制</h2><p>用于将字符串或者整数转换成二进制数存储</p>
<p>bitset存储中下标是从右往左 从0开始计数的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储位数足够，前面多余位用0补足</span></span><br><span class="line">    bitset &lt;8&gt;<span class="built_in">a</span>(<span class="number">13</span>);<span class="comment">// 1101</span></span><br><span class="line">    bitset &lt;8&gt;<span class="built_in">b</span>(<span class="built_in">string</span>(<span class="string">&quot;100101&quot;</span>));<span class="comment">// 100101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储位数不够时，数字转换取后几位，字符串转换取前几位</span></span><br><span class="line">    bitset &lt;3&gt;<span class="built_in">c</span>(<span class="number">12</span>);<span class="comment">// 1100</span></span><br><span class="line">    bitset &lt;4&gt;<span class="built_in">d</span>(<span class="built_in">string</span>(<span class="string">&quot;100111&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注 ：bitset的下标是从右往左数的</span></span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">1011</span></span><br><span class="line">    <span class="number">00001101</span></span><br><span class="line">    <span class="number">00100101</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*执行 flip 、set 和 reset函数 后都会覆盖原有值</span></span><br><span class="line">    string str = <span class="string">&quot;10010111&quot;</span>;</span><br><span class="line">    bitset &lt;8&gt; <span class="built_in">m</span>(str);</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">count</span>() &lt;&lt; endl;<span class="comment">// 返回m中1的个数</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 返回m的大小</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">test</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">// 检测下标为2的元素是否为1 若为1 则返回1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">any</span>() &lt;&lt; endl;<span class="comment">// 检测m中是否有1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">none</span>() &lt;&lt; endl;<span class="comment">// 检测m中是否没有1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">all</span>() &lt;&lt; endl;<span class="comment">// 检测m中是否全部为1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">flip</span>() &lt;&lt; endl;<span class="comment">// 所有位都取反</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">flip</span>(<span class="number">0</span>) &lt;&lt; endl;<span class="comment">// 下标为0的位置取反</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">set</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">// 将下标为2的元素置为1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">set</span>() &lt;&lt; endl;<span class="comment">// 所有位都置为1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">set</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">// 将下标为1的元素置为 0</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">reset</span>() &lt;&lt; endl;<span class="comment">// 将所有位置为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">10010111</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    <span class="number">8</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">01101000</span></span><br><span class="line">    <span class="number">01101001</span></span><br><span class="line">    <span class="number">01101101</span></span><br><span class="line">    <span class="number">11111111</span></span><br><span class="line">    <span class="number">11111101</span></span><br><span class="line">    <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;10010111&quot;</span>;</span><br><span class="line">    bitset &lt;8&gt; <span class="built_in">n</span>(str);</span><br><span class="line">    string s = n.<span class="built_in">to_string</span>();</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将bitset转换为无符号的long</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h = n.<span class="built_in">to_ulong</span>();</span><br><span class="line">    cout &lt;&lt; h &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">10010111</span></span><br><span class="line">    <span class="number">151</span></span><br><span class="line">    <span class="number">151</span></span><br></pre></td></tr></table></figure>

<h2 id="next-permutation-全排列"><a href="#next-permutation-全排列" class="headerlink" title="next_permutation 全排列"></a>next_permutation 全排列</h2><p>prev_permutation前一个排列组合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>输出 n 个数的全排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">关于<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    </span><br><span class="line">其功能是循环从输入流读取n，直到遇到EOF为止，<span class="built_in">scanf</span>()函数返回成功赋值的数据项数，出错时则返回，EOF定义为<span class="number">-1</span>。~是按位取反，<span class="number">-1</span>十六进制补码表示为<span class="number">0xffffffff</span>，f是二进制的<span class="number">1111</span>，取反后就全部变成<span class="number">0</span>了，于是<span class="keyword">while</span>结束。只有返回值为EOF（即<span class="number">-1</span>）时，其取反的的值（即<span class="keyword">while</span>循环的判断条件）才为<span class="number">0</span>，才能结束循环，其它输入情况下（无论是否输入成功）<span class="keyword">while</span>循环的判断条件为非<span class="number">0</span>，即为真。</span><br></pre></td></tr></table></figure>

<h2 id="reverse-翻转函数"><a href="#reverse-翻转函数" class="headerlink" title="reverse 翻转函数"></a>reverse 翻转函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//算法库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">reverse</span>(b, b + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : b) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort 排序函数"></a>sort 排序函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//算法库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入一个随机准则，time(0)是现在到1970-1-1的秒数</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//随机打乱顺序</span></span><br><span class="line">    <span class="built_in">random_shuffle</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reverse-翻转函数-1"><a href="#reverse-翻转函数-1" class="headerlink" title="reverse 翻转函数"></a>reverse 翻转函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(<span class="number">12321</span>);</span><br><span class="line">    <span class="comment">// 翻转以后返回字符串</span></span><br><span class="line">    string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">    cout &lt;&lt; (str == str2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="unique-去重函数"><a href="#unique-去重函数" class="headerlink" title="unique 去重函数"></a>unique 去重函数</h2><p>这是一个<strong>去重</strong>函数 （同时将数组从小到大排序 重复出现的元素放到容器尾部）</p>
<p>unique(num,mun+n)返回的是num去重后的尾地址，之所以说比不真正把重复的元素删除，其实是，该函数把重复的元素移到后面去了，然后依然保存到了原数组中，然后返回去重后最后一个元素的地址，<strong>因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">需要添加头文件：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;abbbccbba&quot;</span>;</span><br><span class="line">    str.<span class="built_in">erase</span>((<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>())), str.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：abcba</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    res.<span class="built_in">erase</span>((<span class="built_in">unique</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>())), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : res) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><p>利用二分查找在已排序的数组中查找元素</p>
<p>lower_bound(begin,end,num) 找到第一个大于或等于num的数字 返回该数字的地址 否则返回end</p>
<p>通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。即 lower_bound(begin,end,num) - begin</p>
<p>upper_bound(begin,end,num) 找到第一个大于num的数字 返回该数字的地址 否则返回end</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">添加头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 通过返回的地址减去起始地址begin,得到找到数字在数组中的下标</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">lower_bound</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), <span class="number">3</span>) - res.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, a);<span class="comment">// 在左边补上空格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-5d\n&quot;</span>, a);<span class="comment">// 在右边补上空格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5.1lf\n&quot;</span>, b);<span class="comment">// 小数长度为5，并且保留一位小数，不够时前面补空格（小数点也算一位）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05.1lf\n&quot;</span>, b);<span class="comment">// 小数长度为5，并且保留一位小数，不够时前面补0（小数点也算一位）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">   <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">  <span class="number">5.0</span></span><br><span class="line"><span class="number">005.0</span></span><br></pre></td></tr></table></figure>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>关于数据范围：大题的题目中会给出相应的数据范围，根据题目的数据范围来选择数据型是int 还是long long 还是其他类型，注意如果是使用long long的话，要用%i64d（i大写）进行输入输出，如果是平常做题过程中使用%lld进行输入输出。（用%i64d（i大写）还是%lld根据情况而定，如果Windows评测机采用%i64d（i大写）；如果Linux评测机采用%lld）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">蓝桥杯输入/出 <span class="type">long</span> <span class="type">long</span>数据需要使用的是</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%I64d&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>蓝色桥杯最大栈空间为256MB，经过换算， 你最大可以<strong>开 1 * 10的7次方左右的数组空间</strong>。也就是<strong>1千万</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="number">0</span>～<span class="number">4294967295</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">int</span> <span class="number">-2147483648</span>～<span class="number">2147483647</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="number">0</span>～<span class="number">4294967295</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">long</span> <span class="number">-2147483648</span>～<span class="number">2147483647</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>的最大值：<span class="number">9223372036854775807</span> <span class="comment">// 18及以下位数都可装 19位也差不多</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>的最小值：<span class="number">-9223372036854775808</span> <span class="comment">// 18及以下位数都可装 19位也差不多</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>的最大值：<span class="number">18446744073709551615</span> <span class="comment">//20位</span></span><br><span class="line"><span class="comment">// 下面用的可能没有接触过， 但存在， 有上面的就够了， 下面和上面的long long 是一样的。</span></span><br><span class="line">__int64的最大值：<span class="number">9223372036854775807</span>__</span><br><span class="line"></span><br><span class="line">int64的最小值：<span class="number">-9223372036854775808</span></span><br><span class="line"><span class="type">unsigned</span> __int64的最大值：<span class="number">18446744073709551615</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> </span><br><span class="line"><span class="comment">// 当需要多次使用一个表达式的值的时候， 可以存起来。 这样可以减少计算次数。</span></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n * b * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改为</span></span><br><span class="line"><span class="type">int</span> n  = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> t = n * b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="comment">// 计算一个数组 / 或者字符串长度的时候， 最后一直存着，以免多次计算。 </span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> </span><br><span class="line"><span class="comment">// 位运算符的应用</span></span><br><span class="line"><span class="comment">// 如:</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> i =  n* <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =  n / <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 可以更改为</span></span><br><span class="line"><span class="type">int</span> i = n &lt;&lt; <span class="number">1</span>; <span class="comment">// 相信我会快。</span></span><br><span class="line"><span class="type">int</span> c =  n &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">// 对于for循环同样使用。</span></span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">while</span>(i &amp; <span class="number">1</span>)&#123; <span class="comment">// 用位运算代替</span></span><br><span class="line">--i;<span class="comment">// 前自减/增 比 后自减/增快。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = i--;</span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="type">int</span> x = i;</span><br><span class="line">--i;<span class="comment">// 这样结果一样， 但编译后，会少一条汇编指令。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer刷题记录</title>
    <url>/2022/03/27/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></p>
<p><strong>原地哈希做法：时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i &amp;&amp; nums[nums[i]] != nums[i]) <span class="built_in">swap</span>(nums[nums[i]], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i &amp;&amp; nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>哈希表做法：时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ++hash[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums[i]] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关于原地哈希算法：时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(1)</em></strong></p>
<p>原地哈希用来解决这样一种问题：需要一个使得数组尽量有序的方式，并且要求时间复杂度达到O(n)。</p>
<p>一个长度为n的数组，所有的数都不相同，且数据的范围为[1,n]，如何在O(n)的时间复杂度内完成排序。</p>
<p><strong>原地哈希原理:</strong></p>
<p>实际上，我们在做一般排序的时候，是基于数字具体值的大小来决定顺序的，也就是说，数字具体值决定了数字应该去的位置。长度为n个数组，所有的数均不相同，不妨我们就让num[i]去到索引为num[i]的位置。实际上，num[i]就应该去索引为num[i]的位置上。</p>
<p>上述思路每一个位置上的置换都可以至少让一个数成功归位，因此复杂度为O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地哈希</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">while</span> (nums[i] - <span class="number">1</span> != i)</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></p>
<p><strong>暴力做法：</strong></p>
<p><strong>时间复杂度：<em>O(n * log<sub>2<sub>n)</em></strong></p>
<p>将数据进行排序，预设答案为ans &#x3D; 1(ans为没有枚举到的答案的最小可能值)，开始遍历整个数组，如果发生了 ans &#x3D;&#x3D; num[i]，则ans++(因为这个数字出现了，我们要看下一个数字有没有出现)。如果发生了num[i] &gt; ans的情况，由ans自增的逻辑我们可以知道，在数据保持相邻不变或者递增1的情况下，ans &gt;&#x3D; num[i]是必定成立的，如果num[i]&gt;ans，则一定是发生了跳跃，此时ans必为答案。如果能够循环到数组结束，那么答案就是ans。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == ans) &#123;</span><br><span class="line">                ans++; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; ans) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>原地哈希做法：</strong></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        	<span class="comment">// nums[i] &gt; 0 （数值小于1的数，对答案没有任何贡献，所以可以直接忽略）</span></span><br><span class="line">        	<span class="comment">// nums[i] &lt;= len 一个长度为 len 的数组，他所能够形成的答案的最大值为 len + 1</span></span><br><span class="line">        	<span class="comment">// nums[nums[i]] != nums[i] （如果数组中有重复的数，他们可能会形成闭合的死循环，此处避免无限交换）</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i]]!=nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></p>
<p><strong>思路：</strong></p>
<p>从整个矩阵的右上角开始枚举，假设当前枚举的数是 x：<br>如果 x 等于 target，则说明我们找到了目标值，返回true；<br>如果 x 小于 target，则 x 左边的数一定都小于 target，我们可以直接排除当前一整行的数；<br>如果 x 大于 target，则 x 下边的数一定都大于 target，我们可以直接排序当前一整列的数。</p>
<p><strong>时间复杂度：<em>O(n + m)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target) j--;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">        &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> targe = <span class="number">20</span>;</span><br><span class="line">    <span class="type">bool</span> have = <span class="built_in">findNumberIn2DArray</span>(matrix, targe);</span><br><span class="line">    cout &lt;&lt; have &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) str += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> str += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) str += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> str += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">replaceSpace</span>(<span class="string">&quot;&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 循环构造链表</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环输出原链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    Solution solution;</span><br><span class="line">    ans = solution.<span class="built_in">reversePrint</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></p>
<p><strong>思路：</strong></p>
<ol>
<li>先利用前序遍历找根节点 k ：前序遍历的第一个数，就是根节点的值；</li>
<li>在中序遍历中找到根节点的位置 k，则 k 左边是左子树的中序遍历，右边是右子树的中序遍历；</li>
<li>假设左子树的中序遍历的长度是 l，则在前序遍历中，根节点后面的 l 个数，是左子树的前序遍历，剩下的数是右子树的前序遍历；</li>
<li>有了左右子树的前序遍历和中序遍历，我们可以先递归创建出左右子树，然后再创建根节点；</li>
</ol>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 采用哈希表几率中序遍历各个节点的位置，方便查询，因为哈希表查询是O(1)的</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="comment">// 定义全局变量，方便多函数使用</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorder, inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; _preorder, vector&lt;<span class="type">int</span>&gt;&amp; _inorder)</span> </span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">             hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs(前序遍历开头，结尾，中序遍历开头，结尾)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果左边大于右边了，说明到叶子节点了</span></span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 根节点就是前序遍历的第一个点</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pl]);</span><br><span class="line">        <span class="comment">// 根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="type">int</span> k = hash[preorder[pl]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归前序遍历和中序遍历得到左右子树的根节点</span></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(pl + <span class="number">1</span>, pl + k - il, il, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">dfs</span>(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h1><p><a href="https://www.acwing.com/activity/content/problem/content/214/">二叉树的下一个节点</a></p>
<p><strong>思路：</strong></p>
<ol>
<li>如果给的点有右儿子，那就是右子树最左边的那个点</li>
<li>如果给的点没有右儿子，那就看他有没有父节点，如果这个点有父节点，并且他是父节点的左儿子，那这个点的后继就是他的父节点</li>
<li>如果给的点没有右儿子，并且他是父节点的右儿子，那就要顺着父节点一直往上找，一直到这个点是父节点的左儿子，那后继就是这个父节点</li>
<li>如果根据3，找不到，就说明这个点没有后继</li>
</ol>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode *father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果给的点有右儿子，那就是右子树最左边的那个点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) &#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果给的点没有右儿子，那就看他有没有父节点，如果这个点有父节点，并且他是父节点的左儿子，那这个点的后继就是他的父节点</span></span><br><span class="line">        <span class="comment">// 如果给的点没有右儿子，并且他是父节点的右儿子，那就要顺着父节点一直往上找，一直到这个点是父节点的左儿子，那后继就是这个父节点</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;father &amp;&amp; p-&gt;father-&gt;right == p) &#123;</span><br><span class="line">            p = p-&gt;father;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;father &amp;&amp; p-&gt;father-&gt;left == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果还找不到，就说明这个点没有后继</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码（简化版）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode *father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">             p = p-&gt;right;</span><br><span class="line">             <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = stk.<span class="built_in">top</span>();</span><br><span class="line">            cache.<span class="built_in">push</span>(i);</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = cache.<span class="built_in">top</span>();</span><br><span class="line">        cache.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (cache.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = cache.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">            cache.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列</a></p>
<p><strong>思路：</strong></p>
<p>模拟一遍即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            c = a % <span class="number">1000000007</span> + b % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            c = a % <span class="number">1000000007</span> + b % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">fib</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶问题</a></p>
<p><strong>思路：dp思想</strong></p>
<p>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。</p>
<ol>
<li>当为 1 级台阶： 此情况共有 f(n−1) 种跳法；</li>
<li>当为 2 级台阶： 此情况共有 f(n−2) 种跳法。</li>
</ol>
<p>f(n) 为以上两种情况之和，即 f(n) &#x3D; f(n - 1) + f(n - 2) ，以上递推性质为斐波那契数列。本题可转化为求斐波那契数列第 n 项的值 。<br>青蛙跳台阶问题： f(0)&#x3D;1, f(1)&#x3D;1 , f(2)&#x3D;2；<br>斐波那契数列问题： f(0)&#x3D;0, f(1)&#x3D;1, f(2)&#x3D;1。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            c = a % <span class="number">1000000007</span> + b % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></p>
<p><strong>二分做法：<em>O(log<sub>2<sub>n)</em></strong></p>
<ol>
<li><p>去掉最后面的一段<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-39-20.png" alt="在这里插入图片描述"></p>
</li>
<li><p>如果是单调的，那么直接返回第一个数即可</p>
</li>
<li><p>通过二分查找排在最前面的比nums[0]小的数，就是最小值</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; numbers[n] == numbers[<span class="number">0</span>]) n--;</span><br><span class="line">        <span class="keyword">if</span> (numbers[n] &gt;= numbers[<span class="number">0</span>]) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt;= numbers[<span class="number">0</span>]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>暴力做法：时间复杂度：<em>O(n)</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minv = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            minv = <span class="built_in">min</span>(minv, numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径</a></p>
<p><strong>时间复杂度：<em>O(3<sup>n</sup>)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 其中的0是已经有0个字母合法，当合法字母数量与word字符数量相同时，就可以返回true了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, <span class="number">0</span>, i, j, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> u, <span class="type">int</span> i, <span class="type">int</span> j, string &amp;word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里一定要记得-1，因为u是从0开始的，笔者之前忘记-1了，调试过后才发现是这里错了</span></span><br><span class="line">        <span class="keyword">if</span> (u == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照上，右，下，左枚举</span></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将走过的路径保存下来，并且置为&#x27;*&#x27;，避免走回头路</span></span><br><span class="line">        <span class="type">char</span> t = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> a = i + dx[k], b = j + dy[k];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; board.<span class="built_in">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, u + <span class="number">1</span>, a, b, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 其中的0是已经有0个字母合法，当合法字母数量与word字符数量相同时，就可以返回true了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, <span class="number">0</span>, i, j, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> u, <span class="type">int</span> i, <span class="type">int</span> j, string &amp;word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里一定要记得-1，因为u是从0开始的，笔者之前忘记-1了，调试过后才发现是这里错了</span></span><br><span class="line">        <span class="keyword">if</span> (u == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照上，右，下，左枚举</span></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将走过的路径保存下来，并且置为&#x27;*&#x27;，避免走回头路</span></span><br><span class="line">        <span class="type">char</span> t = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> a = i + dx[k], b = j + dy[k];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; board.<span class="built_in">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, u + <span class="number">1</span>, a, b, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; board = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    string word = <span class="string">&quot;ABCCED&quot;</span>;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">exist</span>(board, word) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></p>
<p><strong>解法选择：</strong></p>
<p>此类问题可以用深度优先遍历和宽度优先遍历，但是当数据范围比较大的时候，可能会栈溢出，所以这里使用宽度优先遍历解答</p>
<p><strong>时间复杂度：O(n * m)</strong></p>
<p>bfs时间复杂度就是所有的格子遍历一遍，也就是n * m，根据数据范围可知，最多是2500个格子</p>
<p><strong>注意：剑指offer系列和LeetCode特色就是有一些特判的边界</strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算一个数的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个坐标的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_single_sum</span>(t.first) + <span class="built_in">get_single_sum</span>(t.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (!m || !n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义一个二维数组st，用来储存已经走过的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 用来存放遍历到的每一个坐标，所以用pair类型的队列</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先给队列里面放入初始位置的坐标</span></span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果对头元素没有走过，并且各个位之和也符合要求的话才能++，否则continue</span></span><br><span class="line">            <span class="keyword">if</span> (st[t.first][t.second] || <span class="built_in">get_sum</span>(t) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算一个数的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个坐标的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_single_sum</span>(t.first) + <span class="built_in">get_single_sum</span>(t.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (!m || !n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义一个二维数组st，用来储存已经走过的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 用来存放遍历到的每一个坐标，所以用pair类型的队列</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先给队列里面放入初始位置的坐标</span></span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果对头元素没有走过，并且各个位之和也符合要求的话才能++，否则continue</span></span><br><span class="line">            <span class="keyword">if</span> (st[t.first][t.second] || <span class="built_in">get_sum</span>(t) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">movingCount</span>(m, n, k) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剪绳子</a></p>
<p><strong>思路：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-40-28.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码（可以先看最后会不会余下4或者2）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码（也可以先把3减掉，看剩下的是多少）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">6</span>) res *= <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">5</span>) res *= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">4</span>) res *= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">6</span>) res *= <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">5</span>) res *= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">4</span>) res *= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">cuttingRope</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a>剪绳子 II</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>思路一：</strong></p>
<p>res用long long</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n -= <span class="number">3</span>, res %= <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>res仅用int，把res * 3可能溢出int，那就res 加3次，用加法代替乘法即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    	<span class="comment">// 加法代替乘法</span></span><br><span class="line">        <span class="type">int</span> temp = res;</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">        res %= <span class="number">1000000007</span>;</span><br><span class="line">        res += temp;</span><br><span class="line">        res %= <span class="number">1000000007</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></p>
<p><strong>思路：</strong></p>
<p>n &amp; 1 看最后一位是否是1，n &gt;&gt;&#x3D; 1 去掉最后一位</p>
<p><strong>时间复杂度：<em>O(log<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">uint32_t</span> n = <span class="number">-3</span>;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">hammingWeight</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></p>
<p><strong>思路：</strong></p>
<p>快速幂，将幂次变成二进制幂次即可</p>
<p><strong>时间复杂度：<em>O(log<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n2 = <span class="built_in">abs</span>((<span class="type">long</span> <span class="type">long</span>)n);</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2 &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">            n2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = x * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n2 = <span class="built_in">abs</span>((<span class="type">long</span> <span class="type">long</span>)n);</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2 &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">            n2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = x * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">myPow</span>(x, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">pow</span>(<span class="number">10</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h1><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>方法一：</strong></p>
<p>由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。我们可以换一种思路，将下一个节点的值复制到当前节点，然后将下一个节点删除即可。</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i是最后一个点，那就重新遍历，删除最后一个点</span></span><br><span class="line">        <span class="keyword">if</span> (!i-&gt;next) &#123;</span><br><span class="line">            i = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (; i-&gt;next &amp;&amp; i-&gt;next-&gt;next; i = i-&gt;next);</span><br><span class="line">            i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则将下一个节点的值复制到当前节点，然后将下一个节点删除即可</span></span><br><span class="line">        i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出链表规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i是最后一个点，那就重新遍历，删除最后一个点</span></span><br><span class="line">        <span class="keyword">if</span> (!i-&gt;next) &#123;</span><br><span class="line">            i = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (; i-&gt;next &amp;&amp; i-&gt;next-&gt;next; i = i-&gt;next);</span><br><span class="line">            i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则将下一个节点的值复制到当前节点，然后将下一个节点删除即可</span></span><br><span class="line">        i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是自己构造一个链表，用来测试样例</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入要删除的节点：&quot;</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    cin &gt;&gt; val;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点后的链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> head = solution.<span class="built_in">deleteNode</span>(dummy-&gt;next, val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>找到那个要删除的节点，把这个节点后面的节点的值全部前移，然后把最后一个点删掉</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!i-&gt;next) &#123;</span><br><span class="line">            i = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (; i-&gt;next-&gt;next; i = i-&gt;next);</span><br><span class="line">            i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i; i-&gt;next-&gt;next; i = i-&gt;next) &#123;</span><br><span class="line">            i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<p>记录要删除的点是第几个点，然后再重新遍历一遍，把他删掉</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = dummy;</span><br><span class="line">        <span class="keyword">while</span> (res--) &#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="在O-1-时间删除链表结点"><a href="#在O-1-时间删除链表结点" class="headerlink" title="在O(1)时间删除链表结点"></a>在O(1)时间删除链表结点</h1><p><a href="https://www.acwing.com/problem/content/description/85/">在O(1)时间删除链表结点</a></p>
<p><strong>思路：</strong></p>
<p>由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。</p>
<p>我们可以换一种思路，将下一个节点的值复制到当前节点，然后将下一个节点删除即可。</p>
<p>只有常数次操作，所以时间复杂度是 O(1)O(1)。</p>
<p><strong>时间复杂度：<em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h1><p><a href="https://www.acwing.com/problem/content/27/">删除链表中重复的节点</a></p>
<p><strong>方法一：</strong></p>
<p>双指针算法：从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。</p>
<ol>
<li>p是上一个区间里面的最后一个节点</li>
<li>q是下一个区间里面的第一个节点<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-41-26.png" alt="在这里插入图片描述"></li>
<li>如果 <code>p-&gt;next-&gt;next != q</code> ， 如上图所示，那么就要删除这一整段，即 <code>p-&gt;next = q</code> ，如下图所示<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-41-49.png" alt="在这里插入图片描述"></li>
<li>如果下个区间里面只有 <code>p-&gt;next</code> 这一个元素，那么这个点满足要求，那么p移动到下个点也就是 <code>p-&gt;next</code> ，<code>if (p-&gt;next-&gt;next == q) p = p-&gt;next;</code>  ，如下两图所示<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-42-13.png" alt="在这里插入图片描述"></li>
</ol>
<p><strong>时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">// p是上一个区间里面的最后一个节点</span></span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// q是下一个区间里面的第一个节点</span></span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            <span class="comment">// q一直往后，直到移动到下下个区间的第一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;</span><br><span class="line">            <span class="comment">// 如果下个区间里面只有一个元素，那么这个点满足要求，那么p移动到下个点，这个点是这个区间唯一的点，所以也是这个区间最后的一个点</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;next == q) p = p-&gt;next;</span><br><span class="line">            <span class="comment">// 否则把下个区间整段删掉，p还是原区间最后一个节点</span></span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>用哈希表，扫描一次链表，把只出现一次的数存起来。然后再扫描链表，将只出现一次的数筛选出来接上。</p>
<p><strong>时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            hash[i-&gt;val]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i-&gt;val] == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = i;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除末尾重复的数</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next &amp;&amp; p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">// 如果所有数全部重复，则直接接上NULL</span></span><br><span class="line">        <span class="keyword">if</span> (s == k) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出链表规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            hash[i-&gt;val]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i-&gt;val] == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = i;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next &amp;&amp; p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == k) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="comment">// 这里是自己构造一个链表，用来测试样例</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点后的链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> head = solution.<span class="built_in">deleteDuplication</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<p>利用有序哈希表存储出现的次数，将只出现一次的接在新的链表末尾。</p>
<p><strong>时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            hash[i-&gt;val]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.second == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(x.first);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串</a><br>很多情况需要排除，只能多做才能熟练</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k--;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, k + <span class="number">1</span>); <span class="comment">// 除去后空格</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++; <span class="comment">// 除去前空格</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) i++; <span class="comment">// 除去+, -</span></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 除去+, -, +., -., .</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dot = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                dot++;</span><br><span class="line">                <span class="keyword">if</span> (dot &gt; <span class="number">1</span> || e) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果有两个小数点，或者e后面有小数点，则false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                e++;</span><br><span class="line">                <span class="keyword">if</span> (!i || i + <span class="number">1</span> == s.<span class="built_in">size</span>() || e &gt; <span class="number">1</span> || (s[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; i == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1231e+</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k--;</span><br><span class="line">    s = s.<span class="built_in">substr</span>(<span class="number">0</span>, k + <span class="number">1</span>);  <span class="comment">// 除去后空格</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++; <span class="comment">// 除去前空格</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) i++; <span class="comment">// 除去+, -</span></span><br><span class="line">    s = s.<span class="built_in">substr</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 除去+, -, +., -., .</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dot = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dot++;</span><br><span class="line">            <span class="keyword">if</span> (dot &gt; <span class="number">1</span> || e) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果有两个小数点，或者e后面有小数点，则false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            e++;</span><br><span class="line">            <span class="keyword">if</span> (!i || i + <span class="number">1</span> == s.<span class="built_in">size</span>() || e &gt; <span class="number">1</span> || (s[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; i == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">2</span> == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1231e+</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isNumber</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p>警惕数组越界即可，即应该先判断 l &lt;&#x3D; r, r &gt;&#x3D; l</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] % <span class="number">2</span> == <span class="number">1</span>) l++;</span><br><span class="line">            <span class="keyword">while</span> (r &gt;= l &amp;&amp; nums[r] % <span class="number">2</span> == <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) <span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] % <span class="number">2</span> == <span class="number">1</span>) l++;</span><br><span class="line">            <span class="keyword">while</span> (r &gt;= l &amp;&amp; nums[r] % <span class="number">2</span> == <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) <span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; n = solution.<span class="built_in">exchange</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : n) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n + <span class="number">1</span> - k;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码(迭代法)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = pn) &#123;</span><br><span class="line">            pn = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出链表规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = pn) &#123;</span><br><span class="line">            pn = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是自己构造一个链表，用来测试样例</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> head = solution.<span class="built_in">reverseList</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码(递归法)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> tail = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a></p>
<p><strong>思路：</strong></p>
<p>类似归并排序的算法</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l1p = l1, l2p = l2;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1p &amp;&amp; l2p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1p-&gt;val &lt;= l2p-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1p;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1p = l1p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2p;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2p = l2p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1p) &#123;</span><br><span class="line">            cur-&gt;next = l1p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            l1p = l1p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2p) &#123;</span><br><span class="line">            cur-&gt;next = l2p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            l2p = l2p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></p>
<p><strong>时间复杂度：<em>O(nm)</em></strong></p>
<p>最坏情况下，我们对于树A中的每个节点都要递归判断一遍，每次判断在最坏情况下需要遍历完树B中的所有节点。<br>所以时间复杂度是 O(nm)，其中 n 是树A中的节点数， m 是树B中的节点数。</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPart</span>(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPart</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A &amp;&amp; A-&gt;val == B-&gt;val) <span class="keyword">return</span> <span class="built_in">isPart</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">isPart</span>(A-&gt;right, B-&gt;right); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></p>
<p><strong>思路：</strong></p>
<p>我们可以发现镜像后的树就是将原树的所有节点的左右儿子互换！<br>所以我们递归遍历原树的所有节点，将每个节点的左右儿子互换即可。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* p;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root;</span><br><span class="line">        p = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = p;</span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; r || l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;val == r-&gt;val) <span class="keyword">return</span> <span class="built_in">dfs</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> di[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dj[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; k &lt; n * m; k++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> a = i + di[r], b = j + dj[r];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; m &amp;&amp; f[a][b] == <span class="number">0</span>) &#123;</span><br><span class="line">                i = a, j = b;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = (r + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                i = i + di[r], j = j + dj[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈</a></p>
<p><strong>思路：</strong></p>
<p><strong>单调栈：</strong><br>我们除了维护基本的栈结构之外，还需要维护一个单调栈，来实现返回最小值的操作。<br>下面介绍如何维护单调栈：</p>
<ul>
<li>当我们向栈中压入一个数时，如果该数 ≤ 单调栈的栈顶元素，则将该数同时压入单调栈中；否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。</li>
<li>当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。</li>
<li>单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数。</li>
</ul>
<p><strong>时间复杂度：<em>O(1)</em></strong></p>
<p>四种操作都只有常数次入栈出栈操作，所以时间复杂度都是O(1)</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; res, cache;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push</span>(x);</span><br><span class="line">            cache.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">top</span>() &gt;= x) cache.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">top</span>() == cache.<span class="built_in">top</span>()) cache.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列</a></p>
<p><strong>思路：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-43-21.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushed.<span class="built_in">empty</span>() &amp;&amp; pushed.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pushed.<span class="built_in">size</span>() != popped.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : pushed) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushed.<span class="built_in">empty</span>() &amp;&amp; pushed.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pushed.<span class="built_in">size</span>() != popped.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : pushed) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pushed = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; popped = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">validateStackSequences</span>(pushed, popped) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a>从上到下打印二叉树 II</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (level.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">                level.<span class="built_in">clear</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树-III"><a href="#从上到下打印二叉树-III" class="headerlink" title="从上到下打印二叉树 III"></a>从上到下打印二叉树 III</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/">从上到下打印二叉树 III</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">        <span class="comment">// 奇数行为false</span></span><br><span class="line">        <span class="type">bool</span> z = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (level.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偶数行翻转level</span></span><br><span class="line">                <span class="keyword">if</span> (z) <span class="built_in">reverse</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>());</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">                level.<span class="built_in">clear</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偶数行为true</span></span><br><span class="line">                z = !z;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列</a></p>
<p><strong>思路：</strong></p>
<p><strong>合法样例:</strong><br>后序遍历二叉树，10为根节点，左子树的所有节点都比根节点小，右子树的所有点都比根节点大<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-43-48.png" alt="在这里插入图片描述"><br>递归左右子树<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-44-04.png" alt="在这里插入图片描述"><br><strong>不合法样例</strong><br>无法分成比10小和比10大的左右两边<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-44-17.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        pos = postorder;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, pos.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> root = pos[r];</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; r &amp;&amp; pos[k] &lt;= root; k++);</span><br><span class="line">        <span class="type">int</span> tempR = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[k] &gt; root) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(l, tempR) &amp;&amp; <span class="built_in">dfs</span>(tempR + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></p>
<p><strong>思路：</strong></p>
<p>直接DFS走一遍即可</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> tar;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        tar = target;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, u, res);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* &amp;root, <span class="type">int</span> u, vector&lt;<span class="type">int</span>&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        u += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (u == tar &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, u, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, u, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></p>
<p><strong>方法一：</strong></p>
<p>哈希表存储原链表节点和新链表节点的对应关系，先构建只有 next 的新链表<br>然后再遍历原链表，把原链表的 random 对应的哈希表储存的节点赋给新链表的 random</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 哈希表存储原链表节点和新链表节点的对应关系</span></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-10005</span>);</span><br><span class="line">    <span class="comment">// 当前遍历到的节点</span></span><br><span class="line">    Node* cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> np = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val); </span><br><span class="line">            cur-&gt;next = np;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            hash.<span class="built_in">insert</span>(&#123;p, np&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random) &#123;</span><br><span class="line">                cur = hash[p];</span><br><span class="line">                cur-&gt;random = hash[p-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>原链表图形：<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-45-46.png" alt="Snipaste_2022-02-19_18-54-11.png"><br>1、在每个节点的后面加上它的复刻，将原链表和复刻链表连在一起。<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-46-06.png" alt="Snipaste_2022-02-19_18-54-24.png"><br>2、从前往后遍历每一个原链表节点，对于有random指针的节点p，我们让它的<br>p-&gt;next-&gt;random &#x3D; p-&gt;random-&gt;next,这样我们就完成了对原链表random指针的复刻。<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-46-23.png" alt="Snipaste_2022-02-19_18-58-52.png"><br>3、最后我们把原链表和复刻链表拆分出来，并将原链表复原。<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-46-37.png" alt="Snipaste_2022-02-19_18-59-00.png"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> np = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            np-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = np;</span><br><span class="line">            p = np-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-10005</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next = p-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前面破坏了原链表，这里要恢复链表</span></span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/"> 二叉搜索树与双向链表</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p>原地算法，没有新建任何节点</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        pair&lt;Node*, Node*&gt; sides = <span class="built_in">dfs</span>(root);</span><br><span class="line">        sides.first-&gt;left = sides.second;</span><br><span class="line">        sides.second-&gt;right = sides.first;</span><br><span class="line">        <span class="keyword">return</span> sides.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;Node*, Node*&gt; <span class="title">dfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> &#123;root, root&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lside = <span class="built_in">dfs</span>(root-&gt;left), rside = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            lside.second-&gt;right = root, root-&gt;left = lside.second;</span><br><span class="line">            rside.first-&gt;left = root, root-&gt;right = rside.first;</span><br><span class="line">            <span class="keyword">return</span> &#123;lside.first, rside.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lside = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            lside.second-&gt;right = root, root-&gt;left = lside.second;</span><br><span class="line">            <span class="keyword">return</span> &#123;lside.first, root&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> rside = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            rside.first-&gt;left = root, root-&gt;right = rside.first;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, rside.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/submissions/">序列化二叉树</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">dfs_s</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, string &amp;res)</span> </span>&#123; <span class="comment">// 构造前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            res += <span class="string">&quot;null &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">dfs_s</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">dfs_s</span>(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(string data, <span class="type">int</span> &amp;u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == data.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u; <span class="comment">// 记录当前这个数是几位数</span></span><br><span class="line">        <span class="keyword">while</span> (data[k] != <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前字符串是“null”，则回到下一个数字的首部，表示这次构造的是一个null节点，并没孩子节点，所以跳过后面的递归</span></span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">            u = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>; <span class="comment">// val存的是当前的数字</span></span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">&#x27;-&#x27;</span>) &#123; <span class="comment">// 如果数字是负的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u + <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + data[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = -val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数字是正的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; k; i++) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + data[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u = k + <span class="number">1</span>; <span class="comment">// 回到下个数字的首部</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/submissions/">字符串的排列</a></p>
<p><strong>思路：</strong></p>
<p>做一次全排列（DFS+回溯），然后用哈希表去重。最容易想到的办法，但是时间复杂度不太好，相当于暴力做法</p>
<p><strong>时间复杂度：<em>O(n<sup>n</sup>)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="type">bool</span> st[<span class="number">10</span>];</span><br><span class="line">    unordered_set&lt;string&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s, u);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(path) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                hash.<span class="built_in">insert</span>(path);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                path += s[i];</span><br><span class="line">                u++;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s, u);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                u--;</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></p>
<p><strong>思路：</strong></p>
<p>超过一半，快排以后取中间的数即可</p>
<p><strong>时间复杂度：<em>O(nlog<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></p>
<p><strong>思路：</strong></p>
<p>快排，取前 k 个数</p>
<p><strong>时间复杂度：<em>O(nlog<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数</a></p>
<p><strong>思路：</strong></p>
<p>暴解肯定不行，因为 n 最多是 50000，n<sup>2</sup>logn会超时。</p>
<p><strong>这题可以使用大小堆算法：</strong> 维护大根堆和小根堆的时间复杂度都是 O(logn)<br>输入的时候将数字分为两半，小的一半放在大根堆中，大的一半放在小根堆的中。输入的同时保证两堆的大小之差不超过一，如果超过，则将数量多的堆弹出堆顶元素放到另一个堆中。<br>取中位数的时候，奇数返回数量多的堆顶元素；偶数返回两堆的堆顶平均数即可。</p>
<p><strong>时间复杂度：<em>O(logn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大根堆，也就是根节点是最大的</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; max_heap; </span><br><span class="line">    <span class="type">int</span> max_num = <span class="number">0</span>; <span class="comment">// 大根堆中节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆，也就是根节点是最小的</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; min_heap; </span><br><span class="line">    <span class="type">int</span> min_num = <span class="number">0</span>; <span class="comment">// 小根堆中节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为空时，插入大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (max_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">            max_num++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// num 如果小于等于大根堆堆顶，就把他插入大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt;= max_heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">            max_num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">            min_num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果大小根堆数量之差大于 1 那么就把多的弹到另一个堆里面</span></span><br><span class="line">        <span class="keyword">if</span> (max_num - min_num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(max_heap.<span class="built_in">top</span>());</span><br><span class="line">            max_heap.<span class="built_in">pop</span>();</span><br><span class="line">            max_num--;</span><br><span class="line">            min_num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_num - max_num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(min_heap.<span class="built_in">top</span>());</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">            max_num++;</span><br><span class="line">            min_num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((max_num + min_num) % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(max_heap.<span class="built_in">top</span>() + min_heap.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max_num &gt; min_num ? (<span class="type">double</span>)max_heap.<span class="built_in">top</span>() : (<span class="type">double</span>)min_heap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></p>
<p><strong>思路：</strong></p>
<p><strong>动态规划：</strong><br>s这个变量中存储的是 以前一个数结尾的子数组中，和最大的是多少<br>如果s &lt; 0，那么就将s置为0，因为可能存在负数，不能将负收益的s加进来<br>如果s &gt;&#x3D; 0，就让s +&#x3D; x。<br>因为是求最大值，所以res的初值置为 无穷小INT_MIN。同时，每一次迭代，都要更新res，也就是res &#x3D; max(res, s)。最后返回的res就是 最大值。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 此时s是以前一个数结尾的子数组中，和最大的是多少</span></span><br><span class="line">        <span class="type">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里s指的是，以当前数结尾的，子数组的和的最大值</span></span><br><span class="line">            s += x;</span><br><span class="line">            res = <span class="built_in">max</span>(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="1～n-整数中-1-出现的次数"><a href="#1～n-整数中-1-出现的次数" class="headerlink" title="1～n 整数中 1 出现的次数"></a>1～n 整数中 1 出现的次数</h1><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">1～n 整数中 1 出现的次数</a></p>
<p><strong>思路：</strong></p>
<p>按位枚举<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-47-27.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)<sup>2</sup></em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把每一位取出来，例如123，放进数组就是[3, 2, 1]</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最高位开始，枚举每一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// left指的是枚举的那一位前面的数，例如枚举的是abcdef中的c，那么left就是ab;，那么right就是def，如果def是三位，t就是10&lt;sup&gt;3</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = num.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                left = left * <span class="number">10</span> + num[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                right = right * <span class="number">10</span> + num[j];</span><br><span class="line">                t *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先将情况①加进去</span></span><br><span class="line">            ans += left * t;</span><br><span class="line">            <span class="comment">// 加入情况②的(2)</span></span><br><span class="line">            <span class="keyword">if</span> (num[i] == <span class="number">1</span>) ans += right + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 加入情况②的(3)</span></span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt; <span class="number">1</span>) ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 offer</category>
      </categories>
      <tags>
        <tag>剑指 offer</tag>
      </tags>
  </entry>
  <entry>
    <title>周赛册</title>
    <url>/2022/03/26/%E5%91%A8%E8%B5%9B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="数组中紧跟-key-之后出现最频繁的数字"><a href="#数组中紧跟-key-之后出现最频繁的数字" class="headerlink" title="数组中紧跟 key 之后出现最频繁的数字"></a>数组中紧跟 key 之后出现最频繁的数字</h1><p><a href="https://leetcode-cn.com/problems/most-frequent-number-following-key-in-an-array/">数组中紧跟 key 之后出现最频繁的数字</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == nums[i] &amp;&amp; i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                hash[nums[i + <span class="number">1</span>]]++;</span><br><span class="line">                <span class="keyword">if</span> (hash[nums[i + <span class="number">1</span>]] &gt; res) &#123;</span><br><span class="line">                    res = hash[nums[i + <span class="number">1</span>]];</span><br><span class="line">                    ans = nums[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mostFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == nums[i] &amp;&amp; i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            hash[nums[i + <span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums[i + <span class="number">1</span>]] &gt; res) &#123;</span><br><span class="line">                res = hash[nums[i + <span class="number">1</span>]];</span><br><span class="line">                ans = nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> key = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">mostFrequent</span>(nums, key) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="将杂乱无章的数字排序"><a href="#将杂乱无章的数字排序" class="headerlink" title="将杂乱无章的数字排序"></a>将杂乱无章的数字排序</h1><p><a href="https://leetcode-cn.com/problems/sort-the-jumbled-numbers/">将杂乱无章的数字排序</a></p>
<p><strong>时间复杂度：<em>O(n * m)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nums2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortJumbled</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; mapping, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">            string zfc = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zfc.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                res2 = res2 * <span class="number">10</span> + zfc[j] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 加密以前的</span></span><br><span class="line">                <span class="type">int</span> resPlus = mapping[zfc[j] - <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 加密过程</span></span><br><span class="line">                res = res * <span class="number">10</span> + resPlus; <span class="comment">// 加密以后的</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash[i] = res2;</span><br><span class="line">            nums2.<span class="built_in">push_back</span>(&#123;res, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums2) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(hash[x.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nums2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortJumbled</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; mapping, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">            string zfc = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zfc.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                res2 = res2 * <span class="number">10</span> + zfc[j] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 加密以前的</span></span><br><span class="line">                <span class="type">int</span> resPlus = mapping[zfc[j] - <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 加密过程</span></span><br><span class="line">                res = res * <span class="number">10</span> + resPlus; <span class="comment">// 加密以后的</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash[i] = res2;</span><br><span class="line">            nums2.<span class="built_in">push_back</span>(&#123;res, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums2) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(hash[x.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mapping = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">991</span>,<span class="number">338</span>,<span class="number">38</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans = solution.<span class="built_in">sortJumbled</span>(mapping, nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : ans) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="有向无环图中一个节点的所有祖先"><a href="#有向无环图中一个节点的所有祖先" class="headerlink" title="有向无环图中一个节点的所有祖先"></a>有向无环图中一个节点的所有祖先</h1><p><a href="https://leetcode-cn.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/">有向无环图中一个节点的所有祖先</a></p>
<p><strong>思路：记忆化dfs(时间及其慢)，bfs(推荐)</strong></p>
<p><strong>dfs最坏时间复杂度：<em>O(n<sup>n</sup>)</em></strong></p>
<p><strong>核心代码(dfs)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 储存父亲的哈希表（不是祖宗）</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除重复祖宗的哈希表</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; reRes;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getAncestors</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            <span class="comment">// edge[1]的父亲是edge[0]</span></span><br><span class="line">            fa[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            hash.<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            reRes.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">jyh</span>(n);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, i, jyh);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : reRes) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">            ans[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; fa, <span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; jyh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jyh[i].<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; fa[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            reRes.<span class="built_in">insert</span>(fa[i][j]);</span><br><span class="line">            jyh[i].<span class="built_in">push_back</span>(fa[i][j]);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, fa[i][j], jyh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>ACM模式代码(dfs)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 储存父亲的哈希表（不是祖宗）</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除重复祖宗的哈希表</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; reRes;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getAncestors</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            <span class="comment">// edge[1]的父亲是edge[0]</span></span><br><span class="line">            fa[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            hash.<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            reRes.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">jyh</span>(n);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, i, jyh);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : reRes) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">            ans[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; fa, <span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; jyh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jyh[i].<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; fa[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            reRes.<span class="built_in">insert</span>(fa[i][j]);</span><br><span class="line">            jyh[i].<span class="built_in">push_back</span>(fa[i][j]);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, fa[i][j], jyh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">8</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges = &#123;&#123;<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">7</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = solution.<span class="built_in">getAncestors</span>(n, edges);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; p[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; p[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j != p[i].<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != p.<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;],&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合字符串"><a href="#组合字符串" class="headerlink" title="组合字符串"></a>组合字符串</h1><p><a href="https://www.acwing.com/problem/content/4311/">组合字符串</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> s1_len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> s2_len = s2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1sta = <span class="number">1</span>, s2sta = <span class="number">0</span>;</span><br><span class="line">    s3 += s1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (; s1sta &lt; s1_len &amp;&amp; s2sta &lt; s2_len; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (s1[s1sta] &lt; s2[s2sta] &amp;&amp; s1sta &lt; s1_len &amp;&amp; s2sta &lt; s2_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            s3 += s1[s1sta];</span><br><span class="line">            s1sta++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s1[s1sta] &gt;= s2[s2sta] &amp;&amp; s1sta &lt; s1_len &amp;&amp; s2sta &lt; s2_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            s3 += s2[s2sta];</span><br><span class="line">            s2sta++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1sta == <span class="number">0</span>) s3 += s1[s1sta];</span><br><span class="line">    <span class="keyword">if</span> (s2sta == <span class="number">0</span>) s3 += s2[s2sta];</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="消灭老鼠"><a href="#消灭老鼠" class="headerlink" title="消灭老鼠"></a>消灭老鼠</h1><p><a href="https://www.acwing.com/problem/content/4312/">消灭老鼠</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">double</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> n, x0, y0;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x0 &gt;&gt; y0;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="type">double</span> k;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x - x0 == <span class="number">0</span>) k = <span class="number">124184</span>;</span><br><span class="line">        <span class="keyword">else</span> k = (y - y0) / (x - x0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(k)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        hash.<span class="built_in">insert</span>(k);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h1><p><a href="https://www.acwing.com/problem/content/4314/">最小值</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">    <span class="type">double</span> minv = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, a / b * m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, minv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="出现次数"><a href="#出现次数" class="headerlink" title="出现次数"></a>出现次数</h1><p><a href="https://www.acwing.com/problem/content/4315/">出现次数</a></p>
<p><strong>解法一：前缀和</strong></p>
<p><strong>时间复杂度：<em>O(n * m)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> S[<span class="number">1010</span>]; <span class="comment">// 前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s; <span class="comment">// 因为n, m, l, r 都从1开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// S[i]就代表在 i 之前的，并且长度为 m 的子串中，有多少个和 t 相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 求前缀和</span></span><br><span class="line">        S[i] = S[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i - m + <span class="number">1</span>, m) == t) S[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="type">int</span> r0 = l + m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r0 &gt; r) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; S[r] - S[r0 - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：暴搜</strong></p>
<p><strong>最大时间复杂度：<em>O(n * m * q)</em></strong></p>
<p>单独每个数据都能过，但是一起就TLE了</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    string s, t;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ii;</span><br><span class="line">        <span class="type">int</span> jj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l - <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= r - <span class="number">1</span>; i++, j = <span class="number">0</span>) &#123;</span><br><span class="line">            ii = i, jj = j;</span><br><span class="line">            <span class="keyword">if</span> (r - i &lt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i + m - <span class="number">1</span>] != t[m - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (ii &lt; r &amp;&amp; jj &lt; m &amp;&amp; s[ii] == t[jj]) &#123;</span><br><span class="line">                    res++; <span class="comment">// 代表res个相同</span></span><br><span class="line">                    <span class="keyword">if</span> (res == m) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        res = <span class="number">0</span>;<span class="comment">// 代表res个相同</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ii++, jj++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数圈圈"><a href="#数圈圈" class="headerlink" title="数圈圈"></a>数圈圈</h1><p><a href="https://www.acwing.com/problem/content/4379/">数圈圈</a></p>
<p><strong>时间复杂度：<em>O(logn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> c[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> j[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">           <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        num += j[n % <span class="number">16</span>];</span><br><span class="line">        n /= <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="农田灌溉"><a href="#农田灌溉" class="headerlink" title="农田灌溉"></a>农田灌溉</h1><p><a href="https://www.acwing.com/problem/content/4380/">农田灌溉</a></p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> c[<span class="number">220</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            cin &gt;&gt; i;</span><br><span class="line">            c[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= n; a++)</span><br><span class="line">            <span class="keyword">if</span> (c[a] == <span class="number">1</span>) &#123;</span><br><span class="line">                maxlen = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = n; a &gt;= <span class="number">1</span>; a--)</span><br><span class="line">            <span class="keyword">if</span> (c[a] == <span class="number">1</span>) &#123;</span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, n - a + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((j - i) % <span class="number">2</span> == <span class="number">0</span>) len2 = (j - i) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> len2 = (j - i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                        len = <span class="built_in">max</span>(len, len2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, len);</span><br><span class="line">        cout &lt;&lt; maxlen &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode &amp; Acwing 周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现高性能缓存</title>
    <url>/2022/04/07/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="非线程安全的缓存"><a href="#非线程安全的缓存" class="headerlink" title="非线程安全的缓存"></a>非线程安全的缓存</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中找不到，那么需要现在来计算一下结果，并保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟实际的业务中的计算逻辑，采用sleep代替</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cache1</span> <span class="variable">cache1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始计算了&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="用synchronized保证并发安全"><a href="#用synchronized保证并发安全" class="headerlink" title="用synchronized保证并发安全"></a>用synchronized保证并发安全</h1><ul>
<li>性能差（用synchronized之后，线程变成串行的了，多个线程不能同时访问computer方法了，与缓存的使用性不符合）</li>
<li>代码复用性差</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用synchronized保证并发安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中找不到，那么需要现在来计算一下结果，并保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟实际的业务中的计算逻辑，采用sleep代替</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cache1</span> <span class="variable">cache1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始计算了&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给HashMap加final关键字"><a href="#给HashMap加final关键字" class="headerlink" title="给HashMap加final关键字"></a>给HashMap加final关键字</h2><ul>
<li>属性被声明为final后，该变量则只能被赋值一次。且一旦被赋值，final的变量就不能再被改变。</li>
<li>所以我们把它加上final关键字，增强安全性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用synchronized保证并发安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中找不到，那么需要现在来计算一下结果，并保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟实际的业务中的计算逻辑，采用sleep代替</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cache1</span> <span class="variable">cache1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始计算了&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用装饰者模式将缓存与计算逻辑解耦"><a href="#用装饰者模式将缓存与计算逻辑解耦" class="headerlink" title="用装饰者模式将缓存与计算逻辑解耦"></a>用装饰者模式将缓存与计算逻辑解耦</h1><ul>
<li><p>有一个计算函数compute，用来代表耗时计算，每个计算器都要实现这个接口，这样就可以无侵入实现缓存功能</p>
</li>
<li><p>我们假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情</p>
</li>
<li><p>缺点：</p>
<ul>
<li>性能差，不能并行计算（还是synchronized的问题）</li>
<li>Cache3 当多个线程同时想计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差</li>
</ul>
</li>
</ul>
<h2 id="Computable接口"><a href="#Computable接口" class="headerlink" title="Computable接口"></a>Computable接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache.computable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个计算函数compute，用来代表耗时计算，每个计算器都要实现这个接口，这样就可以无侵入实现缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computable</span> &lt;A, V&gt;&#123;</span><br><span class="line">    V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算逻辑ExpensiveFunction"><a href="#计算逻辑ExpensiveFunction" class="headerlink" title="计算逻辑ExpensiveFunction"></a>计算逻辑ExpensiveFunction</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache.computable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存Cache2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用装饰者模式，给计算器自动添加缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache2</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache2</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache2&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache2</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = expensiveCompute.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程并发查询"><a href="#多线程并发查询" class="headerlink" title="多线程并发查询"></a>多线程并发查询</h2><p><strong>缓存Cache3多线程并发查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用装饰者模式，给计算器自动添加缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache3</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache3</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache3&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache3</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：其实第二个线程根本没必要等待第三个线程执行完毕</span><br><span class="line">进入缓存机制</span><br><span class="line">进入缓存机制</span><br><span class="line">第一个线程：<span class="number">667</span></span><br><span class="line">进入缓存机制</span><br><span class="line">第三个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<h1 id="锁性能优化"><a href="#锁性能优化" class="headerlink" title="锁性能优化"></a>锁性能优化</h1><h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p><strong>Cache4减小锁的粒度，试图提高性能</strong></p>
<ul>
<li>缺点：虽然提高了并发效率，但是并不意味着就是线程安全的，还需要考虑到同时读写等情况<ul>
<li>线程仍然不够安全，虽然多个线程不能同时写了，但是如果在写的同时读，同样是线程不安全的</li>
</ul>
</li>
<li>但是，其实没必要自己实现线程安全的HashMap，也不应该加synchronized，因为我们自己实现的性能远不如现有的并发集合</li>
<li>我们来使用ConcurrentHashMap优化我们的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩小synchronized的粒度，提高性能，但是依然并发不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache4</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache4</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            <span class="comment">// 缩小synchronized保护的范围</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                cache.put(arg, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache4&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache4</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发集合ConcurrentHashMap"><a href="#并发集合ConcurrentHashMap" class="headerlink" title="并发集合ConcurrentHashMap"></a>并发集合ConcurrentHashMap</h2><p><strong>Cache5采用并发集合ConcurrentHashMap保证并发安全</strong></p>
<ul>
<li>缺点：在计算完成前，另一个要求计算相同值的请求到来，会导致计算两遍，这和缓存想避免多次计算的初衷恰恰相反，是不可接受的</li>
</ul>
<p><strong>示意图：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220407124801817.png" alt="image-20220407124801817"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用ConcurrentHashMap保证并发安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache5</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache5</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache5&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache5</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="演示ConcurrentHashMap的缺点"><a href="#演示ConcurrentHashMap的缺点" class="headerlink" title="演示ConcurrentHashMap的缺点"></a>演示ConcurrentHashMap的缺点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示ConcurrentHashMap的缺点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache6</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache6</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache6&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache6</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p>三个线程同时进入缓存机制，5秒后同时给出了缓存结果，其实第一个线程和第三个线程重复计算了，并没有用到缓存结果，而是自己重新算了一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入缓存机制</span><br><span class="line">进入缓存机制</span><br><span class="line">进入缓存机制</span><br><span class="line">第三个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">667</span></span><br><span class="line">第一个线程：<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h1 id="避免重复计算Future和Callable"><a href="#避免重复计算Future和Callable" class="headerlink" title="避免重复计算Future和Callable"></a>避免重复计算Future和Callable</h1><p><strong>利用Future避免重复计算</strong></p>
<ul>
<li>动机：现在不同的线程进来以后，确实可以同时计算，但是如果两个线程脚前脚后，也就是相差无几的进来请求同一个数据那么我们来看看会出现什么问题：重复计算</li>
<li>这个例子只有2个线程，并不可怕，但是如果是100个线程都请求同样的内容，却都需要重新计算，那么会造成巨大的浪费</li>
<li>后面的线程，如果能知道前面的线程正在计算，并且计算的内容和我自己要计算的内容一样，那么我只要等待你的计算结果写入缓存之后直接使用即可</li>
<li>缺点：如果有两个同时计算666的线程，同时调用cache.get()方法那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Future避免重复计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache7</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache7</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新建一个任务</span></span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">            f = ft;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先将ft放入缓存，然后再进行计算</span></span><br><span class="line">            cache.put(arg, ft);</span><br><span class="line">            System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">            ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get()不是立即返回的，而是在算完了结果以后才会返回；有结果之前get()会堵塞</span></span><br><span class="line">        <span class="comment">// 当ft.run();执行完毕之后， Future&lt;V&gt; f里面就有值了</span></span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache7&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache7</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第一个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<p>缺点：如果有两个同时计算666的线程，同时调用cache.get()方法那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第一个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<h2 id="原子操作putIfAbsent"><a href="#原子操作putIfAbsent" class="headerlink" title="原子操作putIfAbsent"></a>原子操作putIfAbsent</h2><p>利用putIfAbsent优化Future小概率的重复计算</p>
<ul>
<li>利用Future可以避免重复计算，但是如果有两个同时计算666的线程，同时调用cache.get()方法那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</li>
</ul>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220407190524546.png" alt="image-20220407190524546"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache8</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache8</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新建一个任务</span></span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">            f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                f = ft;</span><br><span class="line">                System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                ft.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache8&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache8</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br><span class="line">第一个线程：<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h1 id="ExcecutionException"><a href="#ExcecutionException" class="headerlink" title="ExcecutionException"></a>ExcecutionException</h1><h2 id="MayFail"><a href="#MayFail" class="headerlink" title="MayFail"></a>MayFail</h2><p><strong>耗时计算的实现类，有概率计算失败</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache.computable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时计算的实现类，有概率计算失败</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MayFail</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">random</span> <span class="operator">=</span> Math.random();</span><br><span class="line">        <span class="keyword">if</span> (random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;读取文件出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正确的异常处理逻辑-各司其职"><a href="#正确的异常处理逻辑-各司其职" class="headerlink" title="正确的异常处理逻辑(各司其职)"></a>正确的异常处理逻辑(各司其职)</h2><ul>
<li>这3种异常之所以用不同的catch块捕获，是因为它们的处理逻辑是不同的<ul>
<li>CancellationException和InterruptedException是人为取消的，那么我们应该立即终止任务</li>
<li>但是如果是计算错误，且我们明确知道多试几次就可以得到答案，那么我们的逻辑应该是重试，尝试多次直到正确的结果出现</li>
<li>在这里，我们加上while（true）来保证计算出错不会影响我们的逻辑，然后如果是计算错误，就进入下一个循环，重新计算，直到计算成功；如果是人为取消，那么就抛出异常然后结束运行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache9</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache9</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache9&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache9</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：一直循环(为什么？因为缓存被污染了)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="缓存污染问题"><a href="#缓存污染问题" class="headerlink" title="缓存污染问题"></a>缓存污染问题</h1><p><strong>使用cache.remove(arg);清楚被污染的缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache9</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache9</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 每个异常抛出以后，缓存都被清理掉了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache9&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache9</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第一个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<h1 id="缓存过期功能"><a href="#缓存过期功能" class="headerlink" title="缓存过期功能"></a>缓存过期功能</h1><ul>
<li><p>为每个结果指定过期时间，并定期扫描过期的元素</p>
</li>
<li><p>出于安全性考虑，缓存需要设置有效期，到期自动失效否则如果缓存一直不失效，那么会带来缓存不一致等问题</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出于安全性考虑，缓存需要设置有效期，到期自动失效否则如果缓存一直不失效，那么会带来缓存不一致等问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache10</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache10</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 每个异常抛出以后，缓存都被清理掉了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg, <span class="type">long</span> expire)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            executor.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    expire(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compute(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">(A key)</span> &#123;</span><br><span class="line">        Future&lt;V&gt; future = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果任务时间到了，还没有完成的话，直接取消任务</span></span><br><span class="line">            <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Future任务被取消&quot;</span>);</span><br><span class="line">                future.cancel(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;过期时间到，缓存被清除&quot;</span>);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache10&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache10</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>, <span class="number">5000L</span>);<span class="comment">// 5秒后过期</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第四次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第一次计算结果：<span class="number">666</span></span><br><span class="line">第二次计算结果：<span class="number">666</span></span><br><span class="line">第三次计算结果：<span class="number">667</span></span><br><span class="line">过期时间到，缓存被清除</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第四次计算结果：<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h1 id="高并发访问时"><a href="#高并发访问时" class="headerlink" title="高并发访问时"></a>高并发访问时</h1><ul>
<li><p>如果同时过期，那么同时都拿不到缓存，导致打爆cpu和MySQL，造成缓存雪崩、缓存击穿等高并发下的缓存问题</p>
</li>
<li><p>缓存过期时间设置为随机</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出于安全性考虑，缓存需要设置有效期，到期自动失效否则如果缓存一直不失效，那么会带来缓存不一致等问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache11</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache11</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 每个异常抛出以后，缓存都被清理掉了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存过期时间设置为随机</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">computeRandomExpire</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">randomExpire</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> compute(arg, randomExpire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg, <span class="type">long</span> expire)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            executor.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    expire(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compute(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">(A key)</span> &#123;</span><br><span class="line">        Future&lt;V&gt; future = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果任务时间到了，还没有完成的话，直接取消任务</span></span><br><span class="line">            <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Future任务被取消&quot;</span>);</span><br><span class="line">                future.cancel(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;过期时间到，缓存被清除&quot;</span>);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache11&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache11</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>, <span class="number">5000L</span>);<span class="comment">// 5秒后过期</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第四次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>高性能缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记</title>
    <url>/2022/04/23/python/</url>
    <content><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># -<span class="emphasis">*- coding: cp-1252 -*</span>-</span></span><br></pre></td></tr></table></figure>

<p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p>
<span id="more"></span>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</p>
<h2 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：( Python 解释器的交互模式下)</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> <span class="built_in">keyword</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">keyword</span>.kwlist</span><br><span class="line"><span class="meta">[</span><span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span><span class="meta">]</span></span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 <strong>#</strong> 开头</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span>(<span class="string">&quot;Hello python&quot;</span>) <span class="meta"># 第一个注释</span></span><br></pre></td></tr></table></figure>

<p>多行注释可以用多个 <strong>#</strong> 号，还有 <strong>‘’’</strong> 和 **”””**：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="comment"># 第二个注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第三注释</span></span><br><span class="line"><span class="string">第四注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第五注释</span></span><br><span class="line"><span class="string">第六注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello python&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">if</span></span> <span class="variable"><span class="literal">True</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">&quot;True&quot;</span>)</span></span><br><span class="line"><span class="variable"><span class="keyword">else</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">&quot;False&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>) # 缩进不一致，会导致运行错误</span><br></pre></td></tr></table></figure>

<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句</p>
<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \，例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">total</span> = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li><strong>bool</strong> (布尔), 如 True。</li>
<li><strong>float</strong> (浮点数), 如 1.23、3E-2</li>
<li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li>Python 中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</li>
<li>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</li>
<li>转义符 ****。</li>
<li>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 <strong>\n</strong> 会显示，并不是换行。</li>
<li>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</li>
<li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</li>
<li>Python 中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">s = <span class="string">&quot;句子&quot;</span></span><br><span class="line">paragragh = <span class="string">&quot;&quot;&quot;这是一个段落</span></span><br><span class="line"><span class="string">可以由多行组成</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始后的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])          <span class="comment"># 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)         <span class="comment"># 连接字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nrunoob&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nrunoob&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure>

<p>这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)       <span class="comment"># 输出空行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(<span class="string">r&#x27;\n&#x27;</span>)      <span class="comment"># 输出 \n</span></span></span><br><span class="line">\n</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">123456789</span><br><span class="line">12345678</span><br><span class="line">1</span><br><span class="line">345</span><br><span class="line">3456789</span><br><span class="line">24</span><br><span class="line">123456789123456789</span><br><span class="line"><span class="section">123456789你好</span></span><br><span class="line"><span class="section">------------------------------</span></span><br><span class="line">hello</span><br><span class="line">runoob</span><br><span class="line">hello\nrunoob</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>执行下面的程序在按回车键后就会等待用户输入：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>以上代码中 ，<strong>\n\n</strong> 在结果输出前会输出两个新的空行。一旦用户按下 <strong>enter</strong> 键时，程序将退出。</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python 可以在同一行中使用多条语句，语句之间使用分号 <strong>;</strong> 分割，以下是一个简单的实例：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.<span class="keyword">write</span>(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用脚本执行以上代码，输出结果为：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">runoob</span></span><br></pre></td></tr></table></figure>

<p>使用交互式命令行执行，输出结果为：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line">runoob</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>此处的 7 表示字符数，<strong>runoob</strong> 有 6 个字符，<strong>\n</strong> 表示一个字符，加起来 <strong>7</strong> 个字符。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">import</span> sys</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sys.stdout.write(<span class="string">&quot; hi &quot;</span>)    <span class="comment"># hi 前后各有 1 个空格</span></span></span><br><span class="line"> hi 4</span><br></pre></td></tr></table></figure>

<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> <span class="number">5</span> + <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">    <span class="attribute">print</span>(&#x27;<span class="number">5</span> + <span class="number">3</span> == <span class="number">2</span>&#x27;)</span><br><span class="line"><span class="attribute">elif</span> <span class="number">5</span> + <span class="number">3</span> == <span class="number">8</span>:</span><br><span class="line">    <span class="attribute">print</span>(&#x27;<span class="number">5</span> + <span class="number">3</span> == <span class="number">8</span>&#x27;)</span><br><span class="line"><span class="attribute">else</span>:</span><br><span class="line">    <span class="attribute">print</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end&#x3D;””**：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">x</span>=<span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="attribute">y</span>=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, <span class="attribute">end</span>=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, <span class="attribute">end</span>=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="section">b</span></span><br><span class="line"><span class="section">---------</span></span><br><span class="line">a b</span><br></pre></td></tr></table></figure>

<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>在 python 用 <strong>import</strong> 或者 <strong>from…import</strong> 来导入相应的模块。</p>
<p>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></p>
<p>从某个模块中导入某个函数,格式为： <strong>from somemodule import somefunction</strong></p>
<p>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p>
<p>将某个模块中的全部函数导入，格式为： <strong>from somemodule import *</strong></p>
<p><strong>导入sys模块</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br></pre></td></tr></table></figure>

<p><strong>导入sys模块的argv,path成员</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================python from import================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> -h</span><br><span class="line">usage: <span class="keyword">python</span> [option] ... [-<span class="keyword">c</span> cmd | -<span class="keyword">m</span> <span class="keyword">mod</span> | <span class="keyword">file</span> | -] [arg] ...</span><br><span class="line">Options <span class="built_in">and</span> arguments (<span class="built_in">and</span> corresponding environment variables):</span><br><span class="line">-<span class="keyword">c</span> cmd : program passed in <span class="keyword">as</span> <span class="built_in">string</span> (terminates option <span class="keyword">list</span>)</span><br><span class="line">-d     : <span class="keyword">debug</span> output from parser (also PYTHONDEBUG=<span class="keyword">x</span>)</span><br><span class="line">-E     : ignore environment variables (such <span class="keyword">as</span> PYTHONPATH)</span><br><span class="line">-h     : <span class="keyword">print</span> this <span class="keyword">help</span> message <span class="built_in">and</span> <span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">[ etc. ]</span><br></pre></td></tr></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（&#x3D;）用来给变量赋值。</p>
<p>等号（&#x3D;）运算符左边是一个变量名,等号（&#x3D;）运算符右边是存储在变量中的值。例如：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="meta"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="meta"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;runoob&quot;</span>     <span class="meta"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (counter)</span><br><span class="line"><span class="keyword">print</span> (miles)</span><br><span class="line"><span class="keyword">print</span> (name)</span><br></pre></td></tr></table></figure>

<h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>Python允许你同时为多个变量赋值。例如：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span> <span class="operator">=</span> b <span class="operator">=</span> c <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p>
<p>您也可以为多个对象指定多个变量。例如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span>, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob” 分配给变量 c。</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li>
<li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>此外还可以用 isinstance 来判断：(交互模式)</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = <span class="number">111</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>isinstance 和 type 的区别在于：</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">class</span> <span class="title class_">A</span>:</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="keyword">pass</span></span></span><br><span class="line"><span class="meta prompt_">...</span> </span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="keyword">pass</span></span></span><br><span class="line"><span class="meta prompt_">...</span> </span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">isinstance</span>(A(), A)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">type</span>(A()) == A </span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">isinstance</span>(B(), A)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">type</span>(B()) == A</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， <strong>True&#x3D;&#x3D;1、False&#x3D;&#x3D;0</strong> 会返回 <strong>True</strong>，但可以通过 <strong>is</strong> 来判断类型。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>) </span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="literal">True</span>==<span class="number">1</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="literal">False</span>==<span class="number">0</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="literal">True</span>+<span class="number">1</span></span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="literal">False</span>+<span class="number">1</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p><em>在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。</em></p>
<p>当你指定一个值时，Number 对象就会被创建：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">var2</span> <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">del var1<span class="comment">[,var2<span class="comment">[,var3<span class="comment">[....,varN]</span>]</span>]</span></span><br></pre></td></tr></table></figure>

<p>可以通过使用del语句删除单个或多个对象。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">del</span> <span class="selector-tag">var</span></span><br><span class="line"><span class="selector-tag">del</span> var_a, var_b</span><br></pre></td></tr></table></figure>

<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span></span><br><span class="line">9</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span></span><br><span class="line">2.3</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span></span><br><span class="line">21</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span></span><br><span class="line">0.5</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span></span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>1、Python可以同时为多个变量赋值，如a, b &#x3D; 1, 2。</li>
<li>2、一个变量可以通过赋值指向不同类型的对象。</li>
<li>3、数值的除法包含两个运算符：**&#x2F;** 返回一个浮点数，**&#x2F;&#x2F;** 返回一个整数。</li>
<li>4、在混合计算时，Python会把整型转换成为浮点数。</li>
</ul>
<h3 id="数值类型实例"><a href="#数值类型实例" class="headerlink" title="数值类型实例"></a>数值类型实例</h3><table>
<thead>
<tr>
<th align="left">int</th>
<th align="left">float</th>
<th align="left">complex</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10</td>
<td align="left">0.0</td>
<td align="left">3.14j</td>
</tr>
<tr>
<td align="left">100</td>
<td align="left">15.20</td>
<td align="left">45.j</td>
</tr>
<tr>
<td align="left">-786</td>
<td align="left">-21.9</td>
<td align="left">9.322e-36j</td>
</tr>
<tr>
<td align="left">080</td>
<td align="left">32.3e+18</td>
<td align="left">.876j</td>
</tr>
<tr>
<td align="left">-0490</td>
<td align="left">-90.</td>
<td align="left">-.6545+0J</td>
</tr>
<tr>
<td align="left">-0x260</td>
<td align="left">-32.54e100</td>
<td align="left">3e+26J</td>
</tr>
<tr>
<td align="left">0x69</td>
<td align="left">70.2E-12</td>
<td align="left">4.53e-7j</td>
</tr>
</tbody></table>
<p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来，同时使用反斜杠 **** 转义特殊字符。</p>
<p>字符串的截取的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">变量<span class="selector-attr">[头下标:尾下标]</span></span><br></pre></td></tr></table></figure>

<p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220421170110404.png" alt="image-20220421170110404"></p>
<p>加号 <strong>+</strong> 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。实例如下：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span>)          <span class="meta"># 输出字符串</span></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">-1</span>])    <span class="meta"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span>[<span class="number">0</span>])       <span class="meta"># 输出字符串第一个字符</span></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])     <span class="meta"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:])      <span class="meta"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span> * <span class="number">2</span>)      <span class="meta"># 输出字符串两次，也可以写成 print (2 * str)</span></span><br><span class="line"><span class="keyword">print</span> (<span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>) <span class="meta"># 连接字符串</span></span><br></pre></td></tr></table></figure>

<p>执行以上程序会输出如下结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Runoob</span></span><br><span class="line"><span class="attribute">Runoo</span></span><br><span class="line"><span class="attribute">R</span></span><br><span class="line"><span class="attribute">noo</span></span><br><span class="line"><span class="attribute">noob</span></span><br><span class="line"><span class="attribute">RunoobRunoob</span></span><br><span class="line"><span class="attribute">RunoobTEST</span></span><br></pre></td></tr></table></figure>

<p>Python 使用反斜杠 *<em>*</em> 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 <strong>r</strong>，表示原始字符串：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(<span class="string">&#x27;Ru\noob&#x27;</span>)</span></span><br><span class="line">Ru</span><br><span class="line">oob</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(<span class="string">r&#x27;Ru\noob&#x27;</span>)</span></span><br><span class="line">Ru\noob</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;123\</span></span><br><span class="line"><span class="string">123&quot;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="meta"># 输出123123</span></span><br></pre></td></tr></table></figure>

<p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(word[<span class="number">0</span>], word[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span></span></span><br><span class="line">输出：</span><br><span class="line">P n</span><br><span class="line">n P</span><br></pre></td></tr></table></figure>

<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">变量<span class="selector-attr">[头下标:尾下标]</span></span><br></pre></td></tr></table></figure>

<p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">list = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (list)            <span class="meta"># 输出完整列表</span></span><br><span class="line"><span class="keyword">print</span> (list[<span class="number">0</span>])         <span class="meta"># 输出列表第一个元素</span></span><br><span class="line"><span class="keyword">print</span> (list[<span class="number">1</span>:<span class="number">3</span>])       <span class="meta"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="keyword">print</span> (list[<span class="number">2</span>:])        <span class="meta"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="keyword">print</span> (tinylist * <span class="number">2</span>)    <span class="meta"># 输出两次列表</span></span><br><span class="line"><span class="keyword">print</span> (list + tinylist) <span class="meta"># 连接列表</span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[<span class="string">&#x27;abcd&#x27;</span>, 786, 2.23, <span class="string">&#x27;runoob&#x27;</span>, 70.2]</span></span><br><span class="line">abcd</span><br><span class="line"><span class="selector-attr">[786, 2.23]</span></span><br><span class="line"><span class="selector-attr">[2.23, <span class="string">&#x27;runoob&#x27;</span>, 70.2]</span></span><br><span class="line"><span class="selector-attr">[123, <span class="string">&#x27;runoob&#x27;</span>, 123, <span class="string">&#x27;runoob&#x27;</span>]</span></span><br><span class="line"><span class="selector-attr">[<span class="string">&#x27;abcd&#x27;</span>, 786, 2.23, <span class="string">&#x27;runoob&#x27;</span>, 70.2, 123, <span class="string">&#x27;runoob&#x27;</span>]</span></span><br></pre></td></tr></table></figure>

<p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a[<span class="number">0</span>] = <span class="number">9</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[9, 2, 13, 14, 15, 6]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a[<span class="number">2</span>:<span class="number">5</span>] = []   <span class="comment"># 将对应的元素值设置为 []</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[9, 2, 6]</span><br></pre></td></tr></table></figure>

<p>List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、List写在方括号之间，元素用逗号隔开。</li>
<li>2、和字符串一样，list可以被索引和切片。</li>
<li>3、List可以使用+操作符进行拼接。</li>
<li>4、List中的元素是可以改变的。</li>
</ul>
<p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220421172500091.png" alt="image-20220421172500091"></p>
<p>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">runoob <span class="keyword">like</span> I</span><br></pre></td></tr></table></figure>

<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(&#x27;abcd&#x27;, <span class="number">786</span>, <span class="number">2.23</span>, &#x27;runoob&#x27;, <span class="number">70.2</span>)</span><br><span class="line">abcd</span><br><span class="line">(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line">(<span class="number">2.23</span>, &#x27;runoob&#x27;, <span class="number">70.2</span>)</span><br><span class="line">(<span class="number">123</span>, &#x27;runoob&#x27;, <span class="number">123</span>, &#x27;runoob&#x27;)</span><br><span class="line">(&#x27;abcd&#x27;, <span class="number">786</span>, <span class="number">2.23</span>, &#x27;runoob&#x27;, <span class="number">70.2</span>, <span class="number">123</span>, &#x27;runoob&#x27;)</span><br></pre></td></tr></table></figure>

<p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p>
<p>其实，可以把字符串看作一种特殊的元组。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(tup[<span class="number">0</span>])</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(tup[<span class="number">1</span>:<span class="number">5</span>])</span></span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup[<span class="number">0</span>] = <span class="number">11</span>  <span class="comment"># 修改元组元素的操作是非法的</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>

<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tup1</span> = ()    <span class="comment"># 空元组</span></span><br><span class="line"><span class="attr">tup2</span> = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure>

<p>string、list 和 tuple 都属于 sequence（序列）。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、与字符串一样，元组的元素不能修改。</li>
<li>2、元组也可以被索引和切片，方法一样。</li>
<li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li>
<li>4、元组也可以使用+操作符进行拼接。</li>
</ul>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">parame = &#123;value01,value02,<span class="built_in">..</span>.&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   # 输出集合，重复的元素被自动去掉</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Runoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a - b)     # a 和 b 的差集</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b)     # a 和 b 的并集</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     # a 和 b 的交集</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     # a 和 b 中不同时存在的元素</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;Zhihu&#x27;, &#x27;Baidu&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;&#125;</span><br><span class="line">Runoob 在集合中</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span><br><span class="line">&#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 菜鸟教程&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;2 - 菜鸟工具&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - 菜鸟教程</span><br><span class="line"><span class="number">2</span> - 菜鸟工具</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="function"><span class="title">dict_keys</span><span class="params">([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;site&#x27;</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">dict_values</span><span class="params">([<span class="string">&#x27;runoob&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。</p>
<p>Python 数据类型转换可以分为两种：</p>
<ul>
<li>隐式类型转换 - 自动完成</li>
<li>显式类型转换 - 需要使用类型函数来转换</li>
</ul>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。</p>
<p>以下实例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">num_int = <span class="number">123</span></span><br><span class="line">num_flo = <span class="number">1.23</span></span><br><span class="line"></span><br><span class="line">num_new = num_int + num_flo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;datatype of num_int:&quot;</span>,type(num_int)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;datatype of num_flo:&quot;</span>,type(num_flo)</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;Value of num_new:&quot;</span>,num_new)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;datatype of num_new:&quot;</span>,type(num_new)</span></span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">num_int 数据类型为: &lt;<span class="keyword">class</span> <span class="comment">&#x27;int&#x27;&gt;</span></span><br><span class="line">num_flo 数据类型为: &lt;<span class="keyword">class</span> <span class="comment">&#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="symbol">num_new:</span> 值为: <span class="number">124.23</span></span><br><span class="line">num_new 数据类型为: &lt;<span class="keyword">class</span> <span class="comment">&#x27;float&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ul>
<li>实例中我们对两个不同数据类型的变量 <code>num_int</code> 和 <code>num_flo</code> 进行相加运算，并存储在变量 <code>num_new</code> 中。</li>
<li>然后查看三个变量的数据类型。</li>
<li>在输出结果中，我们看到 <code>num_int</code> 是 <code>整型（integer）</code> ， <code>num_flo</code> 是 <code>浮点型（float）</code>。</li>
<li>同样，新的变量 <code>num_new</code> 是 <code>浮点型（float）</code>，这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。</li>
</ul>
<p>我们再看一个实例，整型数据与字符串类型的数据进行相加：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">num_int = <span class="number">123</span></span><br><span class="line">num_str = <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;Data type of num_int:&quot;</span>,type(num_int)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;Data type of num_str:&quot;</span>,type(num_str)</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(num_int+num_str)</span></span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">num_int 数据类型为: &lt;class <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">num_str 数据类型为: &lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;/runoob-test/test.py&quot;</span>, <span class="built_in">line</span> <span class="number">7</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span>(num_int+num_str)</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="built_in">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。</p>
<p>但是，Python 为这些类型的情况提供了一种解决方案，称为显式转换。</p>
<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。</p>
<p><strong>int()</strong> 强制转换为整型：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span> = int(<span class="number">1</span>)   <span class="comment"># x 输出结果为 1</span></span><br><span class="line"><span class="attr">y</span> = int(<span class="number">2.8</span>) <span class="comment"># y 输出结果为 2</span></span><br><span class="line"><span class="attr">z</span> = int(<span class="string">&quot;3&quot;</span>) <span class="comment"># z 输出结果为 3</span></span><br></pre></td></tr></table></figure>

<p><strong>float()</strong> 强制转换为浮点型：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span> = float(<span class="number">1</span>)     <span class="comment"># x 输出结果为 1.0</span></span><br><span class="line"><span class="attr">y</span> = float(<span class="number">2.8</span>)   <span class="comment"># y 输出结果为 2.8</span></span><br><span class="line"><span class="attr">z</span> = float(<span class="string">&quot;3&quot;</span>)   <span class="comment"># z 输出结果为 3.0</span></span><br><span class="line"><span class="attr">w</span> = float(<span class="string">&quot;4.2&quot;</span>) <span class="comment"># w 输出结果为 4.2</span></span><br></pre></td></tr></table></figure>

<p><strong>str()</strong> 强制转换为字符串类型：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span> = str(<span class="string">&quot;s1&quot;</span>) <span class="comment"># x 输出结果为 &#x27;s1&#x27;</span></span><br><span class="line"><span class="attr">y</span> = str(<span class="number">2</span>)    <span class="comment"># y 输出结果为 &#x27;2&#x27;</span></span><br><span class="line"><span class="attr">z</span> = str(<span class="number">3.0</span>)  <span class="comment"># z 输出结果为 &#x27;3.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>整型和字符串类型进行运算，就可以用强制类型转换来完成：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">num_int</span> = <span class="number">123</span></span><br><span class="line"><span class="title">num_str</span> = <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">print</span>(<span class="string">&quot;num_int 数据类型为:&quot;</span>,<span class="keyword">type</span>(num_int))</span><br><span class="line"><span class="title">print</span>(<span class="string">&quot;类型转换前，num_str 数据类型为:&quot;</span>,<span class="keyword">type</span>(num_str))</span><br><span class="line"></span><br><span class="line"><span class="title">num_str</span> = int(num_str)    # 强制转换为整型</span><br><span class="line"><span class="title">print</span>(<span class="string">&quot;类型转换后，num_str 数据类型为:&quot;</span>,<span class="keyword">type</span>(num_str))</span><br><span class="line"></span><br><span class="line"><span class="title">num_sum</span> = num_int + num_str</span><br><span class="line"></span><br><span class="line"><span class="title">print</span>(<span class="string">&quot;num_int 与 num_str 相加结果为:&quot;</span>,num_sum)</span><br><span class="line"><span class="title">print</span>(<span class="string">&quot;sum 数据类型为:&quot;</span>,<span class="keyword">type</span>(num_sum))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">num_int 数据类型为: &lt;<span class="keyword">class</span> &#x27;<span class="symbol">int</span>&#x27;&gt;</span><br><span class="line">类型转换前，<span class="symbol">num_str</span> 数据类型为: &lt;<span class="symbol">class</span> &#x27;<span class="symbol">str</span>&#x27;&gt;</span><br><span class="line">类型转换后，<span class="symbol">num_str</span> 数据类型为: &lt;<span class="symbol">class</span> &#x27;<span class="symbol">int</span>&#x27;&gt;</span><br><span class="line"><span class="symbol">num_int</span> 与 <span class="symbol">num_str</span> 相加结果为: <span class="symbol">579</span></span><br><span class="line"><span class="symbol">sum</span> 数据类型为: &lt;<span class="symbol">class</span> &#x27;<span class="symbol">int</span>&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td>
<td align="left">将x转换为一个整数</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td>
<td align="left">将x转换到一个浮点数</td>
</tr>
<tr>
<td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td>
<td align="left">创建一个复数</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td>
<td align="left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td>
<td align="left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td>
<td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td>
<td align="left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td>
<td align="left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td>
<td align="left">转换为可变集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td>
<td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td>
<td align="left">转换为不可变集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td>
<td align="left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td>
<td align="left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td>
<td align="left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td>
<td align="left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
<li>元组(tuple)推导式</li>
</ul>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式格式为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[表达式 for 变量 in 列表]</span> </span><br><span class="line"><span class="string">[out_exp_res for out_exp in input_list]</span></span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[表达式 for 变量 in 列表 if 条件]</span></span><br><span class="line"><span class="string">[out_exp_res for out_exp in input_list if condition]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li>
<li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li>
<li>if condition：条件语句，可以过滤列表中不符合条件的值。</li>
</ul>
<p>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">&#x27;ALICE&#x27;</span>, <span class="string">&#x27;JERRY&#x27;</span>, <span class="string">&#x27;WENDY&#x27;</span>, <span class="string">&#x27;SMITH&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>计算 30 以内可以被 3 整除的整数：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(multiples)</span></span><br><span class="line">[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span><br></pre></td></tr></table></figure>

<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>字典推导基本格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr for value in collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr for value in collection if condition &#125;</span><br></pre></td></tr></table></figure>

<p>使用字符串及其长度创建字典：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="meta"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">new</span><span class="type">dict</span> = &#123;key:<span class="type">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">new</span><span class="type">dict</span></span><br><span class="line">&#123;<span class="string">&#x27;Google&#x27;</span>: <span class="type">6</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="type">6</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="type">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">dic = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">dic</span></span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">type</span>(dic)</span></span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>集合推导式基本格式：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123; expression for item in Sequence &#125;</span></span><br><span class="line">或</span><br><span class="line"><span class="comment">&#123; expression for item in Sequence if conditional &#125;</span></span><br></pre></td></tr></table></figure>

<p>计算数字 1,2,3 的平方数：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">setnew = &#123;i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">setnew</span></span><br><span class="line">&#123;1, 4, 9&#125;</span><br></pre></td></tr></table></figure>

<p>判断不是 abc 的字母并输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h2><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>
<p>元组推导式基本格式：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(expression for item in Sequence )</span></span><br><span class="line">或</span><br><span class="line"><span class="comment">(expression for item in Sequence if conditional )</span></span><br></pre></td></tr></table></figure>

<p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <strong>()</strong> 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**，另外元组推导式返回的结果是一个生成器对象。</p>
<p>例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  # 返回的是生成器对象</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span></span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h2><p>以下假设变量 <strong>a&#x3D;10</strong>，变量 <strong>b&#x3D;21</strong>：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加 - 两个对象相加</td>
<td align="left">a + b 输出结果 31</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减 - 得到负数或是一个数减去另一个数</td>
<td align="left">a - b 输出结果 -11</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td align="left">a * b 输出结果 210</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除 - x 除以 y</td>
<td align="left">b &#x2F; a 输出结果 2.1</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模 - 返回除法的余数</td>
<td align="left">b % a 输出结果 1</td>
</tr>
<tr>
<td align="left">**</td>
<td align="left">幂 - 返回x的y次幂</td>
<td align="left">a**b 为10的21次方</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;</td>
<td align="left">取整除 - 向下取接近商的整数</td>
<td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td>
</tr>
</tbody></table>
<h2 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">等于 - 比较对象是否相等</td>
<td align="left">(a &#x3D;&#x3D; b) 返回 False。</td>
</tr>
<tr>
<td align="left">!&#x3D;</td>
<td align="left">不等于 - 比较两个对象是否不相等</td>
<td align="left">(a !&#x3D; b) 返回 True。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于 - 返回x是否大于y</td>
<td align="left">(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td align="left">(a &lt; b) 返回 True。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于 - 返回x是否大于等于y。</td>
<td align="left">(a &gt;&#x3D; b) 返回 False。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于 - 返回x是否小于等于y。</td>
<td align="left">(a &lt;&#x3D; b) 返回 True。</td>
</tr>
</tbody></table>
<h2 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th>&#x3D;</th>
<th>简单的赋值运算符</th>
<th>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</th>
</tr>
</thead>
<tbody><tr>
<td>+&#x3D;</td>
<td>加法赋值运算符</td>
<td>c +&#x3D; a 等效于 c &#x3D; c + a</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减法赋值运算符</td>
<td>c -&#x3D; a 等效于 c &#x3D; c - a</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘法赋值运算符</td>
<td>c *&#x3D; a 等效于 c &#x3D; c * a</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除法赋值运算符</td>
<td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>取模赋值运算符</td>
<td>c %&#x3D; a 等效于 c &#x3D; c % a</td>
</tr>
<tr>
<td>**&#x3D;</td>
<td>幂赋值运算符</td>
<td>c <strong>&#x3D; a 等效于 c &#x3D; c</strong>  a</td>
</tr>
<tr>
<td>&#x2F;&#x2F;&#x3D;</td>
<td>取整除赋值运算符</td>
<td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td>
</tr>
<tr>
<td>:&#x3D;</td>
<td>海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td>
<td>在这个示例中，赋值表达式可以避免调用 len() 两次:<code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td>
</tr>
</tbody></table>
<h2 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h2><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p>
<p>下表中变量 a 为 60，b 为 13二进制格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">a</span> <span class="string">=</span> <span class="number">0011 </span><span class="number">1100</span></span><br><span class="line"></span><br><span class="line"><span class="string">b</span> <span class="string">=</span> <span class="number">0000 </span><span class="number">1101</span></span><br><span class="line"></span><br><span class="line"><span class="string">-----------------</span></span><br><span class="line"></span><br><span class="line"><span class="string">a&amp;b</span> <span class="string">=</span> <span class="number">0000 </span><span class="number">1100</span></span><br><span class="line"></span><br><span class="line"><span class="string">a|b</span> <span class="string">=</span> <span class="number">0011 </span><span class="number">1101</span></span><br><span class="line"></span><br><span class="line"><span class="string">a^b</span> <span class="string">=</span> <span class="number">0011 </span><span class="number">0001</span></span><br><span class="line"></span><br><span class="line"><span class="string">~a</span>  <span class="string">=</span> <span class="number">1100 </span><span class="number">0011</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 <strong>-x-1</strong></td>
<td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody></table>
<h2 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">逻辑表达式</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">x and y</td>
<td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td>
<td align="left">(a and b) 返回 20。</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">x or y</td>
<td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td align="left">(a or b) 返回 10。</td>
</tr>
<tr>
<td align="left">not</td>
<td align="left">not x</td>
<td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td align="left">not(a and b) 返回 False</td>
</tr>
</tbody></table>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 和 b 都为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 和 b 有一个不为 true&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 a 和 b 都不为 true&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = 0</span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 和 b 都为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 和 b 有一个不为 true&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - 变量 a 和 b 都不为 true&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>( a <span class="keyword">and</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;5 - 变量 a 和 b 都为 true&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>- 变量 a 和 b 都为 true</span><br><span class="line"><span class="symbol">2 </span>- 变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line"><span class="symbol">3 </span>- 变量 a 和 b 有一个不为 true</span><br><span class="line"><span class="symbol">4 </span>- 变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line"><span class="symbol">5 </span>- 变量 a 和 b 都为 false，或其中一个变量为 false</span><br></pre></td></tr></table></figure>

<h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">in</td>
<td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line">list = [1, 2, 3, 4, 5 ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> list ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( b <span class="keyword">not</span> <span class="keyword">in</span> list ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = 2</span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> list ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>- 变量 a 不在给定的列表中 <span class="keyword">list</span> 中</span><br><span class="line"><span class="symbol">2 </span>- 变量 b 不在给定的列表中 <span class="keyword">list</span> 中</span><br><span class="line"><span class="symbol">3 </span>- 变量 a 在给定的列表中 <span class="keyword">list</span> 中</span><br></pre></td></tr></table></figure>

<h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is 是判断两个标识符是不是引用自一个对象</td>
<td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="left"><strong>x is not y</strong> ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<p><strong>注：</strong> <a href="https://www.runoob.com/python/python-func-id.html">id()</a> 函数用于获取对象内存地址。</p>
<p>以下实例演示了Python所有身份运算符的操作：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 20</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a is b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( id(a) == id(b) ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 b 的值</span></span><br><span class="line">b = 30</span><br><span class="line"><span class="keyword">if</span> ( a is b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a is <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - a 和 b 有相同的标识&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>- a 和 b 有相同的标识</span><br><span class="line"><span class="symbol">2 </span>- a 和 b 有相同的标识</span><br><span class="line"><span class="symbol">3 </span>- a 和 b 没有相同的标识</span><br><span class="line"><span class="symbol">4 </span>- a 和 b 没有相同的标识</span><br></pre></td></tr></table></figure>

<p>is 与 &#x3D;&#x3D; 区别：</p>
<p>is 用于判断两个变量引用对象是否为同一个， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="selector-tag">a</span> = <span class="selector-attr">[1, 2, 3]</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> = <span class="selector-tag">a</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> is <span class="selector-tag">a</span> </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> == <span class="selector-tag">a</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> = <span class="selector-tag">a</span><span class="selector-attr">[:]</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> is <span class="selector-tag">a</span></span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">b</span> == <span class="selector-tag">a</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">**</td>
<td align="left">指数 (最高优先级)</td>
</tr>
<tr>
<td align="left">~ + -</td>
<td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td align="left">* &#x2F; % &#x2F;&#x2F;</td>
<td align="left">乘，除，求余数和取整除</td>
</tr>
<tr>
<td align="left">+ -</td>
<td align="left">加法减法</td>
</tr>
<tr>
<td align="left">&gt;&gt; &lt;&lt;</td>
<td align="left">右移，左移运算符</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">位 ‘AND’</td>
</tr>
<tr>
<td align="left">^ |</td>
<td align="left">位运算符</td>
</tr>
<tr>
<td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td>
<td align="left">比较运算符</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">等于运算符</td>
</tr>
<tr>
<td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td>
<td align="left">赋值运算符</td>
</tr>
<tr>
<td align="left">is is not</td>
<td align="left">身份运算符</td>
</tr>
<tr>
<td align="left">in not in</td>
<td align="left">成员运算符</td>
</tr>
<tr>
<td align="left">not and or</td>
<td align="left">逻辑运算符</td>
</tr>
</tbody></table>
<h1 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字(Number)"></a>数字(Number)</h1><p>Python 数字数据类型用于存储数值。</p>
<p>数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。</p>
<p>以下实例在变量赋值时 Number 对象将被创建：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">var2</span> <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以使用del语句删除一些数字对象的引用。</p>
<p>del语句的语法是：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">del var1<span class="comment">[,var2<span class="comment">[,var3<span class="comment">[....,varN]</span>]</span>]</span></span><br></pre></td></tr></table></figure>

<p>可以通过使用del语句删除单个或多个对象的引用，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">del</span> <span class="selector-tag">var</span></span><br><span class="line"><span class="selector-tag">del</span> var_a, var_b</span><br></pre></td></tr></table></figure>

<p>Python 支持三种不同的数值类型：</p>
<ul>
<li><strong>整型(int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。</li>
<li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x 102 &#x3D; 250）</li>
<li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
<li>Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<h2 id="Python-数字类型转换"><a href="#Python-数字类型转换" class="headerlink" title="Python 数字类型转换"></a>Python 数字类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<ul>
<li><strong>int(x)</strong> 将x转换为一个整数。</li>
<li><strong>float(x)</strong> 将x转换到一个浮点数。</li>
<li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li>
<li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li>
</ul>
<p>以下实例将浮点数变量 a 转换为整数：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = <span class="number">1.0</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">int</span>(a)</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td>
<td align="left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td>
<td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td align="left">cmp(x, y)</td>
<td align="left">如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td>
<td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td>
<td align="left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td>
<td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td>
<td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td>
<td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td>
<td align="left">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td>
<td align="left">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td>
<td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td>
<td align="left">x**y 运算后的值。</td>
</tr>
<tr>
<td align="left">[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td>
<td align="left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td>
<td align="left">返回数字x的平方根。</td>
</tr>
</tbody></table>
<h2 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h2><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td>
<td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td align="left">[randrange (<a href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step])</a></td>
<td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-random.html">random()</a></td>
<td align="left">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td align="left">[seed(<a href="https://www.runoob.com/python3/python3-func-number-seed.html">x])</a></td>
<td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst)</a></td>
<td align="left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td>
<td align="left">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody></table>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>Python包括以下三角函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td>
<td align="left">返回x的反余弦弧度值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td>
<td align="left">返回x的反正弦弧度值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td>
<td align="left">返回x的反正切弧度值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td>
<td align="left">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td>
<td align="left">返回x的弧度的余弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td>
<td align="left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td>
<td align="left">返回的x弧度的正弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td>
<td align="left">返回x弧度的正切值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td>
<td align="left">将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td>
<td align="left">将角度转换为弧度</td>
</tr>
</tbody></table>
<h2 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h2><table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pi</td>
<td align="left">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody></table>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="Python-访问字符串中的值"><a href="#Python-访问字符串中的值" class="headerlink" title="Python 访问字符串中的值"></a>Python 访问字符串中的值</h2><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</p>
<p>Python 访问子字符串，可以使用方括号 <strong>[]</strong> 来截取字符串，字符串的截取的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">变量<span class="selector-attr">[头下标:尾下标]</span></span><br></pre></td></tr></table></figure>

<p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220421193304380.png" alt="image-20220421193304380"></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220421193323514.png" alt="image-20220421193323514"></p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在需要在字符中使用特殊字符时，python 用反斜杠 *<em>*</em> 转义字符。如下表：</p>
<table>
<thead>
<tr>
<th align="left">转义字符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(在行尾时)</td>
<td align="left">续行符</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;line1 \ ... line2 \ ... line3&quot;) line1 line2 line3 &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜杠符号</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\\&quot;) \</code></td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left">单引号</td>
<td align="left"><code>&gt;&gt;&gt; print(&#39;\&#39;&#39;) &#39;</code></td>
</tr>
<tr>
<td align="left">“</td>
<td align="left">双引号</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\&quot;&quot;) &quot;</code></td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">响铃</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\a&quot;)</code>执行后电脑有响声。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格(Backspace)</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \b World!&quot;) Hello World!</code></td>
</tr>
<tr>
<td align="left">\000</td>
<td align="left">空</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\000&quot;) &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\n&quot;)  &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">纵向制表符</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \v World!&quot;) Hello        World! &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">横向制表符</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \t World!&quot;) Hello    World! &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成。</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello\rWorld!&quot;) World! &gt;&gt;&gt; print(&#39;google runoob taobao\r123456&#39;) 123456 runoob taobao</code></td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \f World!&quot;) Hello        World! &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\yyy</td>
<td align="left">八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\110\145\154\154\157\40\127\157\162\154\144\41&quot;) Hello World!</code></td>
</tr>
<tr>
<td align="left">\xyy</td>
<td align="left">十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21&quot;) Hello World!</code></td>
</tr>
<tr>
<td align="left">\other</td>
<td align="left">其它的字符以普通格式输出</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">字符串连接</td>
<td align="left">a + b 输出结果： HelloPython</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">重复输出字符串</td>
<td align="left">a*2 输出结果：HelloHello</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通过索引获取字符串中字符</td>
<td align="left">a[1] 输出结果 <strong>e</strong></td>
</tr>
<tr>
<td align="left">[ : ]</td>
<td align="left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td>
<td align="left">a[1:4] 输出结果 <strong>ell</strong></td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td align="left"><strong>‘H’ in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td align="left"><strong>‘M’ not in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">r&#x2F;R</td>
<td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td>
<td align="left"><code>print( r&#39;\n&#39; ) print( R&#39;\n&#39; )</code></td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">格式字符串</td>
<td align="left">请看下一节内容。</td>
</tr>
</tbody></table>
<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p>
<p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<h2 id="实例-Python-3-0"><a href="#实例-Python-3-0" class="headerlink" title="实例(Python 3.0+)"></a>实例(Python 3.0+)</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">我叫 小明 今年 <span class="number">10</span> 岁!</span><br></pre></td></tr></table></figure>

<p>python字符串格式化符号:</p>
<table>
<thead>
<tr>
<th align="left">符  号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%c</td>
<td align="left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">格式化字符串</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="left">格式化整数</td>
</tr>
<tr>
<td align="left">%u</td>
<td align="left">格式化无符号整型</td>
</tr>
<tr>
<td align="left">%o</td>
<td align="left">格式化无符号八进制数</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">格式化无符号十六进制数</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td align="left">%e</td>
<td align="left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%E</td>
<td align="left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%g</td>
<td align="left">%f和%e的简写</td>
</tr>
<tr>
<td align="left">%G</td>
<td align="left">%f 和 %E 的简写</td>
</tr>
<tr>
<td align="left">%p</td>
<td align="left">用十六进制数格式化变量的地址</td>
</tr>
</tbody></table>
<p>格式化操作符辅助指令:</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">用做左对齐</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td align="left"><sp></td>
<td align="left">在正数前面显示空格</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td align="left">(var)</td>
<td align="left">映射变量(字典参数)</td>
</tr>
<tr>
<td align="left">m.n.</td>
<td align="left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody></table>
<p>Python2.6 开始，新增了一种格式化字符串的函数 <a href="https://www.runoob.com/python/att-string-format.html">str.format()</a>，它增强了字符串格式化的功能。</p>
<h2 id="format-格式化函数"><a href="#format-格式化函数" class="headerlink" title="format 格式化函数"></a>format 格式化函数</h2><p>Python2.6 开始，新增了一种格式化字符串的函数 **str.format()**，它增强了字符串格式化的功能。</p>
<p>基本语法是通过 <strong>{}</strong> 和 <strong>:</strong> 来代替以前的 <strong>%</strong> 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>也可以设置参数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.format(<span class="attribute">name</span>=<span class="string">&quot;菜鸟教程&quot;</span>, <span class="attribute">url</span>=<span class="string">&quot;www.runoob.com&quot;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;菜鸟教程&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;www.runoob.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.format(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;</span>.format(my_list))  # <span class="string">&quot;0&quot;</span> 是必须的</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">网站名：菜鸟教程, 地址 www<span class="selector-class">.runoob</span><span class="selector-class">.com</span></span><br><span class="line">网站名：菜鸟教程, 地址 www<span class="selector-class">.runoob</span><span class="selector-class">.com</span></span><br><span class="line">网站名：菜鸟教程, 地址 www<span class="selector-class">.runoob</span>.com</span><br></pre></td></tr></table></figure>

<p>也可以向 <strong>str.format()</strong> 传入对象：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AssignValue</span>(object):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line">print(<span class="string">&#x27;value 为: &#123;0.value&#125;&#x27;</span>.format(my_value))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">value</span> 为: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h3><p>下表展示了 str.format() 格式化数字的多种方法：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>))</span></span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">数字</th>
<th align="left">格式</th>
<th align="left">输出</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3.1415926</td>
<td align="left">{:.2f}</td>
<td align="left">3.14</td>
<td align="left">保留小数点后两位</td>
</tr>
<tr>
<td align="left">3.1415926</td>
<td align="left">{:+.2f}</td>
<td align="left">+3.14</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">-1</td>
<td align="left">{:+.2f}</td>
<td align="left">-1.00</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">2.71828</td>
<td align="left">{:.0f}</td>
<td align="left">3</td>
<td align="left">不带小数</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:0&gt;2d}</td>
<td align="left">05</td>
<td align="left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:x&lt;4d}</td>
<td align="left">5xxx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">{:x&lt;4d}</td>
<td align="left">10xx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">1000000</td>
<td align="left">{:,}</td>
<td align="left">1,000,000</td>
<td align="left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td align="left">0.25</td>
<td align="left">{:.2%}</td>
<td align="left">25.00%</td>
<td align="left">百分比格式</td>
</tr>
<tr>
<td align="left">1000000000</td>
<td align="left">{:.2e}</td>
<td align="left">1.00e+09</td>
<td align="left">指数记法</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&gt;10d}</td>
<td align="left">13</td>
<td align="left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&lt;10d}</td>
<td align="left">13</td>
<td align="left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:^10d}</td>
<td align="left">13</td>
<td align="left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&#39;&#123;:b&#125;&#39;.format(11) &#39;&#123;:d&#125;&#39;.format(11) &#39;&#123;:o&#125;&#39;.format(11) &#39;&#123;:x&#125;&#39;.format(11) &#39;&#123;:#x&#125;&#39;.format(11) &#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td align="left"><code>1011 11 13 b 0xb 0XB</code></td>
<td align="left">进制</td>
</tr>
</tbody></table>
<p><strong>^</strong>, <strong>&lt;**, **&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p>
<p><strong>+</strong> 表示在正数前显示 **+**，负数前显示 **-**； （空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<p>此外我们可以使用大括号 <strong>{}</strong> 来转义大括号，如下实例：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">print (<span class="string">&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;</span>.format(<span class="string">&quot;runoob&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">runoob</span> 对应的位置是 &#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h2><p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">para_str = <span class="string">&quot;&quot;&quot;这是一个多行字符串的实例</span></span><br><span class="line"><span class="string">多行字符串可以使用制表符</span></span><br><span class="line"><span class="string">TAB ( \t )。</span></span><br><span class="line"><span class="string">也可以使用换行符 [ \n ]。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> (para_str)</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line"><span class="literal">TAB</span> (    )。</span><br><span class="line">也可以使用换行符 [ </span><br><span class="line"> ]。</span><br></pre></td></tr></table></figure>

<h2 id="Python-的字符串内建函数"><a href="#Python-的字符串内建函数" class="headerlink" title="Python 的字符串内建函数"></a>Python 的字符串内建函数</h2><p>Python 的字符串常用内建函数如下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg&#x3D; 0,end&#x3D;len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding&#x3D;”utf-8”, errors&#x3D;”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding&#x3D;’UTF-8’,errors&#x3D;’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize&#x3D;8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg&#x3D;0, end&#x3D;len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg&#x3D;0, end&#x3D;len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg&#x3D;0,end&#x3D;len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg&#x3D;0, end&#x3D;len(string))</a> 类似于 index()，不过是从右边开始.</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str&#x3D;””, num&#x3D;string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg&#x3D;0,end&#x3D;len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars&#x3D;””)</a> 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>序列是 Python 中最基本的数据结构。</p>
<p>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。</p>
<p>Python 有 6 个序列的内置类型，但最常见的是列表和元组。</p>
<p>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</p>
<p>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<p>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。</p>
<p>列表的数据项<strong>不需要具有相同的类型</strong></p>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">list1</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="attr">list2</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="attr">list3</span> = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line"><span class="attr">list4</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h2><p>与字符串的索引一样，列表索引从 <strong>0</strong> 开始，第二个索引是 <strong>1</strong>，依此类推。</p>
<p>通过索引列表可以进行截取、组合等操作。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220422165713077.png" alt="image-20220422165713077"></p>
<p>索引也可以从尾部开始，最后一个元素的索引为 <strong>-1</strong>，往前一位为 <strong>-2</strong>，以此类推。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220422165755780.png" alt="image-20220422165755780"></p>
<p>使用下标索引来访问列表中的值，同样你也可以使用方括号 <strong>[]</strong> 的形式截取字符，如下所示：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220422165841004.png" alt="image-20220422165841004"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">nums = <span class="selector-attr">[10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(nums[<span class="number">0</span>:<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[10, 20, 30, 40]</span></span><br></pre></td></tr></table></figure>

<p>使用负数索引值截取：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">list = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&quot;Zhihu&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取第二位</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1]: &quot;</span>, list[1])</span><br><span class="line"><span class="comment"># 从第二位开始（包含）截取到倒数第二位（不包含）</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1:-2]: &quot;</span>, list[1:-2])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">list[<span class="number">1</span>]:  <span class="symbol">Runoob</span></span><br><span class="line">list[<span class="number">1</span>:-<span class="number">2</span>]:  [<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h2><p>你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">list = <span class="selector-attr">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, 1997, 2000]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;第三个元素为 : &quot;</span>, list[<span class="number">2</span>])</span></span></span><br><span class="line">list<span class="selector-attr">[2]</span> = <span class="number">2001</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, list[<span class="number">2</span>])</span></span></span><br><span class="line"></span><br><span class="line">list1 = <span class="selector-attr">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span></span><br><span class="line">list1<span class="selector-class">.append</span>(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;更新后的列表 : &quot;</span>, list1)</span></span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">第三个元素为 :  1997</span><br><span class="line">更新后的第三个元素为 :  2001</span><br><span class="line">更新后的列表 :  [&#x27;<span class="type">Google</span>&#x27;, <span class="symbol">&#x27;Runoob</span>&#x27;, <span class="symbol">&#x27;Taobao</span>&#x27;, <span class="symbol">&#x27;Baidu</span>&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><p>可以使用 del 语句来删除列表的的元素，如下实例：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">list = <span class="selector-attr">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, 1997, 2000]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;原始列表 : &quot;</span>, list)</span></span></span><br><span class="line"><span class="selector-tag">del</span> list<span class="selector-attr">[2]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;删除第三个元素 : &quot;</span>, list)</span></span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">原始列表 :  <span class="selector-attr">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, 1997, 2000]</span></span><br><span class="line">删除第三个元素 :  <span class="selector-attr">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, 2000]</span></span><br></pre></td></tr></table></figure>

<h2 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h2><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p>
<p>如下所示：</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">len([1, 2, 3])</td>
<td align="left">3</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="left">[1, 2, 3] + [4, 5, 6]</td>
<td align="left">[1, 2, 3, 4, 5, 6]</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">[‘Hi!’] * 4</td>
<td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td align="left">重复</td>
</tr>
<tr>
<td align="left">3 in [1, 2, 3]</td>
<td align="left">True</td>
<td align="left">元素是否存在于列表中</td>
</tr>
<tr>
<td align="left">for x in [1, 2, 3]: print(x, end&#x3D;” “)</td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<h2 id="Python列表截取与拼接"><a href="#Python列表截取与拼接" class="headerlink" title="Python列表截取与拼接"></a>Python列表截取与拼接</h2><p>Python的列表截取与字符串操作类型，如下所示：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">L</span>=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>操作：</p>
<p>操作：</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">L[2]</td>
<td align="left">‘Taobao’</td>
<td align="left">读取第三个元素</td>
</tr>
<tr>
<td align="left">L[-2]</td>
<td align="left">‘Runoob’</td>
<td align="left">从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td align="left">L[1:]</td>
<td align="left">[‘Runoob’, ‘Taobao’]</td>
<td align="left">输出从第二个元素开始后的所有元素</td>
</tr>
</tbody></table>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="symbol">L</span>=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="symbol">L</span>[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Taobao&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="symbol">L</span>[<span class="number">-2</span>]</span><br><span class="line"><span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="symbol">L</span>[<span class="number">1</span>:]</span><br><span class="line">[<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>列表还支持拼接操作：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;squares = [1, 4, 9, 16, 25]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">squares += [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">squares</span></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>使用嵌套列表即在列表里创建其它列表，例如：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; x = [a, n]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">&gt;&gt;&gt; x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Python列表函数-amp-方法"><a href="#Python列表函数-amp-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h2><p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td>
</tr>
</tbody></table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td>
</tr>
</tbody></table>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号 **( )**，列表使用方括号 **[ ]**。</p>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup1 = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup3 = <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>   <span class="comment">#  不需要括号也可以</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">type</span>(tup3)</span></span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>创建空元组</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tup1</span> <span class="operator">=</span> ()</span><br></pre></td></tr></table></figure>

<p>元组中只包含一个元素时，需要在元素后面添加逗号 <strong>,</strong> ，否则括号会被当作运算符使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup1)     <span class="comment"># 不加逗号，类型为整型</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup1)     <span class="comment"># 加上逗号，类型为元组</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等。</p>
<h2 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h2><p>元组可以使用下标索引来访问元组中的值，如下实例:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tup1</span> = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="attribute">tup2</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"> </span><br><span class="line"><span class="attribute">print</span> (<span class="string">&quot;tup1[0]: &quot;</span>, tup1[<span class="number">0</span>])</span><br><span class="line"><span class="attribute">print</span> (<span class="string">&quot;tup2[1:5]: &quot;</span>, tup2[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tup1</span>[<span class="number">0</span>]:  Google</span><br><span class="line"><span class="attribute">tup2</span>[<span class="number">1</span>:<span class="number">5</span>]:  (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h2><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">tup1 = (12, 34.56)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span> (tup3)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">12</span>, <span class="number">34.56</span>, <span class="symbol">&#x27;abc</span>&#x27;, <span class="symbol">&#x27;xyz</span>&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h2><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(tup)</span></span></span><br><span class="line"><span class="selector-tag">del</span> tup</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;删除后的元组 tup : &quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(tup)</span></span></span><br></pre></td></tr></table></figure>

<p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;E:/study/pythonstudy/test.py&quot;</span>, <span class="built_in">line</span> <span class="number">6</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span>(tup)</span><br><span class="line">NameError: name <span class="string">&#x27;tup&#x27;</span> <span class="keyword">is</span> not defined</span><br><span class="line">(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">删除后的元组 tup : </span><br></pre></td></tr></table></figure>

<h2 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h2><p>与字符串一样，元组之间可以使用 <strong>+</strong> 号和 ***** 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>len((1, 2, 3))</code></td>
<td align="left">3</td>
<td align="left">计算元素个数</td>
</tr>
<tr>
<td align="left"><code>(1, 2, 3) + (4, 5, 6)</code></td>
<td align="left">(1, 2, 3, 4, 5, 6)</td>
<td align="left">连接</td>
</tr>
<tr>
<td align="left"><code>(&#39;Hi!&#39;,) * 4</code></td>
<td align="left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td>
<td align="left">复制</td>
</tr>
<tr>
<td align="left"><code>3 in (1, 2, 3)</code></td>
<td align="left">True</td>
<td align="left">元素是否存在</td>
</tr>
<tr>
<td align="left"><code>for x in (1, 2, 3):     print (x, end=&quot; &quot;)</code></td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<h2 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h2><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素</p>
<p>元组：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tup</span> = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Wiki&#x27;</span>, <span class="string">&#x27;Weibo&#x27;</span>,<span class="string">&#x27;Weixin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tup[1]</td>
<td align="left">‘Runoob’</td>
<td align="left">读取第二个元素</td>
</tr>
<tr>
<td align="left">tup[-2]</td>
<td align="left">‘Weibo’</td>
<td align="left">反向读取，读取倒数第二个元素</td>
</tr>
<tr>
<td align="left">tup[1:]</td>
<td align="left">(‘Runoob’, ‘Taobao’, ‘Wiki’, ‘Weibo’, ‘Weixin’)</td>
<td align="left">截取元素，从第二个开始后的所有元素。</td>
</tr>
<tr>
<td align="left">tup[1:4]</td>
<td align="left">(‘Runoob’, ‘Taobao’, ‘Wiki’)</td>
<td align="left">截取元素，从第二个开始到第四个元素（索引为 3）。</td>
</tr>
</tbody></table>
<h2 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h2><p>Python元组包含了以下内置函数</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(tuple) 计算元组元素个数。</td>
<td align="left"><code>&gt;&gt;&gt; tuple1 = (&#39;Google&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;) &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">max(tuple) 返回元组中元素最大值。</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; max(tuple2) &#39;8&#39; &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">min(tuple) 返回元组中元素最小值。</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; min(tuple2) &#39;4&#39; &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">tuple(iterable) 将可迭代系列转换为元组。</td>
<td align="left"><code>&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 (&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)</code></td>
</tr>
</tbody></table>
<h2 id="关于元组是不可变的"><a href="#关于元组是不可变的" class="headerlink" title="关于元组是不可变的"></a>关于元组是不可变的</h2><p>所谓元组的不可变指的是元组所指向的内存中的内容不可变。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup = (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup[<span class="number">0</span>] = <span class="string">&#x27;g&#x27;</span>     <span class="comment"># 不支持修改元素</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">id</span>(tup)     <span class="comment"># 查看内存地址</span></span></span><br><span class="line">4440687904</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">id</span>(tup)</span></span><br><span class="line">4441088800    # 内存地址不一样了</span><br></pre></td></tr></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 <strong>key&#x3D;&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : <span class="type">value1</span>, key2 : <span class="type">value2</span>, key3 : <span class="type">value3</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：dict</strong> 作为 Python 的关键字和内置函数，变量名不建议命名为 <strong>dict</strong>。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220422173313061.png" alt="image-20220422173313061"></p>
<p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</p>
<p>一个简单的字典实例：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tinydict</span> = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220422173336201.png" alt="image-20220422173336201"></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">也可如此创建字典：</span><br><span class="line"></span><br><span class="line">ti<span class="symbol">nydict1</span> = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;</span><br><span class="line">ti<span class="symbol">nydict2</span> = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h2><p>使用大括号 <strong>{ }</strong> 创建空字典：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(emptyDict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看字典的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>, len(emptyDict))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">print</span>(type(emptyDict))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">Length: <span class="number">0</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>使用内建函数 <strong>dict()</strong> 创建字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emptyDict = <span class="built_in">dict</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(emptyDict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看字典的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>,<span class="built_in">len</span>(emptyDict))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emptyDict))</span><br></pre></td></tr></table></figure>

<h2 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h2><p>把相应的键放入到方括号中，如下实例:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: 7, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>如果用字典里没有的键访问数据，会输出错误如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: 7, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Alice&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Alice&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, <span class="built_in">line</span> <span class="number">5</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&quot;tinydict[&#x27;Alice&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">KeyError: <span class="string">&#x27;Alice&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h2><p>向字典添加新内容的方法是增加新的键&#x2F;值对，修改或删除已有键&#x2F;值对如下实例:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: <span class="number">7</span>, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">tinydict[&#x27;Age&#x27;] = <span class="number">8</span>               <span class="meta"># 更新 Age</span></span><br><span class="line">tinydict[&#x27;School&#x27;] = <span class="string">&quot;菜鸟教程&quot;</span>  <span class="meta"># 添加信息</span></span><br></pre></td></tr></table></figure>

<h2 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h2><p>能删单一的元素也能清空字典，清空只需一项操作。</p>
<p>显式删除一个字典用del命令，如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>但这会引发一个异常，因为用执行 del 操作后字典不再存在：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;/runoob-test/test.py&quot;</span>, <span class="built_in">line</span> <span class="number">9</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">NameError: name <span class="string">&#x27;tinydict&#x27;</span> <span class="keyword">is</span> not defined</span><br></pre></td></tr></table></figure>

<h3 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h3><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: 7, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">tinydict<span class="selector-attr">[<span class="string">&#x27;Name&#x27;</span>]</span>:  小菜鸟</span><br></pre></td></tr></table></figure>

<p>2）<strong>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</strong>，如下实例：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"> </span><br><span class="line">print (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, <span class="built_in">line</span> <span class="number">3</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(dict) 计算字典元素个数，即键的总数。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">str(dict) 输出字典，可以打印的字符串表示。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td>
</tr>
</tbody></table>
<p>Python字典包含了以下内置方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">[pop(key<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody></table>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 这里演示的是去重功能</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 快速判断元素是否在集合内</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面展示两个集合间的运算.</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>类似列表推导式，同样集合支持集合推导式(Set comprehension):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h2><h3 id="1、添加元素"><a href="#1、添加元素" class="headerlink" title="1、添加元素"></a>1、添加元素</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">s.<span class="keyword">add</span>( <span class="keyword">x</span> )</span><br></pre></td></tr></table></figure>

<p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; thisset.<span class="built_in">add</span>(<span class="string">&quot;Facebook&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">s.update<span class="comment">( x )</span></span><br></pre></td></tr></table></figure>

<p>x 可以有多个，用逗号分开。</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">thisset = <span class="keyword">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"></span><br><span class="line"># &#123;<span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br><span class="line">thisset.<span class="keyword">add</span>(<span class="string">&quot;Facebook&quot;</span>) </span><br><span class="line">pr<span class="meta">int</span>(thisset)</span><br><span class="line"></span><br><span class="line"># &#123;<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, 1, 3, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>&#125;</span><br><span class="line">thisset.up<span class="meta">date</span>(&#123;1,3&#125;)</span><br><span class="line">pr<span class="meta">int</span>(thisset)</span><br><span class="line"></span><br><span class="line"># &#123;1, 3, 4, 5, 6, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>&#125;</span><br><span class="line">thisset.up<span class="meta">date</span>([1,4],[5,6])</span><br><span class="line">pr<span class="meta">int</span>(thisset)</span><br></pre></td></tr></table></figure>

<h3 id="2、移除元素"><a href="#2、移除元素" class="headerlink" title="2、移除元素"></a>2、移除元素</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">remove</span>( x )</span><br></pre></td></tr></table></figure>

<p>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; thisset.<span class="built_in">remove</span>(<span class="string">&quot;Taobao&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; thisset.<span class="built_in">remove</span>(<span class="string">&quot;Facebook&quot;</span>)   # 不存在会发生错误</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;Facebook&#x27;</span></span><br></pre></td></tr></table></figure>

<p>此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.discard( x )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.discard(<span class="string">&quot;Facebook&quot;</span>)  <span class="comment"># 不存在不会发生错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以设置随机删除集合中的一个元素，语法格式如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">s<span class="selector-class">.pop</span>() </span><br><span class="line">thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Facebook&quot;</span>))</span><br><span class="line">x = thisset<span class="selector-class">.pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(x)</span></span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Runoob</span></span><br></pre></td></tr></table></figure>

<p>多次执行测试结果都不一样。</p>
<p>set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。</p>
<h3 id="3、计算集合元素个数"><a href="#3、计算集合元素个数" class="headerlink" title="3、计算集合元素个数"></a>3、计算集合元素个数</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">len</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4、清空集合"><a href="#4、清空集合" class="headerlink" title="4、清空集合"></a>4、清空集合</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure>

<h3 id="5、判断元素是否在集合中存在"><a href="#5、判断元素是否在集合中存在" class="headerlink" title="5、判断元素是否在集合中存在"></a>5、判断元素是否在集合中存在</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">x in s</span></span><br></pre></td></tr></table></figure>

<p>判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。</p>
<h3 id="集合内置方法完整列表"><a href="#集合内置方法完整列表" class="headerlink" title="集合内置方法完整列表"></a>集合内置方法完整列表</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td>
<td align="left">为集合添加元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td>
<td align="left">移除集合中的所有元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td>
<td align="left">拷贝一个集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td>
<td align="left">返回多个集合的差集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td>
<td align="left">移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td>
<td align="left">删除集合中指定的元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td>
<td align="left">返回集合的交集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td>
<td align="left">返回集合的交集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td>
<td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td>
<td align="left">判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td>
<td align="left">判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td>
<td align="left">随机移除元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td>
<td align="left">移除指定元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td>
<td align="left">返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td>
<td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td>
<td align="left">返回两个集合的并集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td>
<td align="left">给集合添加元素</td>
</tr>
</tbody></table>
<h1 id="编程第一步"><a href="#编程第一步" class="headerlink" title="编程第一步"></a>编程第一步</h1><p>在前面的教程中我们已经学习了一些 Python3 的基本语法知识，下面我们尝试来写一个斐波纳契数列。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line">a, <span class="keyword">b </span>= <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">while <span class="keyword">b </span>&lt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="keyword">b)</span></span><br><span class="line"><span class="keyword"></span>    a, <span class="keyword">b </span>= <span class="keyword">b, </span>a+<span class="keyword">b</span></span><br></pre></td></tr></table></figure>

<p>其中代码 <strong>a, b &#x3D; b, a+b</strong> 的计算方式为先计算右边表达式，然后同时赋值给左边，等价于：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">n</span>=b</span><br><span class="line"><span class="attr">m</span>=a+b</span><br><span class="line"><span class="attr">a</span>=n</span><br><span class="line"><span class="attr">b</span>=m</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>这个例子介绍了几个新特征。</p>
<p>第一行包含了一个复合赋值：变量 a 和 b 同时得到新值 0 和 1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</p>
<h3 id="end-关键字"><a href="#end-关键字" class="headerlink" title="end 关键字"></a>end 关键字</h3><p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line"><span class="keyword">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">1000</span>:</span><br><span class="line">    print(b, <span class="keyword">end</span>=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">a</span>, b = b, <span class="keyword">a</span>+b</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,</span><br></pre></td></tr></table></figure>

<h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># 该实例演示了数字猜谜游戏</span><br><span class="line"><span class="keyword">number</span> = <span class="number">7</span></span><br><span class="line">guess = -<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;数字猜谜游戏!&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> guess != <span class="keyword">number</span>:</span><br><span class="line">    guess = <span class="keyword">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你猜的数字：&quot;</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> guess == <span class="keyword">number</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;恭喜，你猜对了！&quot;</span>)</span><br><span class="line">    elif guess &lt; <span class="keyword">number</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;猜的数字小了...&quot;</span>)</span><br><span class="line">    elif guess &gt; <span class="keyword">number</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;猜的数字大了...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，实例输出结果如下：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">数字猜谜游戏!</span><br><span class="line">请输入你猜的数字：<span class="number">1</span></span><br><span class="line">猜的数字小了...</span><br><span class="line">请输入你猜的数字：<span class="number">9</span></span><br><span class="line">猜的数字大了...</span><br><span class="line">请输入你猜的数字：<span class="number">7</span></span><br><span class="line">恭喜，你猜对了！</span><br></pre></td></tr></table></figure>

<h2 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if 表达式1</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">语句</span></span><br><span class="line"><span class="attribute">    if 表达式2</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">语句</span></span><br><span class="line"><span class="attribute">    elif 表达式3</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">语句</span></span><br><span class="line"><span class="attribute">    else</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">语句</span></span><br><span class="line"><span class="attribute">elif 表达式4</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">语句</span></span><br><span class="line"><span class="attribute">else</span><span class="punctuation">:</span></span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>本章节将为大家介绍 Python 循环语句的使用。</p>
<p>Python 中的循环语句有 for 和 while。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sum</span> = <span class="number">0</span></span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> counter &lt;= n:</span><br><span class="line">    <span class="keyword">sum</span> = <span class="keyword">sum</span> + counter</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;1 到 %d 之和为: %d&quot;</span> % (n,<span class="keyword">sum</span>))</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>到 <span class="number">100</span> 之和为: <span class="number">5050</span></span><br></pre></td></tr></table></figure>

<h3 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h3><p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p>
<p>语法格式如下：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">while</span></span> &lt;<span class="variable">expr</span>&gt;:</span><br><span class="line">    &lt;<span class="function"><span class="title">statement</span>(<span class="variable">s</span>)&gt;</span></span><br><span class="line"><span class="function"><span class="variable"><span class="keyword">else</span></span>:</span></span><br><span class="line"><span class="function">    &lt;<span class="title">additional_statement</span>(<span class="variable">s</span>)&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span> 大于或等于 <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="简单语句组"><a href="#简单语句组" class="headerlink" title="简单语句组"></a>简单语句组</h3><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">flag = 1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (flag): <span class="built_in">print</span> (<span class="string">&#x27;欢迎访问菜鸟教程!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。</p>
<p>for循环的一般格式如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="symbol">&lt;variable&gt;</span> in <span class="symbol">&lt;sequence&gt;</span>:</span><br><span class="line">    <span class="symbol">&lt;statements&gt;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="symbol">&lt;statements&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sites = [<span class="string">&quot;Baidu&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">    <span class="keyword">if</span> site == <span class="string">&quot;Runoob&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;菜鸟教程！&quot;</span>)</span><br><span class="line">        break</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环数据 &quot;</span> + site)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有循环数据&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;完成循环！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行脚本后，在循环到 “Runoob”时会跳出循环体：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">循环数据 Baidu</span><br><span class="line">循环数据 Google</span><br><span class="line">菜鸟教程!</span><br><span class="line">完成循环!</span><br></pre></td></tr></table></figure>

<p>如果列表中没有 “Runoob”</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sites = [<span class="string">&quot;Baidu&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Taobao&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">    <span class="keyword">if</span> site == <span class="string">&quot;Runoob&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;菜鸟教程！&quot;</span>)</span><br><span class="line">        break</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环数据 &quot;</span> + site)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有循环数据&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;完成循环！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行脚本后</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">循环数据 <span class="keyword">Baidu</span></span><br><span class="line"><span class="keyword"></span>循环数据 Google</span><br><span class="line">循环数据 Taobao</span><br><span class="line">没有循环数据</span><br><span class="line">完成循环！</span><br></pre></td></tr></table></figure>

<h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h2><p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(5):</span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="built_in">print</span>(i)</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>你也可以使用range指定区间的值：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">   </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>负数：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(<span class="string">-10</span>, <span class="string">-100</span>, <span class="string">-30</span>) :</span><br><span class="line">    print(i)</span><br><span class="line">     </span><br><span class="line"><span class="string">-10</span></span><br><span class="line"><span class="string">-40</span></span><br><span class="line"><span class="string">-70</span></span><br></pre></td></tr></table></figure>

<p>您可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="selector-attr">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;QQ&#x27;</span>]</span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="selector-tag">i</span>, <span class="selector-tag">a</span><span class="selector-attr">[i]</span>)</span><br><span class="line"><span class="number">0</span> Google</span><br><span class="line"><span class="number">1</span> Baidu</span><br><span class="line"><span class="number">2</span> Runoob</span><br><span class="line"><span class="number">3</span> Taobao</span><br><span class="line"><span class="number">4</span> QQ</span><br></pre></td></tr></table></figure>

<p>还可以使用range()函数来创建一个列表：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>(range(<span class="number">5</span>))</span><br><span class="line"><span class="selector-attr">[0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="break-和-continue-语句及循环中的-else-子句"><a href="#break-和-continue-语句及循环中的-else-子句" class="headerlink" title="break 和 continue 语句及循环中的 else 子句"></a>break 和 continue 语句及循环中的 else 子句</h2><p><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</p>
<p><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>:     <span class="meta"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&#x27;当前字母为 :&#x27;</span>, letter)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">var</span> = <span class="number">10</span>                    <span class="meta"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">var</span> &gt; <span class="number">0</span>:              </span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&#x27;当前变量值为 :&#x27;</span>, <span class="built_in">var</span>)</span><br><span class="line">   <span class="built_in">var</span> = <span class="built_in">var</span> <span class="number">-1</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">var</span> == <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">当前字母为 : <span class="type">R</span></span><br><span class="line">当前字母为 : <span class="type">u</span></span><br><span class="line">当前字母为 : <span class="type">n</span></span><br><span class="line">当前字母为 : <span class="type">o</span></span><br><span class="line">当前字母为 : <span class="type">o</span></span><br><span class="line">当前变量值为 : 10</span><br><span class="line">当前变量值为 : 9</span><br><span class="line">当前变量值为 : 8</span><br><span class="line">当前变量值为 : 7</span><br><span class="line">当前变量值为 : 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<p>以下实例循环字符串 Runoob，碰到字母 o 跳过输出：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>:     <span class="meta"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;o&#x27;</span>:        <span class="meta"># 字母为 o 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">var</span> = <span class="number">10</span>                    <span class="meta"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">var</span> &gt; <span class="number">0</span>:              </span><br><span class="line">   <span class="built_in">var</span> = <span class="built_in">var</span> <span class="number">-1</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">var</span> == <span class="number">5</span>:             <span class="meta"># 变量为 5 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&#x27;当前变量值 :&#x27;</span>, <span class="built_in">var</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">当前字母 : <span class="type">R</span></span><br><span class="line">当前字母 : <span class="type">u</span></span><br><span class="line">当前字母 : <span class="type">n</span></span><br><span class="line">当前字母 : <span class="type">b</span></span><br><span class="line">当前变量值 : 9</span><br><span class="line">当前变量值 : 8</span><br><span class="line">当前变量值 : 7</span><br><span class="line">当前变量值 : 6</span><br><span class="line">当前变量值 : 4</span><br><span class="line">当前变量值 : 3</span><br><span class="line">当前变量值 : 2</span><br><span class="line">当前变量值 : 1</span><br><span class="line">当前变量值 : 0</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n in <span class="keyword">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x in <span class="keyword">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(n, <span class="string">&#x27;等于&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n<span class="comment">//x)</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        # 循环中没有找到元素</span><br><span class="line">        <span class="built_in">print</span>(n, <span class="string">&#x27; 是质数&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span> 是质数</span><br><span class="line"><span class="symbol">3 </span> 是质数</span><br><span class="line"><span class="symbol">4 </span>等于 <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span> 是质数</span><br><span class="line"><span class="symbol">6 </span>等于 <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="symbol">7 </span> 是质数</span><br><span class="line"><span class="symbol">8 </span>等于 <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="symbol">9 </span>等于 <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>

<p>最小的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">class</span> <span class="title class_">MyEmptyClass</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>迭代器对象可以使用常规for语句进行遍历：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">list = [1, 2, 3, 4]</span><br><span class="line">it = iter(list)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(x, <span class="attribute">end</span>=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 next() 函数：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">import sys  <span class="comment"># 引入 sys 模块</span></span><br><span class="line"></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    try:</span><br><span class="line">        print(<span class="keyword">next</span>(it))</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.<span class="keyword">exit</span>()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fibonacci(n):  <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n):</span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = fibonacci(<span class="number">10</span>)  <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    try:</span><br><span class="line">        print(<span class="keyword">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.<span class="keyword">exit</span>()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span> <span class="comment"># x 是全局变量，可在其他函数中使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_global</span>():</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_local</span>():</span><br><span class="line">    x = <span class="number">100</span> <span class="comment"># x 是局部变量，不影响全局变量中的 x</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">print_global() <span class="comment"># 10</span></span><br><span class="line">print_local() <span class="comment"># 100</span></span><br><span class="line">print_global() <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<p>我们定义了全局变量 x，在 <code>print_local</code> 中定义了与全局变量同名的局部变量 x，并将 100 赋值给 x，在这里修改的是局部变量的值，局部变量只在这个函数内部有效，全局变量不会受到影响。因此，两次 <code>print_global</code> 的结果都是 10。</p>
<p>定义局部变量的好处在于，控制变量的作用域范围，减少各个函数之间的干扰。全局变量可以在多个函数之间共享，一般建议仅将只读的变量设置为全局变量，比如圆周率 <code>π</code> 的值。那如果我们想修改全局变量怎么办呢？可以使用 <code>global</code> 关键字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span> <span class="comment"># x 是全局变量，可在其他函数中使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_global</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_local</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">print_global() <span class="comment"># 10</span></span><br><span class="line">print_local() <span class="comment"># 100</span></span><br><span class="line">print_global() <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>在 <code>print_local</code> 中，使用 <code>global x</code> 告诉 Python x 是一个全局变量，而非局部变量。因此 <code>x = 100</code> 将修改全局变量 x 的值。所以第二个 <code>print_global()</code> 将打印 100。</p>
<h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li>
</ul>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220423123106491.png" alt="image-20220423123106491"></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line"><span class="function">    函数体</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>让我们使用函数来输出”Hello World！”：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">hello</span>() :</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hello</span>()</span></span><br></pre></td></tr></table></figure>

<p>更复杂点的应用，函数中带上参数变量:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">max</span>(<span class="keyword">a</span>, b):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">a</span> &gt; b:</span><br><span class="line">        <span class="literal">return</span> <span class="keyword">a</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="literal">return</span> b</span><br><span class="line"> </span><br><span class="line"><span class="keyword">a</span> = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">print(<span class="built_in">max</span>(<span class="keyword">a</span>, b))</span><br></pre></td></tr></table></figure>

<p>计算面积函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算面积函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_welcome</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>, name)</span><br><span class="line"> </span><br><span class="line">print_welcome(<span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">w = <span class="number">4</span></span><br><span class="line">h = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;width =&quot;</span>, w, <span class="string">&quot; height =&quot;</span>, h, <span class="string">&quot; area =&quot;</span>, area(w, h))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Welcome Runoob</span><br><span class="line"><span class="attribute">width</span> <span class="operator">=</span> <span class="number">4</span>  height <span class="operator">=</span> <span class="number">5</span>  area <span class="operator">=</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p>
<p>如下实例调用了 <strong>printme()</strong> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="comment"># 打印任何传入的字符串</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">&quot;我要调用用户自定义函数!&quot;</span>)</span><br><span class="line">printme(<span class="string">&quot;再次调用同一函数&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">我要调用用户自定义函数!</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">a</span>=<span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><strong>不可变类型：</strong>变量赋值 <strong>a&#x3D;5</strong> 后再赋值 <strong>a&#x3D;10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li>
<li><strong>可变类型：</strong>变量赋值 <strong>la&#x3D;[1,2,3,4]</strong> 后再赋值 <strong>la[2]&#x3D;5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li>
<li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li>
</ul>
<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<h3 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h3><p>通过 <strong>id()</strong> 函数来查看内存地址变化：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">change</span>(<span class="variable">a</span>):</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="title">id</span>(<span class="variable">a</span>))</span></span><br><span class="line">    <span class="variable">a</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="title">id</span>(<span class="variable">a</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="variable">a</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">id</span>(<span class="variable">a</span>))</span></span><br><span class="line"><span class="function"><span class="title">change</span>(<span class="variable">a</span>)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">id</span>(<span class="variable">a</span>))</span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">140720485308064</span><br><span class="line">140720485308064</span><br><span class="line">140720485308352</span><br><span class="line">140720485308064</span><br></pre></td></tr></table></figure>

<p>可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。</p>
<h3 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h3><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changeme</span>(<span class="params">mylist</span>):</span><br><span class="line">    <span class="comment"># 修改传入的列表</span></span><br><span class="line">    mylist.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内取值: &quot;</span>, mylist)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(mylist))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(mylist))</span><br><span class="line">changeme(mylist)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外取值: &quot;</span>, mylist)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(mylist))</span><br></pre></td></tr></table></figure>

<p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">2786207069824</span><br><span class="line">函数内取值:  <span class="comment">[10, 20, 30, <span class="comment">[1, 2, 3, 4]</span>]</span></span><br><span class="line">2786207069824</span><br><span class="line">函数外取值:  <span class="comment">[10, 20, 30, <span class="comment">[1, 2, 3, 4]</span>]</span></span><br><span class="line">2786207069824</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>以下是调用函数时可使用的正式参数类型：</p>
<ul>
<li>必需参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<h3 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h3><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用 printme 函数，不加参数会报错</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;E:/study/pythonstudy/test.py&quot;</span>, <span class="built_in">line</span> <span class="number">9</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    printme()</span><br><span class="line">TypeError: printme() missing <span class="number">1</span> required positional <span class="keyword">argument</span>: <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( <span class="built_in">str</span> = <span class="string">&quot;菜鸟教程&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>

<p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line">def printinfo(name, age):</span><br><span class="line">    <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用printinfo函数</span></span><br><span class="line">printinfo(<span class="attribute">age</span>=50, <span class="attribute">name</span>=<span class="string">&quot;runoob&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">名字:  runoob</span></span><br><span class="line"><span class="section">年龄:  50</span></span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line">def printinfo(name, <span class="attribute">age</span>=35):</span><br><span class="line">    <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用printinfo函数</span></span><br><span class="line">printinfo(<span class="attribute">age</span>=50, <span class="attribute">name</span>=<span class="string">&quot;runoob&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">printinfo(<span class="attribute">name</span>=<span class="string">&quot;runoob&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line"><span class="section">年龄:  50</span></span><br><span class="line"><span class="section">------------------------</span></span><br><span class="line">名字:  runoob</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure>

<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">def functionname([<span class="keyword">formal</span><span class="number">_</span>args,] *var<span class="number">_</span>args<span class="number">_</span>tuple ):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   <span class="keyword">function</span><span class="number">_</span>suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>

<p><strong>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line">def printinfo(arg1, *vartuple):</span><br><span class="line">    <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arg1)</span><br><span class="line">    <span class="built_in">print</span>(vartuple)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(70, 60, 50)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="comment">(60, 50)</span></span><br></pre></td></tr></table></figure>

<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 可写函数说明</span></span><br><span class="line">def printinfo(arg1, *vartuple):</span><br><span class="line">    <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">    <span class="keyword">print</span>(<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">    <span class="keyword">print</span>(arg1)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">var</span> <span class="keyword">in</span> vartuple:</span><br><span class="line">        <span class="keyword">print</span>(<span class="built_in">var</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">10</span>)</span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输出:</span></span><br><span class="line">10</span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>元组式可变参数用 <code>*参数名</code> 表示，传入的实际参数会构成一个元组，例如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现一个求和函数，支持传入任意个数字</span></span><br><span class="line"><span class="attribute">def</span> sum_n(*nums):</span><br><span class="line">    <span class="attribute">s</span> = <span class="number">0</span></span><br><span class="line">    <span class="attribute">for</span> num in nums:</span><br><span class="line">        <span class="attribute">s</span> += num</span><br><span class="line">    <span class="attribute">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="attribute">print</span>(sum_n(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) # <span class="number">6</span></span><br><span class="line"><span class="attribute">print</span>(sum_n(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) # <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>还有一种就是参数带两个星号 *<strong>*</strong> 基本语法如下：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">def functionname([<span class="keyword">formal</span><span class="number">_</span>args,] **var<span class="number">_</span>args<span class="number">_</span>dict ):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   <span class="keyword">function</span><span class="number">_</span>suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>

<p>加了两个星号 *<strong>*</strong>  的参数会以字典的形式导入。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line">def printinfo(arg1, **vardict):</span><br><span class="line">    <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arg1)</span><br><span class="line">    <span class="built_in">print</span>(vardict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(1, <span class="attribute">a</span>=2, <span class="attribute">b</span>=3)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;&#x27;a&#x27;: <span class="number">2</span>, &#x27;b&#x27;: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>字典式(键值对式)可变参数用<code>**参数名表示</code>，传入的实际参数会构成一个字典(dict)，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">def print_student(**students):</span><br><span class="line">    for name, age in students.<span class="built_in">items</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;今年 &#123;&#125; 岁&#x27;</span>.<span class="built_in">format</span>(name, age))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_student</span>(小明=<span class="number">8</span>, 小红=<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">小明今年<span class="number"> 8 </span>岁</span><br><span class="line">小红今年<span class="number"> 7 </span>岁</span><br></pre></td></tr></table></figure>

<p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br></pre></td></tr></table></figure>

<p>如果单独出现星号 ***** 后的参数必须用关键字传入。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="keyword">return</span> a+b+c</span></span><br><span class="line"><span class="meta prompt_">...</span> </span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment"># 报错</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: f() takes 2 positional arguments but 3 were given</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 正常</span></span></span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Python 使用 <strong>lambda</strong> 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数。</p>
<ul>
<li><strong>lambda</strong> 只是一个表达式，函数体比 <strong>def</strong> 简单很多。</li>
<li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li>
<li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda 函数的语法只包含一个语句，如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lambda</span> [arg1 [,arg2,.....argn]]<span class="symbol">:expression</span></span><br></pre></td></tr></table></figure>

<p>设置参数 a 加上 10:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">x = lambda <span class="selector-tag">a</span> : <span class="selector-tag">a</span> + <span class="number">10</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(x(<span class="number">5</span>)</span></span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<p>以下实例匿名函数设置两个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>(<span class="number">20</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure>

<p>我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p>
<p>以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">myfunc</span>(<span class="variable">n</span>):</span></span><br><span class="line"><span class="function">    <span class="variable">return</span> <span class="variable">lambda</span> <span class="variable">a</span>: <span class="variable">a</span> * <span class="variable">n</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="variable">mydoubler</span> = <span class="title">myfunc</span>(<span class="number">2</span>)</span></span><br><span class="line"><span class="variable">mytripler</span> = <span class="function"><span class="title">myfunc</span>(<span class="number">3</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">mydoubler</span>(<span class="number">11</span>))</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">mytripler</span>(<span class="number">11</span>))</span></span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">22</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># 可写函数说明</span><br><span class="line">def <span class="built_in">sum</span>(arg1, arg2):</span><br><span class="line">    # 返回2个参数的和.&quot;</span><br><span class="line">    <span class="keyword">total</span> = arg1 + arg2</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">&quot;函数内 : &quot;</span>, <span class="keyword">total</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">total</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用<span class="keyword">sum</span>函数</span><br><span class="line"><span class="keyword">total</span> = <span class="built_in">sum</span>(10, 20)</span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;函数外 : &quot;</span>, <span class="keyword">total</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure>

<p>如果不带return：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># 可写函数说明</span><br><span class="line">def <span class="built_in">sum</span>(arg1, arg2):</span><br><span class="line">    # 返回2个参数的和.&quot;</span><br><span class="line">    <span class="keyword">total</span> = arg1 + arg2</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">&quot;函数内 : &quot;</span>, <span class="keyword">total</span>)</span><br><span class="line"></span><br><span class="line"># 调用<span class="keyword">sum</span>函数</span><br><span class="line"><span class="keyword">total</span> = <span class="built_in">sum</span>(10, 20)</span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;函数外 : &quot;</span>, <span class="keyword">total</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">函数内 :  30</span><br><span class="line">函数外 :  <span class="type">None</span></span><br></pre></td></tr></table></figure>

<h2 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h2><p>Python3.8 新增了一个函数形参语法 &#x2F; 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">def f(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, /, c, d, *, e, f):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure>

<p>以下使用方法是正确的:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">f</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>以下使用方法会发生错误:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">f</span>(<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)   # b 不能使用关键字参数的形式</span><br><span class="line"><span class="attribute">f</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, f=<span class="number">60</span>)           # e 必须使用关键字参数的形式</span><br></pre></td></tr></table></figure>

<h2 id="文档字符串-doc"><a href="#文档字符串-doc" class="headerlink" title="文档字符串 doc"></a>文档字符串 <strong>doc</strong></h2><p>给每一个函数写文档是编程的好习惯，在 Python 中，对每个函数来说，有一个内置的属性 <code>__doc__</code> 保存了函数的说明文档，Python 中称之为 <code>DocStrings</code>。那怎么定义这个属性呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_student</span>(<span class="params">**students</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Prints name and age for every student.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    key is name, and value is age.&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> name, age <span class="keyword">in</span> students.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;今年 &#123;&#125; 岁&#x27;</span>.<span class="built_in">format</span>(name, age))</span><br><span class="line"></span><br><span class="line">print_student(小明=<span class="number">8</span>, 小红=<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(print_student.__doc__) <span class="comment"># 打印 __doc__ 的值</span></span><br><span class="line"><span class="built_in">help</span>(print_student)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数体一开始使用三个单引号<code>&#39;&#39;&#39;</code>标志 DocStrings 的开始。</li>
<li>第一行描述函数的作用，首字母大写。第二行为空行，第三行是详细的描述，可以包括函数每一个参数的介绍等。</li>
</ul>
<p>执行结果：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">小明今年 <span class="number">8</span> 岁</span><br><span class="line">小红今年 <span class="number">7</span> 岁</span><br><span class="line">Prints<span class="built_in"> name</span> <span class="keyword">and</span> age <span class="keyword">for</span> <span class="keyword">every</span> student.</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> key</span> <span class="literal">is</span><span class="built_in"> name</span>, <span class="keyword">and</span> <span class="keyword">value</span> <span class="literal">is</span> age.</span><br><span class="line">Help on <span class="keyword">function</span> print_student <span class="keyword">in</span> <span class="keyword">module</span> __main_<span class="number">_</span>:</span><br><span class="line"></span><br><span class="line">print_student(**students)</span><br><span class="line">    Prints<span class="built_in"> name</span> <span class="keyword">and</span> age <span class="keyword">for</span> <span class="keyword">every</span> student.</span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> key</span> <span class="literal">is</span><span class="built_in"> name</span>, <span class="keyword">and</span> <span class="keyword">value</span> <span class="literal">is</span> age.</span><br></pre></td></tr></table></figure>

<h1 id="数据结列表"><a href="#数据结列表" class="headerlink" title="数据结列表"></a>数据结列表</h1><p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。</p>
<p>以下是 Python 中列表的方法：构</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">list.append(x)</td>
<td align="left">把一个元素添加到列表的结尾，相当于 a[len(a):] &#x3D; [x]。</td>
</tr>
<tr>
<td align="left">list.extend(L)</td>
<td align="left">通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] &#x3D; L。</td>
</tr>
<tr>
<td align="left">list.insert(i, x)</td>
<td align="left">在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td>
</tr>
<tr>
<td align="left">list.remove(x)</td>
<td align="left">删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td>
</tr>
<tr>
<td align="left">list.pop([i])</td>
<td align="left">从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td>
</tr>
<tr>
<td align="left">list.clear()</td>
<td align="left">移除列表中的所有项，等于del a[:]。</td>
</tr>
<tr>
<td align="left">list.index(x)</td>
<td align="left">返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td>
</tr>
<tr>
<td align="left">list.count(x)</td>
<td align="left">返回 x 在列表中出现的次数。</td>
</tr>
<tr>
<td align="left">list.sort()</td>
<td align="left">对列表中的元素进行排序。</td>
</tr>
<tr>
<td align="left">list.reverse()</td>
<td align="left">倒排列表中的元素。</td>
</tr>
<tr>
<td align="left">list.copy()</td>
<td align="left">返回列表的浅复制，等于a[:]。</td>
</tr>
</tbody></table>
<p>下面示例演示了列表的大部分方法：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = [<span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span>(a.count(<span class="number">333</span>), a.count(<span class="number">66.25</span>), a.count(<span class="string">&#x27;x&#x27;</span>))</span></span><br><span class="line">2 1 0</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a.insert(<span class="number">2</span>, -<span class="number">1</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a.append(<span class="number">333</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[66.25, 333, -1, 333, 1, 1234.5, 333]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a.index(<span class="number">333</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a.remove(<span class="number">333</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[66.25, -1, 333, 1, 1234.5, 333]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a.reverse()</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[333, 1234.5, 1, 333, -1, 66.25]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a.sort()</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[-1, 1, 66.25, 333, 333, 1234.5]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">del</span> a[<span class="number">0</span>] <span class="comment"># 删除下标为1的元素</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[1, 66.25, 333, 333, 1234.5]</span><br></pre></td></tr></table></figure>

<p>注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。</p>
<h2 id="将列表当做堆栈使用"><a href="#将列表当做堆栈使用" class="headerlink" title="将列表当做堆栈使用"></a>将列表当做堆栈使用</h2><p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。例如：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.append(<span class="number">6</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.append(<span class="number">7</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack</span></span><br><span class="line">[3, 4, 5, 6, 7]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.pop()</span></span><br><span class="line">7</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack</span></span><br><span class="line">[3, 4, 5, 6]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.pop()</span></span><br><span class="line">6</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.pop()</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack</span></span><br><span class="line">[3, 4]</span><br></pre></td></tr></table></figure>

<h2 id="将列表当作队列使用"><a href="#将列表当作队列使用" class="headerlink" title="将列表当作队列使用"></a>将列表当作队列使用</h2><p>也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue = deque([<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.append(<span class="string">&quot;Terry&quot;</span>)           <span class="comment"># Terry arrives</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.append(<span class="string">&quot;Graham&quot;</span>)          <span class="comment"># Graham arrives</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.popleft()                 <span class="comment"># The first to arrive now leaves</span></span></span><br><span class="line">&#x27;Eric&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.popleft()                 <span class="comment"># The second to arrive now leaves</span></span></span><br><span class="line">&#x27;John&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue                           <span class="comment"># Remaining queue in order of arrival</span></span></span><br><span class="line">deque([&#x27;Michael&#x27;, &#x27;Terry&#x27;, &#x27;Graham&#x27;])</span><br></pre></td></tr></table></figure>

<h2 id="列表推导式-1"><a href="#列表推导式-1" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p>
<p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>
<p>这里我们将列表中每个数值乘三，获得一个新的列表：</p>
<p>现在我们玩一点小花样：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="comment">[<span class="comment">[x, x**2]</span> for x in vec]</span></span><br><span class="line"><span class="comment">[<span class="comment">[2, 4]</span>, <span class="comment">[4, 16]</span>, <span class="comment">[6, 36]</span>]</span></span><br></pre></td></tr></table></figure>

<p>这里我们对序列里每一个元素逐个调用某方法：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; freshfruit = [<span class="string">&#x27;  banana&#x27;</span>, <span class="string">&#x27;  loganberry &#x27;</span>, <span class="string">&#x27;passion fruit  &#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>我们可以用 if 子句作为过滤器：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [<span class="number">3</span>*<span class="keyword">x</span> for <span class="keyword">x</span> in vec if <span class="keyword">x</span> &gt; <span class="number">3</span>]</span><br><span class="line">[<span class="number">12</span><span class="punctuation">,</span> <span class="number">18</span>]</span><br><span class="line">&gt;&gt;&gt; [<span class="number">3</span>*<span class="keyword">x</span> for <span class="keyword">x</span> in vec if <span class="keyword">x</span> &lt; <span class="number">2</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>以下是一些关于循环和其它技巧的演示：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">vec1 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">vec2 = [<span class="number">4</span>, <span class="number">3</span>, -<span class="number">9</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[x*y <span class="keyword">for</span> x <span class="keyword">in</span> vec1 <span class="keyword">for</span> y <span class="keyword">in</span> vec2]</span></span><br><span class="line">[8, 6, -18, 16, 12, -36, 24, 18, -54]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[x+y <span class="keyword">for</span> x <span class="keyword">in</span> vec1 <span class="keyword">for</span> y <span class="keyword">in</span> vec2]</span></span><br><span class="line">[6, 5, -7, 8, 7, -5, 10, 9, -3]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[vec1[i]*vec2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vec1))]</span></span><br><span class="line">[8, 12, -54]</span><br></pre></td></tr></table></figure>

<p>列表推导式可以使用复杂表达式或嵌套函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">str</span>(<span class="built_in">round</span>(<span class="number">355</span>/<span class="number">113</span>, i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">[<span class="string">&#x27;3.1&#x27;</span>, <span class="string">&#x27;3.14&#x27;</span>, <span class="string">&#x27;3.142&#x27;</span>, <span class="string">&#x27;3.1416&#x27;</span>, <span class="string">&#x27;3.14159&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="嵌套列表解析"><a href="#嵌套列表解析" class="headerlink" title="嵌套列表解析"></a>嵌套列表解析</h2><p>Python的列表还可以嵌套。</p>
<p>以下实例展示了3X4的矩阵列表：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">matrix</span> = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">matrix</span>)</span><br><span class="line">a = [[<span class="built_in">row</span>[i] <span class="keyword">for</span> <span class="built_in">row</span> <span class="keyword">in</span> <span class="built_in">matrix</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</span></span><br><span class="line"><span class="string">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span></span><br></pre></td></tr></table></figure>

<p>以下实例也可以使用以下方法来实现：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">matrix</span> = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">matrix</span>)</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    transposed.<span class="built_in">append</span>([<span class="built_in">row</span>[i] <span class="keyword">for</span> <span class="built_in">row</span> <span class="keyword">in</span> <span class="built_in">matrix</span>])</span><br><span class="line"><span class="built_in">print</span>(transposed)</span><br></pre></td></tr></table></figure>

<p>另外一种实现方法：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">matrix</span> = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">matrix</span>)</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    transposed_row = []</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">row</span> <span class="keyword">in</span> <span class="built_in">matrix</span>:</span><br><span class="line">        transposed_row.<span class="built_in">append</span>(<span class="built_in">row</span>[i])</span><br><span class="line">    transposed.<span class="built_in">append</span>(transposed_row)</span><br><span class="line"><span class="built_in">print</span>(transposed)</span><br></pre></td></tr></table></figure>

<h2 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h2><p>使用 del 语句可以从一个列表中根据索引来删除一个元素，而不是值来删除元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">del</span> a[<span class="number">0</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[1, 66.25, 333, 333, 1234.5]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">del</span> a[<span class="number">2</span>:<span class="number">4</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[1, 66.25, 1234.5]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">del</span> a[:]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>也可以用 del 删除实体变量：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">del</span> a</span></span><br></pre></td></tr></table></figure>

<h2 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h2><p>元组由若干逗号分隔的值组成，例如：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t[<span class="number">0</span>]</span></span><br><span class="line">12345</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t</span></span><br><span class="line">(12345, 54321, &#x27;hello!&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="comment"># Tuples may be nested:</span></span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">u</span></span><br><span class="line">((12345, 54321, &#x27;hello!&#x27;), (1, 2, 3, 4, 5))</span><br></pre></td></tr></table></figure>

<p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p>
<h2 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h2><p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。</p>
<p>可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。</p>
<p>以下是一个简单的演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 删除重复的</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 检测成员</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 以下演示了两个集合的操作</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># a 中唯一的字母</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 在 a 中的字母，但不在 b 中</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 在 a 或 b 中的字母</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 在 a 和 b 中都有的字母</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 在 a 或 b 中的字母，但不同时在 a 和 b 中</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合也支持推导式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><p>另一个非常有用的 Python 内建数据类型是字典。</p>
<p>序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p>
<p>理解字典的最佳方式是把它看做无序的键&#x3D;&gt;值对集合。在同一个字典之内，关键字必须是互不相同。</p>
<p>一对大括号创建一个空的字典：{}。</p>
<p>这是一个字典运用的简单例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;guido&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="number">4098</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> tel[<span class="string">&#x27;sape&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;irv&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;irv&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(tel.keys())</span><br><span class="line">[<span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(tel.keys())</span><br><span class="line">[<span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="title function_">dict</span>(<span class="params">[(<span class="string">&#x27;sape&#x27;</span>, <span class="number">4139</span>), (<span class="string">&#x27;guido&#x27;</span>, <span class="number">4127</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">4098</span>)]</span>)</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此外，字典推导可以用来创建任意键和值的表达式词典：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;&gt;&gt;</span> &#123;<span class="attr">x:</span> <span class="string">x**2</span> <span class="string">for</span> <span class="string">x</span> <span class="string">in</span> <span class="string">(2</span>, <span class="number">4</span>, <span class="number">6</span><span class="string">)</span>&#125;</span><br><span class="line">&#123;<span class="attr">2:</span> <span class="number">4</span>, <span class="attr">4:</span> <span class="number">16</span>, <span class="attr">6:</span> <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dict(<span class="attribute">sape</span>=4139, <span class="attribute">guido</span>=4127, <span class="attribute">jack</span>=4098)</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: 4139, <span class="string">&#x27;jack&#x27;</span>: 4098, <span class="string">&#x27;guido&#x27;</span>: 4127&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h2><p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="built_in">print</span>(k, v)</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>

<p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="built_in">print</span>(i, v)</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">0 tic</span><br><span class="line">1 tac</span><br><span class="line">2 toe</span><br></pre></td></tr></table></figure>

<p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">questions = <span class="selector-attr">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span></span><br><span class="line">answers = <span class="selector-attr">[<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">q</span>, <span class="selector-tag">a</span> <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span><span class="selector-class">.format</span>(<span class="selector-tag">q</span>, a))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">What <span class="keyword">is</span> your name?  It <span class="keyword">is</span> lancelot.</span><br><span class="line">What <span class="keyword">is</span> your quest?  It <span class="keyword">is</span> the holy grail.</span><br><span class="line">What <span class="keyword">is</span> your favorite color?  It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure>

<p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="built_in">print</span>(i)</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> sorted(<span class="built_in">set</span>(basket)):</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">apple</span><br><span class="line"><span class="keyword">banana</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">orange</span></span><br><span class="line"><span class="keyword"></span>pear</span><br></pre></td></tr></table></figure>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在前面的几个章节中我们基本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p>
<p>下面是一个使用 python 标准库中模块的例子。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&#x27;命令行参数如下:&#x27;</span>)</span></span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> sys<span class="selector-class">.argv</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&#x27;\n\nPython 路径为：&#x27;</span>, sys.path, <span class="string">&#x27;\n&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>执行结果如下所示：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">命令行参数如下:</span><br><span class="line">E:/study/pythonstudy/test.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python 路径为： [&#x27;E:<span class="symbol">\\</span>study<span class="symbol">\\</span>pythonstudy&#x27;, &#x27;E:<span class="symbol">\\</span>study<span class="symbol">\\</span>pythonstudy&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>JetBrains<span class="symbol">\\</span>PyCharm 2020.1<span class="symbol">\\</span>plugins<span class="symbol">\\</span>python<span class="symbol">\\</span>helpers<span class="symbol">\\</span>pycharm_display&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>python38.zip&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>DLLs&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>lib&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38&#x27;, &#x27;C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>hahaha<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Roaming<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python38<span class="symbol">\\</span>site-packages&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>lib<span class="symbol">\\</span>site-packages&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>JetBrains<span class="symbol">\\</span>PyCharm 2020.1<span class="symbol">\\</span>plugins<span class="symbol">\\</span>python<span class="symbol">\\</span>helpers<span class="symbol">\\</span>pycharm_matplotlib_backend&#x27;] </span><br></pre></td></tr></table></figure>

<ul>
<li>1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。</li>
<li>2、sys.argv 是一个包含命令行参数的列表。</li>
<li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li>
</ul>
<h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">module</span><span class="number">1</span>[, <span class="keyword">module</span><span class="number">2</span>[,... moduleN]</span><br></pre></td></tr></table></figure>

<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：</p>
<p> support.py 文件代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_func</span>(<span class="params"> par </span>):</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Hello : &quot;</span>, par)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>test.py 引入 support 模块：</p>
<p>test.py 文件代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> support</span><br><span class="line"></span><br><span class="line"><span class="meta"># 现在可以调用模块里包含的函数了</span></span><br><span class="line"><span class="title">support</span>.print_func(<span class="string">&quot;Runoob&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Hello :  <span class="type">Runoob</span></span><br></pre></td></tr></table></figure>

<p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p>
<p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#x27;&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>python38.zip&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>DLLs&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>lib&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38&#x27;,&#x27;C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>hahaha<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Roaming<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python38<span class="symbol">\\</span>site-packages&#x27;, &#x27;C:<span class="symbol">\\</span>Program Files<span class="symbol">\\</span>Python38<span class="symbol">\\</span>lib<span class="symbol">\\</span>site-packages&#x27;]</span><br></pre></td></tr></table></figure>

<p>sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契(fibonacci)数列模块</span></span><br><span class="line"></span><br><span class="line">def fib(n):  <span class="comment"># 定义到 n 的斐波那契数列</span></span><br><span class="line">    <span class="keyword">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        print(b, <span class="keyword">end</span>=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">a</span>, b = b, <span class="keyword">a</span> + b</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fib2(n):  <span class="comment"># 返回到 n 的斐波那契数列</span></span><br><span class="line">    <span class="built_in">result</span> = []</span><br><span class="line">    <span class="keyword">a</span>, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        <span class="built_in">result</span>.append(b)</span><br><span class="line">        <span class="keyword">a</span>, b = b, <span class="keyword">a</span> + b</span><br><span class="line">    <span class="literal">return</span> <span class="built_in">result</span></span><br></pre></td></tr></table></figure>

<p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">import</span> fibo</span></span><br></pre></td></tr></table></figure>

<p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;fibo.fib(1000)</span><br><span class="line">1<span class="number"> 1 </span>2<span class="number"> 3 </span>5<span class="number"> 8 </span>13<span class="number"> 21 </span>34<span class="number"> 55 </span>89<span class="number"> 144 </span>233<span class="number"> 377 </span>610 987</span><br><span class="line">&gt;&gt;&gt; fibo.fib2(100)</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br><span class="line">&gt;&gt;&gt; fibo.__name__</span><br><span class="line">&#x27;fibo&#x27;</span><br></pre></td></tr></table></figure>

<p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fib = fibo.fib</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">1<span class="number"> 1 </span>2<span class="number"> 3 </span>5<span class="number"> 8 </span>13<span class="number"> 21 </span>34<span class="number"> 55 </span>89<span class="number"> 144 </span>233 377</span><br></pre></td></tr></table></figure>

<h2 id="from-…-import-语句"><a href="#from-…-import-语句" class="headerlink" title="from … import 语句"></a>from … import 语句</h2><p>有时候，导入的模块名路径很深，可以使用 <code>from xxx import xxx</code>来简化导入的路径：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="string">&#x27;/tmp&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"># 可以替换为</span><br><span class="line">from <span class="built_in">os</span> import <span class="built_in">path</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">path</span>.join(<span class="string">&#x27;/tmp&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fib(<span class="number">500</span>)</span></span><br><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<h2 id="from-…-import-语句-1"><a href="#from-…-import-语句-1" class="headerlink" title="from … import * 语句"></a>from … import * 语句</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><strong>name</strong>属性</h2><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<strong>name</strong>属性来使该程序块仅在该模块自身运行时执行。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">if</span></span> <span class="variable">__name__</span> == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="function"><span class="title">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span></span><br><span class="line"><span class="variable"><span class="keyword">else</span></span>:</span><br><span class="line">   <span class="function"><span class="title">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<p>运行输出如下：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line">程序自身在运行</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">import</span> using_name</span></span><br><span class="line">我来自另一模块</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 每个模块都有一个<strong>name</strong>属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p>
<p>说明：**<strong>name</strong>** 与 <strong><strong>main</strong></strong> 底下是双下划线， <strong>_ _</strong> 是这样去掉中间的那个空格。</p>
<h2 id="模块别名"><a href="#模块别名" class="headerlink" title="模块别名"></a>模块别名</h2><p>如果我们导入的模块名有冲突，可以使用 <code>as</code> 为导入的模块起一个别名</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math as math2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(math2.__name__)<span class="meta"> # 模块名 math</span></span><br><span class="line"><span class="built_in">print</span>(math2.<span class="built_in">ceil</span>(<span class="number">4.3</span>))<span class="meta"> # 向上取整 5</span></span><br><span class="line"><span class="built_in">print</span>(math2.<span class="built_in">floor</span>(<span class="number">4.8</span>))<span class="meta"> # 向下取整 4</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">math</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h2><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">import</span> <span class="variable">fibo</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">dir</span>(<span class="variable">fibo</span>))</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">&#x27;__builtins__</span>&#x27;, <span class="symbol">&#x27;__cached__</span>&#x27;, <span class="symbol">&#x27;__doc__</span>&#x27;, <span class="symbol">&#x27;__file__</span>&#x27;, <span class="symbol">&#x27;__loader__</span>&#x27;, <span class="symbol">&#x27;__name__</span>&#x27;, <span class="symbol">&#x27;__package__</span>&#x27;, <span class="symbol">&#x27;__spec__</span>&#x27;, <span class="symbol">&#x27;fib</span>&#x27;, <span class="symbol">&#x27;fib2</span>&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import fibo</span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-attr">[1, 2, 3, 4, 5]</span></span><br><span class="line">fib = fibo<span class="selector-class">.fib</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(dir()</span></span>)</span><br><span class="line"><span class="selector-attr">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;fibo&#x27;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h2><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。</p>
<p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p>
<p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。</p>
<p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1</span><br><span class="line"><span class="string">&#x27;&gt;&gt;&gt; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps2</span><br><span class="line"><span class="string">&#x27;... &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">&#x27;C&gt; &#x27;</span></span><br><span class="line">C&gt; <span class="built_in">print</span>(<span class="string">&#x27;Runoob!&#x27;</span>)</span><br><span class="line">Runoob!</span><br><span class="line">C&gt; </span><br></pre></td></tr></table></figure>

<h2 id="使用自己实现的模块"><a href="#使用自己实现的模块" class="headerlink" title="使用自己实现的模块"></a>使用自己实现的模块</h2><p>新建一个文件 <code>calc.py</code>，在里面实现如下的函数：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">def area(<span class="keyword">length</span>, <span class="keyword">width</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">length</span> * <span class="keyword">width</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="string">&#x27;this is calc module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">assert</span>(area(<span class="number">3</span>, <span class="number">4</span>) == <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">&#x27;test done&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行 <code>python calc.py</code>，将会输出：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">this is calc module</span><br><span class="line"><span class="keyword">test </span>done</span><br></pre></td></tr></table></figure>

<p>在 <code>main.py</code> 中我们可以导入模块 <code>calc</code> 并使用，在 Python 中一个 <code>.py</code> 文件就可以被视为一个模块：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(calc.__name__)</span><br><span class="line">    <span class="built_in">print</span>(calc.area(5, 10))</span><br></pre></td></tr></table></figure>

<p>执行 <code>python main.py</code>，将会输出：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> calc <span class="keyword">module</span></span><br><span class="line">calc</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>当模块被导入时会执行该模块的代码，因此也打印了 <code>this is calc module</code>，但没有打印 <code>test done</code>。</p>
<p>当 <code>calc.py</code> 作为一个模块导入时，属性 <code>__name__</code> 与文件名相同，即等于 <code>calc</code>，因此没有进入到 <code>if</code> 分支中，而被独立执行时，<code>__name__</code> 的值是 <code>__main__</code>，因此进入到了 <code>if</code> 分支，打印了 <code>test done</code>。</p>
<p>因此，我们可以利用这个特性，在模块被独立执行时运行一些代码，比如简单的测试逻辑，但不影响被导入时的执行逻辑。</p>
<h2 id="使用第三方模块"><a href="#使用第三方模块" class="headerlink" title="使用第三方模块"></a>使用第三方模块</h2><p>Python 拥有非常丰富的第三方模块，比如著名的爬虫框架 <code>scrapy</code>，数学基础库 <code>numpy</code>、数据处理利器 <code>pandas</code> 等。如果我们想使用第三方模块，只需要使用 <code>pip</code> 命令安装即可。</p>
<p>例如安装 numpy：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure>

<p>如果你的机器上同时安装了 Python2 和 Python3，给特定的 Python 版本安装可以使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">python3 -m pip <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure>

<p>如果国内下载网速过慢，可以通过 <code>-i</code> 选项指定下载源：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pip install numpy -i http:<span class="regexp">//</span>pypi.douban.com<span class="regexp">/simple/</span> --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>

<p>安装完成后，就可以像使用标准库一样使用 <code>numpy</code> 了：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">a = np.array(<span class="string">[[1, 2, 3], [4, 5, 6]]</span>)</span><br><span class="line">b = np.array(<span class="string">[[1, 5, 8], [2, 5, 6]]</span>)</span><br><span class="line"><span class="built_in">print</span> (a - b) # 两个矩阵相减</span><br><span class="line"># <span class="string">[[ 0 -3 -5]</span></span><br><span class="line"><span class="string">#  [ 2  0  0]]</span></span><br></pre></td></tr></table></figure>



<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sound/                          顶层包</span><br><span class="line">      __init__<span class="selector-class">.py</span>               初始化 sound 包</span><br><span class="line">      formats/                  文件格式转换子包</span><br><span class="line">              __init__<span class="selector-class">.py</span></span><br><span class="line">              wavread<span class="selector-class">.py</span></span><br><span class="line">              wavwrite<span class="selector-class">.py</span></span><br><span class="line">              aiffread<span class="selector-class">.py</span></span><br><span class="line">              aiffwrite<span class="selector-class">.py</span></span><br><span class="line">              auread<span class="selector-class">.py</span></span><br><span class="line">              auwrite<span class="selector-class">.py</span></span><br><span class="line">              ...</span><br><span class="line">      effects/                  声音效果子包</span><br><span class="line">              __init__<span class="selector-class">.py</span></span><br><span class="line">              echo<span class="selector-class">.py</span></span><br><span class="line">              surround<span class="selector-class">.py</span></span><br><span class="line">              reverse<span class="selector-class">.py</span></span><br><span class="line">              ...</span><br><span class="line">      filters/                  filters 子包</span><br><span class="line">              __init__<span class="selector-class">.py</span></span><br><span class="line">              equalizer<span class="selector-class">.py</span></span><br><span class="line">              vocoder<span class="selector-class">.py</span></span><br><span class="line">              karaoke<span class="selector-class">.py</span></span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>

<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的 :file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure>

<p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sound.effects.echo.echofilter(input, output, <span class="attribute">delay</span>=0.7, <span class="attribute">atten</span>=4)</span><br></pre></td></tr></table></figure>

<p>还有一种导入子模块的方法是:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>

<p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">echo.echofilter(input, output, <span class="attribute">delay</span>=0.7, <span class="attribute">atten</span>=4)</span><br></pre></td></tr></table></figure>

<p>还有一种变化就是直接导入一个函数或者变量:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure>

<p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">echofilter(input, output, <span class="attribute">delay</span>=0.7, <span class="attribute">atten</span>=4)</span><br></pre></td></tr></table></figure>

<p>注意当使用 <strong>from package import item</strong> 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <strong>:exc:ImportError</strong> 异常。</p>
<p>反之，如果使用形如 <strong>import item.subitem.subsubitem</strong> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<h2 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h2><p>如果我们使用 <strong>from sound.effects import *</strong> 会发生什么呢？</p>
<p>Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。</p>
<p>但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。</p>
<p>在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。</p>
<p>为了解决这个问题，我们只需要提供一个精确包的索引。</p>
<p>导入语句遵循如下规则：如果包定义文件 <strong><strong>init</strong>.py</strong> 存在一个叫做 <strong><strong>all</strong></strong> 的列表变量，那么在使用 <strong>from package import *</strong> 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 <strong><strong>all</strong></strong> 也更新了啊。</p>
<p>以下实例在 file:sounds&#x2F;effects&#x2F;<strong>init</strong>.py 中包含如下代码:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">__all__</span> = [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;surround&quot;</span>, <span class="string">&quot;reverse&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong><strong>all</strong></strong> 真的没有定义，那么使用**from sound.effects import ***这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。</p>
<p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="title">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>这个例子中，在执行 from…import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 <strong>all</strong> 就更没问题了）</p>
<p>通常我们并不主张使用 ***** 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用 <strong>from Package import specific_submodule</strong> 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure>

<p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性<strong>path</strong>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的<strong>init</strong>.py，你得在其他<strong>init</strong>.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>之前的例子我们使用了标准输入输出函数 <code>input</code> 和 <code>output</code> 实现了简单的功能。Python 常用于数据挖掘分析，文本处理是最基本的能力，使用 Python 进行文件读写也非常简单。</p>
<p>下面是一个非常简单的例子：将字符串 s 写入文件 <code>1.txt</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;&#x27;第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>open</code> 是 Python 用于读取文件的内置函数，第一个参数是文件路径，第二个参数是打开模式，<code>w</code> 代表写模式， <code>r</code>代表只读模式。<code>w</code> 模式打开文件后，文件会被清空，如果需要追加写，则需要以<code>a</code>模式打开文件。</li>
<li>如果打开文件成功，<code>open</code>会返回一个文件句柄，我们可以使用这个句柄对文件进行操作。</li>
<li>操作完毕后，需要将文件关闭。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">t</td>
<td align="left">文本模式 (默认)。</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">二进制模式。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">通用换行模式（<strong>Python 3 不支持</strong>）。</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td align="left">rb</td>
<td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">rb+</td>
<td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb</td>
<td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb+</td>
<td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td align="left">ab+</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p>
<p>Python 还提供了另一种更安全、简单的方式 <code>with as</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;&#x27;第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(s)</span><br></pre></td></tr></table></figure>

<p><code>with</code> 语句会在 <code>with</code> 内部的代码块执行完毕后，执行资源回收的操作，对于文件来说即关闭文件。</p>
<p>读取文件，并统计字数：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.<span class="built_in">read</span>()</span><br><span class="line">    print(<span class="built_in">len</span>(s)) <span class="comment"># 11，因为换行符也算一个字数</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <code>readlines()</code> 读取文件的所有行：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> s:</span><br><span class="line">        print(<span class="built_in">line</span>, <span class="keyword">end</span>=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br></pre></td></tr></table></figure>

<p>还有一种更高效的方式，直接遍历文件句柄 <code>f</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">        print(<span class="built_in">line</span>, <span class="keyword">end</span>=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>尽管我们想要将代码写得尽善尽美，但是出现异常还是难免的。如果我们不对异常做任何的处理，程序会立即退出。Python 提供了 <code>try except finally</code> 机制，给开发者提供了一个处理异常的机会。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们执行上述程序，会出现如下错误：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;E:/study/pythonstudy/test.py&quot;</span>, <span class="built_in">line</span> <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such <span class="built_in">file</span> <span class="keyword">or</span> <span class="built_in">directory</span>: <span class="string">&#x27;2.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>程序在第二行就退出了，错误原因是 <code>2.txt</code> 不存在。那我们如何捕获到这个错误并处理呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>程序正常执行结束：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">[Errno <span class="number">2</span>] <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> directory: <span class="string">&#x27;2.txt&#x27;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ul>
<li><code>try</code> 语句块中包含可能发生异常的代码，如果发生异常，将跳转到 <code>except</code> 语句块执行。</li>
<li>无论是否发生异常，<code>finally</code> 中的代码都会得到执行，<code>finally</code> 是可选的。</li>
</ul>
<p>我们也可以在 <code>except</code> 中处理完毕之后，继续将异常抛出，留给调用方处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">raise</span> e <span class="comment"># 往上抛异常</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[Errno <span class="number">2</span>] No such <span class="keyword">file</span> <span class="built_in">or</span> directory: <span class="string">&#x27;2.txt&#x27;</span></span><br><span class="line">done</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, <span class="built_in">line</span> <span class="number">7</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    raise <span class="keyword">e</span></span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, <span class="built_in">line</span> <span class="number">3</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    with <span class="keyword">open</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such <span class="keyword">file</span> <span class="built_in">or</span> directory: <span class="string">&#x27;2.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Python 是一门既支持过程式编程，又支持面向对象编程的一门语言。</p>
<blockquote>
<p>面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。</p>
</blockquote>
<p>面向对象编程的三大特性：</p>
<ul>
<li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li>
<li>继承： 子类从父类继承方法，使得子类具有父类相同的行为。</li>
<li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</li>
</ul>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>Python 中使用关键字 <code>class</code> 声明一个类，一般继承基类 <code>object</code>：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(object):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params"><span class="variable language_">self</span></span>):</span><br><span class="line">        print(<span class="string">&#x27;你好，我是&#123;&#125;，今年&#123;&#125;岁&#x27;</span>.format(<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    jack = Student(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">    jack.hello()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">你好，我是Jack，今年18岁</span><br></pre></td></tr></table></figure>

<ul>
<li>类内部声明的方法默认是实例方法，第一个参数是 <code>self</code>，代表实例本身，调用时省略。</li>
<li><code>__init__</code> 是一个类的构造方法，第一个参数是 <code>self</code>，后面的参数根据需要声明，使用时使用 <code>类名(参数)</code> 可创建出一个属于该类的一个实例对象。<code>name</code> 和 <code>age</code> 都属于实例变量，实例变量属于该实例，不与其他实例共享。</li>
<li>其他方法的声明与普通的函数实现类似，唯一不同点在于实例方法可以通过参数 <code>self</code> 获取实例的属性或调用实例的其他方法。</li>
</ul>
<h2 id="类方法与类变量"><a href="#类方法与类变量" class="headerlink" title="类方法与类变量"></a>类方法与类变量</h2><p>实例方法和实例变量是针对对象实例而言的，与实例方法和实例变量相对应的是类方法和类变量，属于该类的所有实例都可以共享，可以通过<code>类.方法</code> 或 <code>实例.方法</code> 的方式使用。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(object):</span><br><span class="line">    school = <span class="string">&#x27;东方小学&#x27;</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 实例变量</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age  <span class="comment"># 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params"><span class="variable language_">self</span></span>):</span><br><span class="line">        print(<span class="string">&#x27;你好，我是&#123;&#125;，今年&#123;&#125;岁&#x27;</span>.format(<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.age))</span><br><span class="line"></span><br><span class="line">    <span class="variable">@classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_school</span>(<span class="params">cls</span>):  <span class="comment"># 类方法</span></span><br><span class="line">        print(cls.school)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    jack = Student(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">    tom = Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">    jack.print_school()</span><br><span class="line">    tom.print_school()</span><br><span class="line"></span><br><span class="line">    Student.school = <span class="string">&#x27;东明小学&#x27;</span>  <span class="comment"># 修改类变量</span></span><br><span class="line">    jack.print_school()  <span class="comment"># 东明小学</span></span><br><span class="line">    tom.print_school()  <span class="comment"># 东明小学</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">东方小学</span><br><span class="line">东方小学</span><br><span class="line">东明小学</span><br><span class="line">东明小学</span><br></pre></td></tr></table></figure>

<ul>
<li>实例变量在构造函数 <code>__init__</code> 内部声明，类变量在外部声明。</li>
<li>类内部声明的方法默认为实例方法，使用 <code>@classmethod</code> 声明类方法，第一个参数<code>cls</code> 代表类自己。</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>还有一类方法，既不会访问实例变量和方法，也不会访问类变量和方法，仅仅是一个辅助函数，比如因为某个实例方法实现过长，想把其中的一部分代码抽取出来独立成一个方法，提高代码可读性。而这个辅助函数仅对这个类有用，对其他类没有用。这种情况下，我们通常会将其声明为静态方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(object):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 实例变量</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age  <span class="comment"># 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params"><span class="variable language_">self</span></span>):</span><br><span class="line">        print(<span class="string">&#x27;你好，我是&#123;&#125;，今年&#123;&#125;岁&#x27;</span>.format(<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.age))</span><br><span class="line"></span><br><span class="line">    <span class="variable">@staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">help_func</span>():</span><br><span class="line">        print(<span class="string">&#x27;我是一个静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    jack = Student(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">    Student.help_func()</span><br><span class="line">    jack.help_func()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">我是一个静态方法</span><br><span class="line">我是一个静态方法</span><br></pre></td></tr></table></figure>

<ul>
<li>静态方法使用 <code>@staticmethod</code> 声明，与普通的全局函数没有任何区别，可以通过<code>类.方法</code> 或 <code>实例.方法</code> 的方式使用。与实例方法和类型方法相比，没有 <code>self</code> 或<code>cls</code> 参数。</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(object):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, length, width</span>):</span><br><span class="line">        <span class="variable language_">self</span>.length = length</span><br><span class="line">        <span class="variable language_">self</span>.width = width</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params"><span class="variable language_">self</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.length * <span class="variable language_">self</span>.width</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(Rectangle):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, length</span>):</span><br><span class="line">        <span class="variable language_">super</span>(Square, <span class="variable language_">self</span>).__init__(length, length)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Square(<span class="number">4</span>)</span><br><span class="line">    print(s.area())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Square</code> 继承了 <code>Rectangle</code>，因此拥有了 <code>Rectangle</code> 的所有属性和方法。</li>
<li><code>Square</code> 可以根据需要覆盖父类的方法，在这里 <code>Square</code> 覆盖了父类的构造函数，参数列表从原来的 2 个变为了 1个。</li>
<li>子类可以通过 <code>super(子类名, self).方法</code> 的方式调用父类的方法。</li>
</ul>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记</title>
    <url>/2022/04/23/java/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="基本变量类型"><a href="#基本变量类型" class="headerlink" title="基本变量类型"></a>基本变量类型</h2><p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420180944588.png" alt="image-20220420180944588"></p>
<span id="more"></span>

<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420172046919.png" alt="image-20220420172046919"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果试图给byte类型的变量赋予超出其范围的值，就会产生编译错误</span></span><br><span class="line">        <span class="type">byte</span> b = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浮点型</strong></p>
<p>浮点数类型有两种 float 长度为32位 double 长度为64位 <strong>注意： 默认的小数值是double类型的</strong> 所以 float f &#x3D; 54.321会出现编译错误，因为54.321的默认类型是 double，其类型 长度为64，超过了float的长度32 在数字后面<strong>加一个字母f</strong>，直接把该数字声明成float类型 float f2 &#x3D; 54.321<strong>f</strong>, 这样就不会出错了</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420172350714.png" alt="image-20220420172350714"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> d = <span class="number">123.45</span>;</span><br><span class="line">        <span class="comment">// 该行会出现编译错误，因为54.321是double型的</span></span><br><span class="line">        <span class="type">float</span> f = <span class="number">54.321</span>;</span><br><span class="line">        <span class="type">float</span> f2 = <span class="number">54.321f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整数字面值</strong></p>
<p>当以l或者L结尾的时候，一个整数字面值是long类型，否则就是int类型。 建议使用<strong>大写的L</strong>而非小写的l，因为容易和1混淆。 byte,short,int和long的值都可以通过int类型的字面值来创建。整数的字面值可以用如下四种进制来表示： 十进制: 基 10, 包含从0-9的数字，<strong>平常用的就是这种</strong> 十六进制: 基 16, 包含从0-9的数字，和从A-F的字母。 八进制: 基 8, 包含从0-7的数字 二进制: 基 2, 包含0和1。（从 JAVA7开始就可以创建 二进制的字面值了）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1e4</span>; <span class="comment">// 整数不能用科学计数法</span></span><br><span class="line">        <span class="type">long</span> val = <span class="number">26L</span>; <span class="comment">//以L结尾的字面值表示long型</span></span><br><span class="line">        <span class="type">int</span> decVal = <span class="number">26</span>; <span class="comment">//默认就是int型</span></span><br><span class="line">        <span class="type">int</span> hexVal = <span class="number">0x1a</span>; <span class="comment">//16进制</span></span><br><span class="line">        <span class="type">int</span> oxVal = <span class="number">032</span>; <span class="comment">//8进制</span></span><br><span class="line">        <span class="type">int</span> binVal = <span class="number">0b11010</span>; <span class="comment">//2进制</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(oxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 报错，爆int了</span></span><br><span class="line">        <span class="comment">// long val = 3000000000;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> val = <span class="number">3000000000L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浮点数字面值</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> f1 = <span class="number">3.13F</span>;</span><br><span class="line">        <span class="type">double</span> d1 = <span class="number">123.3</span>;</span><br><span class="line">        <span class="type">double</span> d2 = <span class="number">12.2e5</span>; <span class="comment">// 可以科学计数法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转义字符</strong></p>
<p>需要注意的是，\表示转义，比如需要表示制表符，回车换行，双引号等就需要用 \t \r \n “ 的方式进行</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以下是转义字符</span></span><br><span class="line">        <span class="type">char</span> tab = <span class="string">&#x27;\t&#x27;</span>; <span class="comment">//制表符</span></span><br><span class="line">        <span class="type">char</span> carriageReturn = <span class="string">&#x27;\r&#x27;</span>; <span class="comment">//回车</span></span><br><span class="line">        <span class="type">char</span> newLine = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//换行</span></span><br><span class="line">        <span class="type">char</span> doubleQuote = <span class="string">&#x27;\&quot;&#x27;</span>; <span class="comment">//双引号</span></span><br><span class="line">        <span class="type">char</span> singleQuote = <span class="string">&#x27;\&#x27;&#x27;</span>; <span class="comment">//单引号</span></span><br><span class="line">        <span class="type">char</span> backslash = <span class="string">&#x27;\\&#x27;</span>; <span class="comment">//反斜杠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>转换规则</strong></p>
<p>转换规则如图所示 <strong>精度高</strong>的数据类型就像<strong>容量大</strong>的杯子，可以<strong>放更大</strong>的数据 <strong>精度低</strong>的数据类型就像<strong>容量小</strong>的杯子，只能<strong>放更小</strong>的数据 小杯子往大杯子里倒东西，大杯子<strong>怎么都放得下</strong> 大杯子往小杯子里倒东西，<strong>有的时候放的下</strong>，<strong>有的时候就会有溢出</strong> 需要注意的一点是 虽然short和char都是16位的，长度是一样的 但是彼此之间，依然需要进行强制转换</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420174220863.png" alt="image-20220420174220863"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">short</span> s = <span class="number">80</span>;</span><br><span class="line">        <span class="comment">// 虽然short和char都是16位的，长度是一样的</span></span><br><span class="line">        <span class="comment">// 但是彼此之间，依然需要进行强制转换</span></span><br><span class="line">        c = (<span class="type">char</span>)s;</span><br><span class="line">        System.out.<span class="built_in">println</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>低精度向高精度转换</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">// 自动类型转换</span><br><span class="line">long l <span class="operator">=</span> <span class="number">50</span><span class="comment">;</span></span><br><span class="line">int i <span class="operator">=</span> <span class="number">50</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong>高精度向低精度转换(强转)</strong></p>
<p>把int类型的数据转成为byte类型的数据，<strong>是有风险的</strong> <strong>有的时候是可以转换的</strong>，比如 b &#x3D; i1 (i1&#x3D;10); <strong>有的时候不可以转换</strong> 比如 b&#x3D; i2 (i2&#x3D;300) 因为放不下了 编译器就会提示错误 这个时候就只能采用<strong>强制转换</strong>，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420175035658.png" alt="image-20220420175035658"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">byte</span> b;</span><br><span class="line">        <span class="built_in">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> i2 = <span class="number">300</span>;</span><br><span class="line">        b = (<span class="built_in">byte</span>) i1;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b);</span><br><span class="line">        <span class="comment">// 丢失精度</span></span><br><span class="line">        b = (<span class="built_in">byte</span>) i2;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键字列表</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420175316652.png" alt="image-20220420175316652"></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220420175330218.png" alt="image-20220420175330218"></p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>当一个变量被final修饰的时候，该变量<strong>只有一次赋值的机会</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">// 报错</span><br><span class="line">final int i <span class="operator">=</span> <span class="number">5</span><span class="comment">;</span></span><br><span class="line"><span class="attribute">i</span> <span class="operator">=</span> <span class="number">19</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>final 修饰的变量在方法中，可以先初始化再赋值</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">// 正确</span><br><span class="line">final int i<span class="comment">;</span></span><br><span class="line"><span class="attribute">i</span> <span class="operator">=</span> <span class="number">19</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>但是如果是成员变量，必须在初始化的时赋值，不然会报错</p>
<p><strong>经过测试静态方法不能调用成员变量</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> i; <span class="comment">// 报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final修饰的类不能被继承 </p>
<p>final定义的方法不能被重写 </p>
<p>final定义的常量不能被重写赋值</p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p><strong>异或^：</strong></p>
<p>不同，返回真 相同，返回假</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> b = !(i++ == <span class="number">3</span>) ^ (i++ ==<span class="number">2</span>) &amp;&amp; (i++ == <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(b);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="keyword">false</span></span><br><span class="line">	<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>一个整数的二进制表达：</strong></p>
<p>通过Integer.toBinaryString() 方法，将一个十进制整数转换为一个二进制字符串</p>
<p><strong>位或：</strong></p>
<p>5的二进制是101</p>
<p>6的二进制是110</p>
<p>所以 5|6 对每一位进行或运算，得到 111-&gt;7</p>
<p><strong>位与：</strong></p>
<p>5的二进制是101</p>
<p>6的二进制是110</p>
<p>所以 5&amp;6 对每一位进行与运算，得到 100-&gt;4</p>
<p><strong>异或：</strong></p>
<p>5的二进制是101 6的二进制是110 所以 5^6 对每一位进行异或运算，得到 011-&gt;3</p>
<p>一些特别情况： 任何数和自己进行异或 都等于 0 任何数和0 进行异或 都等于自己</p>
<p><strong>取非~：</strong></p>
<p>5 的二进制是 00000101 所以取反即为 11111010 这个二进制换算成十进制即为-6</p>
<p><strong>左移 右移：</strong></p>
<p>左移：根据一个整数的二进制表达，将其每一位都向左移动，最右边一位补0 右移：根据一个整数的二进制表达，将其每一位都向右移动</p>
<p><strong>使用Scanner读取整数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个整数：&quot;</span>+a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个整数：&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用Scanner读取浮点数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> s.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取的浮点数的值是：&quot;</span>+a);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用Scanner读取字符串：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取的字符串是：&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取了整数后，接着读取字符串：</strong></p>
<p>需要注意的是，如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:”\r\n”,因为nextInt仅仅读取数字信息，而不会<strong>读取</strong>回车换行”\r\n”.</p>
<p>所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取的整数是&quot;</span>+ i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">rn</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取的字符串是：&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch可以使用byte,short,int,char,String,enum</p>
<p><strong>注:</strong> 每个表达式结束，都应该有一个break; <strong>注:</strong> String在Java1.7之前是不支持的, Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数 <strong>注:</strong> enum是枚举类型，在<a href="https://how2j.cn/k/class-object/class-object-enum/678.html">枚举</a>章节有详细讲解</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> day = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;星期111&quot;</span>);</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;都不是&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    星期一</span><br><span class="line">    星期<span class="number">111</span></span><br><span class="line">    星期二</span><br><span class="line">    都不是</span><br></pre></td></tr></table></figure>

<h2 id="使用boolean变量结束外部循环"><a href="#使用boolean变量结束外部循环" class="headerlink" title="使用boolean变量结束外部循环"></a>使用boolean变量结束外部循环</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">boolean</span> breakout = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(i + <span class="string">&quot;:&quot;</span> + j);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == j % <span class="number">2</span>) &#123;</span><br><span class="line">                    breakout = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (breakout) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用标签结束外部循环："><a href="#使用标签结束外部循环：" class="headerlink" title="使用标签结束外部循环："></a>使用标签结束外部循环：</h2><p>在外部循环的前一行，加上标签 在break的时候使用该标签 即能达到结束外部循环的效果</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//打印单数    </span></span><br><span class="line">        outloop: <span class="comment">//outloop这个标示是可以自定义的比如outloop1,ol2,out5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(i+<span class="string">&quot;:&quot;</span>+j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span>==j%<span class="number">2</span>) </span><br><span class="line">                    <span class="keyword">break</span> outloop; <span class="comment">//如果是双数，结束外部循环</span></span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="选择法排序"><a href="#选择法排序" class="headerlink" title="选择法排序"></a>选择法排序</h2><p>选择法排序的思路： <strong>把第一位</strong>和其他所有的进行比较，只要比第一位小的，就换到第一个位置来 比较完后，<strong>第一位就是最小的</strong> 然后再从<strong>第二位</strong>和剩余的其他所有进行比较，只要比第二位小，就换到第二个位置来 比较完后，<strong>第二位就是第二小的</strong> 以此类推</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220107180612236.png" alt="image-20220107180612236"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;&quot;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="keyword">temp</span> = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = <span class="keyword">temp</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡法排序"><a href="#冒泡法排序" class="headerlink" title="冒泡法排序"></a>冒泡法排序</h2><p>冒泡法排序的思路： 第一步：从第一位开始，把相邻两位进行比较 如果发现前面的比后面的大，就把大的数据交换在后面，循环比较完毕后，<strong>最后一位就是最大的</strong> 第二步： 再来一次，只不过不用比较最后一位 以此类推</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220107182324590.png" alt="image-20220107182324590"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;&quot;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="keyword">temp</span> = a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = <span class="keyword">temp</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h2><p>把一个数组的值，复制到另一个数组中</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">System.arraycopy(src, srcP<span class="keyword">os</span>, dest, destP<span class="keyword">os</span>, length)</span><br></pre></td></tr></table></figure>

<p>src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] b = <span class="built_in">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b1 : b) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(b1 + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-工具类"><a href="#Arrays-工具类" class="headerlink" title="Arrays 工具类"></a>Arrays 工具类</h2><p>与使用System.arraycopy进行数组复制类似的， Arrays提供了一个copyOfRange方法进行数组复制。 不同的是System.arraycopy，需要事先准备好目标数组，并分配长度。 copyOfRange 只需要源数组就就可以了，通过返回值，就能够得到目标数组了。 除此之外，需要注意的是 copyOfRange 的<strong>第3个参数</strong>，表示源数组的结束位置，是<strong>取不到的</strong>。</p>
<h3 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        // copyOfRange(<span class="type">int</span>[] original, <span class="type">int</span> <span class="keyword">from</span>, <span class="type">int</span> <span class="keyword">to</span>)</span><br><span class="line">        // 第一个参数表示源数组</span><br><span class="line">        // 第二个参数表示开始位置(取得到)</span><br><span class="line">        // 第三个参数表示结束位置(取不到)</span><br><span class="line">        <span class="type">int</span>[] b = Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b1 : b) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(b1 + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Arrays.toString(a);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Test &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="built_in">int</span><span class="literal">[]</span> a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(a);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>查询元素出现的位置 需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序 如果数组中有多个相同的元素，查找结果是不确定的</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Test &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="built_in">int</span><span class="literal">[]</span> a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(a);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;数字62出现的位置：&quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>binary<span class="constructor">Search(<span class="params">a</span>, 62)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否相同"><a href="#判断是否相同" class="headerlink" title="判断是否相同"></a>判断是否相同</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] b = &#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.equals(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>使用同一个值，填充整个数组</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(a, <span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.<span class="built_in">toString</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习-二维数组排序"><a href="#练习-二维数组排序" class="headerlink" title="练习-二维数组排序"></a>练习-二维数组排序</h3><p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220107191917080.png" alt="image-20220107191917080"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Test &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="built_in">int</span><span class="literal">[]</span><span class="literal">[]</span> a = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">5</span>]</span><span class="literal">[<span class="number">8</span>]</span>;</span><br><span class="line">        <span class="built_in">int</span><span class="literal">[]</span> temp = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                a<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">j</span>]</span> = (<span class="built_in">int</span>)(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span><span class="operator"> * </span><span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>[<span class="params">i</span>])</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(a<span class="literal">[<span class="identifier">i</span>]</span>, <span class="number">0</span>, temp, i<span class="operator"> * </span><span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">temp</span>)</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(temp);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">temp</span>)</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(temp, i<span class="operator"> * </span><span class="number">8</span>, a<span class="literal">[<span class="identifier">i</span>]</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>[<span class="params">i</span>])</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="重载（可变数量的参数）"><a href="#重载（可变数量的参数）" class="headerlink" title="重载（可变数量的参数）"></a>重载（可变数量的参数）</h2><p>如果要攻击更多的英雄，就需要设计更多的方法，这样类会显得很累赘，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero h1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero h1,Hero h2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero h1,Hero h2,Hero h3)</span></span><br></pre></td></tr></table></figure>

<p> 这时，可以采用可变数量的参数 <strong>只需要设计一个方法</strong> public void attack(Hero **…**heros) 即可代表上述所有的方法了 在方法里，使用操作数组的方式处理参数heros即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 进行了一次攻击 ，但是不确定打中谁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变数量的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero... heros)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 攻击了 &quot;</span> + heros[i].name);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ADHero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h1.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h2.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line"></span><br><span class="line">        bh.attack(h1);</span><br><span class="line">        bh.attack(h1, h2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this代表当前对象-打印对象地址"><a href="#this代表当前对象-打印对象地址" class="headerlink" title="this代表当前对象(打印对象地址)"></a>this代表当前对象(打印对象地址)</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;调用Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAddressInMemory</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;打印this看到的虚拟地址：&quot;</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Hero garen =  <span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">        garen.hp = <span class="number">616.28f</span>;</span><br><span class="line">        garen.armor = <span class="number">27.536f</span>;</span><br><span class="line">        garen.moveSpeed = <span class="number">350</span>;</span><br><span class="line">        garen.showAddressInMemory();</span><br><span class="line"></span><br><span class="line">        Hero teemo =  <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">        teemo.hp = <span class="number">383f</span>;</span><br><span class="line">        teemo.armor = <span class="number">14f</span>;</span><br><span class="line">        teemo.moveSpeed = <span class="number">330</span>;</span><br><span class="line">        teemo.showAddressInMemory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过this访问属性"><a href="#通过this访问属性" class="headerlink" title="通过this访问属性"></a>通过this访问属性</h3><p>直接this.属性即可</p>
<h3 id="通过this调用其他的构造方法"><a href="#通过this调用其他的构造方法" class="headerlink" title="通过this调用其他的构造方法"></a>通过this调用其他的构造方法</h3><p>如果要在一个构造方法中，调用另一个构造方法，可以使用this()</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;调用Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;一个参数的构造方法&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>(<span class="params">String name, <span class="built_in">float</span> hp</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;两个参数的构造方法&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAddressInMemory</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;打印this看到的虚拟地址：&quot;</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Hero garen =  <span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">        garen.hp = <span class="number">616.28f</span>;</span><br><span class="line">        garen.armor = <span class="number">27.536f</span>;</span><br><span class="line">        garen.moveSpeed = <span class="number">350</span>;</span><br><span class="line">        garen.showAddressInMemory();</span><br><span class="line">        System.<span class="keyword">out</span>.println(garen.name);</span><br><span class="line"></span><br><span class="line">        Hero teemo =  <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">        teemo.hp = <span class="number">383f</span>;</span><br><span class="line">        teemo.armor = <span class="number">14f</span>;</span><br><span class="line">        teemo.moveSpeed = <span class="number">330</span>;</span><br><span class="line">        teemo.showAddressInMemory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>类和类之间的关系有如下几种: 以Hero为例 <strong>自身：</strong>指的是Hero自己 <strong>同包子类：</strong>ADHero这个类是Hero的子类，并且和Hero处于<strong>同一个包下</strong> <strong>不同包子类：</strong>Support这个类是Hero的子类，但是在<strong>另一个包下</strong> <strong>同包类：</strong> GiantDragon 这个类和Hero是<strong>同一个包</strong>，但是彼此<strong>没有继承关系</strong> <strong>其他类：</strong>Item这个类，<strong>在不同包</strong>，也没有继承关系的类</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220108130736058.png" alt="image-20220108130736058"></p>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p><strong>类属性：</strong> 又叫做静态属性 <strong>对象属性：</strong> 又叫实例属性，非静态属性 如果一个属性声明成类属性，那么所有的对象，都共享这么一个值 给英雄设置一个类属性叫做“版权” (copyright), 无论有多少个具体的英雄，所有的英雄的版权都属于 Riot Games公司。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Hero &#123;</span><br><span class="line">    <span class="built_in">public</span> String <span class="type">name</span>;//实例属性，对象属性，非静态属性</span><br><span class="line">    protected <span class="type">float</span> hp;</span><br><span class="line">    static String copyright;//类属性,静态属性</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Hero garen =  <span class="built_in">new</span> Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line"></span><br><span class="line">        Hero.copyright = &quot;版权由Riot Games公司所有&quot;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(garen.name);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(garen.copyright);</span><br><span class="line"></span><br><span class="line">        Hero teemo =  <span class="built_in">new</span> Hero();</span><br><span class="line">        teemo.name = &quot;提莫&quot;;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(teemo.name);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(teemo.copyright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问类属性有两种方式</strong></p>
<ul>
<li>对象.类属性</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">teemo.<span class="keyword">copyright</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类.类属性</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Hero</span>.</span></span>copyright</span><br></pre></td></tr></table></figure>

<p>这两种方式都可以访问类属性，访问即修改和获取，但是建议使用第二种 <strong>类.类属性</strong> 的方式进行，这样更符合语义上的理解</p>
<p><strong>什么时候使用对象属性，什么时候使用类属性?</strong></p>
<p>如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为它是<strong>跟着对象走的</strong>，每个对象的name都是不同的</p>
<p>如果一个属性，<strong>所有的英雄都共享</strong>，都是一样的，那么就应该设计为类属性。比如血量上限，所有的英雄的血量上限都是 9999，不会因为英雄不同，而取不同的值。 这样的属性，就适合设计为类属性</p>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p><strong>类方法：</strong> 又叫做静态方法</p>
<p><strong>对象方法：</strong> 又叫实例方法，非静态方法</p>
<p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上 访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p>
<h3 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h3><p><strong>类方法：</strong> 又叫做静态方法</p>
<p><strong>对象方法：</strong> 又叫实例方法，非静态方法</p>
<p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上 访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//实例属性，对象属性，非静态属性</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例方法,对象方法，非静态方法</span></span><br><span class="line">    <span class="comment">//必须有对象才能够调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span>()</span> &#123;</span><br><span class="line">        hp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类方法，静态方法</span></span><br><span class="line">    <span class="comment">//通过类就可以直接调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Hero garen =  <span class="keyword">new</span> Hero();</span><br><span class="line">        garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(garen.name);</span><br><span class="line">        garen.die();</span><br><span class="line">        Hero.battleWin();</span><br><span class="line"></span><br><span class="line">        Hero teemo =  <span class="keyword">new</span> Hero();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(teemo.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>和<a href="https://how2j.cn/k/class-object/class-object-class-attribute/296.html#step2259">访问类属性</a>一样，调用类方法也有两种方式</p>
<ol>
<li><p>对象.类方法</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">garen.battleWin()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类.类方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Hero</span>.</span></span>battle<span class="constructor">Win()</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这两种方式都可以调用类方法，但是建议使用第二种 类.类方法 的方式进行，这样更符合语义上的理解。 并且在很多时候，并没有实例，比如在前面练习的时候用到的<a href="https://how2j.cn/k/array/array-create/280.html#step2182">随机数的获取办法</a></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Math.random()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>random()就是一个类方法，直接通过类Math进行调用，并没有一个Math的实例存在。</p>
<h3 id="什么时候设计对象方法，什么时候设计类方法"><a href="#什么时候设计对象方法，什么时候设计类方法" class="headerlink" title="什么时候设计对象方法，什么时候设计类方法"></a>什么时候设计对象方法，什么时候设计类方法</h3><p>如果在某一个方法里，调用了对象属性，比如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>name属性是对象属性，只有存在一个具体对象的时候，name才有意义。 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法</p>
<p>如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法，比如</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGameDuration</span>()</span>&#123;</span><br><span class="line">	System.<span class="keyword">out</span>.println(<span class="string">&quot;已经玩了10分50秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>printGameDuration 打印当前玩了多长时间了，不和某一个具体的英雄关联起来，所有的英雄都是一样的。 这样的方法，更带有<strong>功能性</strong>色彩 就像取随机数一样，random()是一个功能用途的方法</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Math.random()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h2><h3 id="对象属性初始化"><a href="#对象属性初始化" class="headerlink" title="对象属性初始化"></a>对象属性初始化</h3><p>对象属性初始化有3种 \1. 声明该属性的时候初始化 \2. 构造方法中初始化 \3. 初始化块</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name = <span class="string">&quot;some hero&quot;</span>; <span class="comment">//声明该属性的时候初始化</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="type">float</span> maxHP;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        maxHP = <span class="number">200</span>; <span class="comment">//初始化块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span>&#123;</span><br><span class="line">        hp = <span class="number">100</span>; <span class="comment">//构造方法中初始化</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类属性初始化"><a href="#类属性初始化" class="headerlink" title="类属性初始化"></a>类属性初始化</h3><p>类属性初始化有2种 \1. 声明该属性的时候初始化 \2. 静态初始化块</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="type">float</span> maxHP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品栏的容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> itemCapcity = <span class="number">8</span>;<span class="comment">//声明的时候 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> &#123;</span><br><span class="line">        itemCapcity = <span class="number">6</span>;<span class="comment">//静态初始化块 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(Hero.itemCapcity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">6</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name = <span class="string">&quot;some hero&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">&quot;one hero&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;the hero&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> <span class="built_in">Hero</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(h.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">	one hero</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式又叫做 Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在。</p>
<h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>GiantDragon 应该只有一只，通过私有化其构造方法，使得外部无法通过new 得到新的实例。 GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。 这种单例模式又叫做<strong>饿汉式</strong>单例模式，无论如何都会创建一个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GiantDragon</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GiantDragon</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GiantDragon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GiantDragon</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，提供给调用者获取12行定义的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGiantDragon</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过new实例化会报错</span></span><br><span class="line"><span class="comment">//      GiantDragon g = new GiantDragon();</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//只能通过getInstance得到对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">GiantDragon</span> <span class="variable">g1</span> <span class="operator">=</span> GiantDragon.getInstance();</span><br><span class="line">        <span class="type">GiantDragon</span> <span class="variable">g2</span> <span class="operator">=</span> GiantDragon.getInstance();</span><br><span class="line">        <span class="type">GiantDragon</span> <span class="variable">g3</span> <span class="operator">=</span> GiantDragon.getInstance();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//都是同一个对象</span></span><br><span class="line">        System.out.println(g1==g2);</span><br><span class="line">        System.out.println(g1==g3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><p><strong>懒汉式</strong>单例模式与<strong>饿汉式</strong>单例模式不同，只有在调用getInstance的时候，才会创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GiantDragon</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GiantDragon</span><span class="params">()</span>&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//public static 方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span>==instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">GiantDragon</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回 instance指向的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGiantDragon</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过new实例化会报错</span></span><br><span class="line"><span class="comment">//      GiantDragon g = new GiantDragon();</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//只能通过getInstance得到对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">GiantDragon</span> <span class="variable">g1</span> <span class="operator">=</span> GiantDragon.getInstance();</span><br><span class="line">        <span class="type">GiantDragon</span> <span class="variable">g2</span> <span class="operator">=</span> GiantDragon.getInstance();</span><br><span class="line">        <span class="type">GiantDragon</span> <span class="variable">g3</span> <span class="operator">=</span> GiantDragon.getInstance();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//都是同一个对象</span></span><br><span class="line">        System.out.println(g1==g2);</span><br><span class="line">        System.out.println(g1==g3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候使用饿汉式，什么时候使用懒汉式"><a href="#什么时候使用饿汉式，什么时候使用懒汉式" class="headerlink" title="什么时候使用饿汉式，什么时候使用懒汉式"></a>什么时候使用饿汉式，什么时候使用懒汉式</h3><p><strong>饿汉式</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。 如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p>
<p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。 并且有<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全</a>的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。 使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h3 id="单例模式三元素"><a href="#单例模式三元素" class="headerlink" title="单例模式三元素"></a>单例模式三元素</h3><p>这个是面试的时候经常会考的点，面试题通常的问法是: 什么是单例模式？</p>
<p>回答的时候，要答到三元素</p>
<ol>
<li>构造方法私有化</li>
<li>静态属性指向实例</li>
<li>public static的 getInstance方法，返回第二步的静态属性</li>
</ol>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h3 id="预先定义常量"><a href="#预先定义常量" class="headerlink" title="预先定义常量"></a>预先定义常量</h3><p>枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常量 比如设计一个枚举类型 季节，里面有4种常量</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">	SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个常用的场合就是switch语句中，使用枚举来进行判断</p>
<p><strong>注：</strong>因为是常量，所以一般都是全大写</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Season season = Season.SPRING;</span><br><span class="line">        <span class="keyword">switch</span> (season) &#123;</span><br><span class="line">        <span class="keyword">case</span> SPRING:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUMMER:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AUTUMN:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WINTER:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Season &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用枚举的好处"><a href="#使用枚举的好处" class="headerlink" title="使用枚举的好处"></a>使用枚举的好处</h3><p>假设在使用<a href="https://how2j.cn/k/control-flow/control-flow-switch/272.html">switch</a>的时候，不是使用枚举，而是使用int，而int的取值范围就不只是1-4，有可能取一个超出1-4之间的值，这样判断结果就似是而非了。（因为只有4个季节）</p>
<p>但是使用枚举，就能把范围死死的限定在这四个当中</p>
<p>而不会出现奇怪的 <strong>第5季</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> season = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">switch</span> (season) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历枚举"><a href="#遍历枚举" class="headerlink" title="遍历枚举"></a>遍历枚举</h3><p>借助<a href="https://how2j.cn/k/array/array-foreach/330.html#step707">增强型for循环</a>，可以很方便的遍历一个枚举都有哪些常量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Season</span> s : <span class="title class_">Season</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在设计LOL的时候，进攻类英雄有两种，一种是进行物理系攻击，一种是进行魔法系攻击</p>
<p>这时候，就可以使用<strong>接口</strong>来实现这个效果。</p>
<p><strong>接口就像是一种约定</strong>，我们约定某些英雄是物理系英雄，那么他们就一定能够进行物理攻击。</p>
<h3 id="物理攻击接口"><a href="#物理攻击接口" class="headerlink" title="物理攻击接口"></a>物理攻击接口</h3><p>创建一个接口 AD ，声明一个方法 physicAttack 物理攻击，但是没有方法体，是一个“<strong>空</strong>”方法</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AD</span> </span>&#123;</span><br><span class="line">        <span class="comment">//物理伤害</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计一类英雄，能够使用物理攻击"><a href="#设计一类英雄，能够使用物理攻击" class="headerlink" title="设计一类英雄，能够使用物理攻击"></a>设计一类英雄，能够使用物理攻击</h3><p>设计一类英雄，能够使用物理攻击，这类英雄在LOL中被叫做AD 类：ADHero 继承了Hero 类，所以继承了name,hp,armor等属性</p>
<p><strong>实现某个接口，就相当于承诺了某种约定</strong></p>
<p>所以，<strong>实现</strong>了<strong>AD</strong>这个接口，就<strong>必须</strong>提供AD接口中声明的方法<strong>physicAttack()</strong> <strong>实现</strong>在语法上使用关键字 <strong>implements</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="title">implements</span> <span class="title">AD</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="魔法攻击接口"><a href="#魔法攻击接口" class="headerlink" title="魔法攻击接口"></a>魔法攻击接口</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AP</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">magicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计一类英雄，只能使用魔法攻击"><a href="#设计一类英雄，只能使用魔法攻击" class="headerlink" title="设计一类英雄，只能使用魔法攻击"></a>设计一类英雄，只能使用魔法攻击</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">APHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="title">implements</span> <span class="title">AP</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;进行魔法攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计一类英雄，既能进行物理攻击，又能进行魔法攻击"><a href="#设计一类英雄，既能进行物理攻击，又能进行魔法攻击" class="headerlink" title="设计一类英雄，既能进行物理攻击，又能进行魔法攻击"></a>设计一类英雄，既能进行物理攻击，又能进行魔法攻击</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//同时能进行物理和魔法伤害的英雄</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ADAPHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="title">implements</span> <span class="title">AD</span>,<span class="title">AP</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void magicAttack() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;进行魔法攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么样的情况下该使用接口"><a href="#什么样的情况下该使用接口" class="headerlink" title="什么样的情况下该使用接口?"></a>什么样的情况下该使用接口?</h3><p>如上的例子，似乎要接口，不要接口，都一样的，那么接口的意义是什么呢</p>
<p>学习一个知识点，是由浅入深得进行的。 这里呢，只是引入了接口的概念，要真正理解接口的好处，需要更多的实践，以及在较为复杂的系统中进行大量运用之后，才能够真正理解，比如在学习了<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-polymorphic/315.html">多态</a>之后就能进一步加深理解。</p>
<p>刚刚接触一个概念，就希望达到炉火纯青的学习效果，这样的学习目标是不科学的。</p>
<h2 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h2><h3 id="明确引用类型与对象类型的概念"><a href="#明确引用类型与对象类型的概念" class="headerlink" title="明确引用类型与对象类型的概念"></a>明确引用类型与对象类型的概念</h3><p>首先，明确引用类型与对象类型的概念 在这个例子里，有一个对象 new ADHero(), 同时也有一个引用ad 对象是有类型的， 是ADHero 引用也是有类型的，是ADHero 通常情况下，引用类型和对象类型是一样的 接下来要讨论的类型转换的问题，指的是<strong>引用类型和对象类型</strong>不一致的情况下的转换问题</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="built_in">ADHero</span>();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类转父类-向上转型"><a href="#子类转父类-向上转型" class="headerlink" title="子类转父类(向上转型)"></a>子类转父类(向上转型)</h3><p>所谓的转型，是指当<strong>引用类型</strong>和<strong>对象类型</strong>不一致的时候，才需要进行类型转换 类型转换有时候会成功，有时候会失败(参考<a href="https://how2j.cn/k/variable/variable-transfer/264.html">基本类型的类型转换</a>)</p>
<p>到底能否转换成功？ 教大家一个很简单的判别办法 <strong>把右边的当做左边来用</strong>，看说得通不</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Hero h <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">ADHero ad <span class="operator">=</span> new ADHero()<span class="comment">;</span></span><br><span class="line"><span class="attribute">h</span> <span class="operator">=</span> ad<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>右边ad<strong>引用所指向的对象的类型</strong>是 物理攻击英雄 左边h<strong>引用的类型</strong>是 普通英雄 把物理攻击英雄 当做 普通英雄，说不说得通？ 说得通，就可以转</p>
<p>所有的<strong>子类转换为父类</strong>，都是说得通的。比如你身边的例子</p>
<p>苹果手机 继承了 手机，把苹果手机当做普通手机使用 怡宝纯净水 继承了 饮品， 把怡宝纯净水 当做饮品来使用</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> <span class="built_in">Hero</span>();</span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="built_in">ADHero</span>();</span><br><span class="line">        <span class="comment">//类型转换指的是把一个引用所指向的对象的类型，转换为另一个引用的类型</span></span><br><span class="line">        <span class="comment">//把ad引用所指向的对象的类型是ADHero</span></span><br><span class="line">        <span class="comment">//h引用的类型是Hero</span></span><br><span class="line">        <span class="comment">//把ADHero当做Hero使用，一定可以</span></span><br><span class="line">        h = ad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="父类转子类-向下转型"><a href="#父类转子类-向下转型" class="headerlink" title="父类转子类(向下转型)"></a>父类转子类(向下转型)</h3><p>父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。 强制转换的意思就是 转换有风险，风险自担。</p>
<p><strong>什么时候行呢？</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> <span class="built_in">Hero</span>();</span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="built_in">ADHero</span>();</span><br><span class="line">        h = ad;</span><br><span class="line">        ad = (ADHero)h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行，是子类转父类，一定可以的 第4行，就是父类转子类，所以要进行强转。 h这个引用，所指向的对象是ADHero, 所以第4行，就会把ADHero转换为ADHero，就能转换成功。</p>
<p><strong>什么时候转换不行呢？</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> <span class="type">Hero</span>();</span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="type">ADHero</span>();</span><br><span class="line">        Support s = <span class="keyword">new</span> <span class="type">Support</span>();</span><br><span class="line">        h = s;</span><br><span class="line">        ad = (ADHero)h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Support</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Hero</span></span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行，是子类转父类，是可以转换成功的 第5行，是把h引用所指向的对象 Support，转换为ad引用的类型ADHero。 从语义上讲，把物理攻击英雄，当成辅助英雄来用，说不通，所以会强制转换失败，并且抛出<a href="https://how2j.cn/k/exception/exception-tutorial/332.html">异常</a></p>
<p><strong>以下是对完整的代码的关键行分析</strong> 14行： 把ad当做Hero使用，一定可以 转换之后，h引用指向一个ad对象 15行： h引用有可能指向一个ad对象，也有可能指向一个support对象 所以把h引用转换成AD类型的时候，就有可能成功，有可能失败 因此要进行强制转换，换句话说转换后果自负 到底能不能转换成功，要看引用<strong>h到底指向的是哪种对象</strong> 在这个例子里，h指向的是一个ad对象，所以转换成ADHero类型，是可以的 16行：把一个support对象当做Hero使用，一定可以 转换之后，h引用指向一个support对象 17行：这个时候，h指向的是一个support对象，所以转换成ADHero类型，会失败。 失败的表现形式是抛出异常 ClassCastException 类型转换异常</p>
<h3 id="没有继承关系的两个类，互相转换"><a href="#没有继承关系的两个类，互相转换" class="headerlink" title="没有继承关系的两个类，互相转换"></a>没有继承关系的两个类，互相转换</h3><p>没有继承关系的两个类，互相转换，一定会失败 虽然ADHero和APHero都继承了Hero，但是彼此没有互相继承关系 “<strong>把魔法英雄当做物理英雄来用</strong>“,在语义上也是说不通的</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="built_in">ADHero</span>();</span><br><span class="line">        APHero ap = <span class="keyword">new</span> <span class="built_in">APHero</span>();</span><br><span class="line">        <span class="comment">// 没有继承关系的类型进行互相转换一定会失败，所以会出现编译错误</span></span><br><span class="line">        ad = (ADHero)ap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现类转换成接口-向上转型"><a href="#实现类转换成接口-向上转型" class="headerlink" title="实现类转换成接口(向上转型)"></a>实现类转换成接口(向上转型)</h3><p>引用ad指向的对象是ADHero类型，这个类型实现了AD接口 10行： 把一个ADHero类型转换为AD接口 从语义上来讲，把一个ADHero当做AD来使用，而AD接口只有一个physicAttack方法，这就意味着转换后就有可能要调用physicAttack方法，而ADHero一定是有physicAttack方法的，所以转换是能成功的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="built_in">ADHero</span>();</span><br><span class="line">        AD adi = ad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口转换成实现类-向下转型"><a href="#接口转换成实现类-向下转型" class="headerlink" title="接口转换成实现类(向下转型)"></a>接口转换成实现类(向下转型)</h3><p>10行： ad引用指向ADHero， 而adi引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功 12行: adi实际上是指向一个ADHero的，所以能够转换成功 14行： adi引用所指向的对象是一个ADHero，要转换为ADAPHero就会失败。</p>
<p><strong>假设能够转换成功</strong>，那么就可以使用<strong>magicAttack</strong>方法，而adi引用所指向的对象*<em>ADHero*<em><strong>是</strong></em></em>没有magicAttack**方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ADHero</span> <span class="variable">ad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">        <span class="type">AD</span> <span class="variable">adi</span> <span class="operator">=</span> ad;</span><br><span class="line">        <span class="type">ADHero</span> <span class="variable">adHero</span> <span class="operator">=</span> (ADHero)adi;</span><br><span class="line">        <span class="comment">//ADAPHero adapHero = (ADHero)adi;报错</span></span><br><span class="line">        <span class="comment">//adapHero.magicAttack();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>子类可以继承父类的对象方法</p>
<p>在继承后，重复提供该方法，就叫做方法的重写</p>
<p>又叫覆盖 override</p>
<h3 id="父类Item"><a href="#父类Item" class="headerlink" title="父类Item"></a>父类Item</h3><p>父类Item有一个方法，叫做effect</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Item</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;物品使用后，可以有效果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类LifePotion"><a href="#子类LifePotion" class="headerlink" title="子类LifePotion"></a>子类LifePotion</h3><p>子类LifePotion继承Item,同时也提供了方法effect</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LifePotion</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    public void effect() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;血瓶使用后，可以回血&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用重写的方法"><a href="#调用重写的方法" class="headerlink" title="调用重写的方法"></a>调用重写的方法</h3><p>调用重写的方法 调用就会执行重写的方法，而不是从父类的方法 所以LifePotion的effect会打印： “血瓶使用后，可以回血”</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="title class_">String</span> name;</span><br><span class="line">    int price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;物品使用后，可以有效果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Item</span> i = <span class="keyword">new</span> <span class="title class_">Item</span>();</span><br><span class="line">        i.<span class="title function_">effect</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title class_">LifePotion</span> lp = <span class="keyword">new</span> <span class="title class_">LifePotion</span>();</span><br><span class="line">        lp.<span class="title function_">effect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">	物品使用后，可以有效果</span><br><span class="line">血瓶使用后，可以回血</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>操作符的多态 + 可以作为算数运算，也可以作为字符串连接</p>
<p>类的多态 父类引用指向子类对象</p>
<h3 id="操作符的多态"><a href="#操作符的多态" class="headerlink" title="操作符的多态"></a>操作符的多态</h3><p>同一个操作符在不同情境下，具备不同的作用 如果+号两侧都是整型，那么**+代表 数字相加** 如果+号两侧，任意一个是字符串，那么**+代表字符串连接**</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> k = i+j; <span class="comment">//如果+号两侧都是整型，那么+代表 数字相加</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(k);</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="type">String</span> b = <span class="string">&quot;5&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> c = a+b; <span class="comment">//如果+号两侧，任意一个是字符串，那么+代表字符串连接</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(c);</span><br><span class="line">         </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察类的多态现象"><a href="#观察类的多态现象" class="headerlink" title="观察类的多态现象"></a>观察类的多态现象</h3><p>观察类的多态现象： \1. i1和i2都是Item类型 \2. 都调用effect方法 \3. 输出不同的结果</p>
<p>多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Item</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;物品使用后，可以有效果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Item i1 = <span class="keyword">new</span> LifePotion();</span><br><span class="line">        Item i2 = <span class="keyword">new</span> MagicPotion();</span><br><span class="line">        i1.effect();</span><br><span class="line">        i2.effect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MagicPotion</span> <span class="title">extends</span> <span class="title">Item</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;蓝瓶使用后，可以回魔法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LifePotion</span> <span class="title">extends</span> <span class="title">Item</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;血瓶使用后，可以回血&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的多态条件"><a href="#类的多态条件" class="headerlink" title="类的多态条件"></a>类的多态条件</h3><p>要实现类的多态，需要如下条件 \1. 父类（接口）引用指向子类对象 \2. 调用的方法有<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-override/309.html">重写</a> 那么多态有什么作用呢？ 通过比较<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-polymorphic/315.html#step643">不使用多态</a>与<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-polymorphic/315.html#step645">使用多态</a>来进一步了解</p>
<p><strong>如果不使用多态</strong>， 假设英雄要使用血瓶和魔瓶，就需要为Hero设计两个方法 useLifePotion useMagicPotion</p>
<p>除了血瓶和魔瓶还有很多种物品，那么就需要设计很多很多个方法，比如 usePurityPotion 净化药水 useGuard 守卫 useInvisiblePotion 使用隐形药水 等等等等</p>
<p>如果物品的种类特别多，那么就需要设计很多的方法 比如useArmor,useWeapon等等</p>
<p><strong>这个时候采用多态来解决这个问题</strong> 设计一个方法叫做useItem，其参数类型是Item 如果是使用血瓶，调用该方法 如果是使用魔瓶，还是调用该方法 无论英雄要使用什么样的物品，<strong>只需要一个方法</strong>即可</p>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>与重写类似，方法的<strong>重写是</strong>子类覆盖父类的<strong>对象方法</strong></p>
<p><strong>隐藏</strong>，就是子类覆盖父类的<strong>类方法</strong></p>
<h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><p>父类有一个类方法 ：battleWin</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hp;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//类方法，静态方法</span></span><br><span class="line">    <span class="comment">//通过类就可以直接调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;hero battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类隐藏父类的类方法"><a href="#子类隐藏父类的类方法" class="headerlink" title="子类隐藏父类的类方法"></a>子类隐藏父类的类方法</h3><p>子类隐藏父类的类方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Hero</span> <span class="keyword">implements</span> <span class="variable constant_">AD</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">physicAttack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐藏父类的battleWin方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">battleWin</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;ad hero battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Hero</span>.<span class="title function_">battleWin</span>();</span><br><span class="line">        <span class="title class_">ADHero</span>.<span class="title function_">battleWin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h3 id="准备一个显式提供无参构造方法的父类"><a href="#准备一个显式提供无参构造方法的父类" class="headerlink" title="准备一个显式提供无参构造方法的父类"></a>准备一个显式提供无参构造方法的父类</h3><p>准备显式提供无参构造方法的父类 在实例化Hero对象的时候，其构造方法会打印 “Hero的构造方法 “</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useItem</span>(<span class="params">Item i</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;hero use item&quot;</span>);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例化子类，父类的构造方法一定会被调用"><a href="#实例化子类，父类的构造方法一定会被调用" class="headerlink" title="实例化子类，父类的构造方法一定会被调用"></a>实例化子类，父类的构造方法一定会被调用</h3><p>实例化一个ADHero(), 其构造方法会被调用 其<strong>父类的构造方法也会被调用</strong> 并且是父类构造方法<strong>先调用</strong> 子类构造方法会默认调用父类的 无参的构造方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ADHero</span> <span class="title">extends</span> <span class="title">Hero</span> <span class="title">implements</span> <span class="title">AD</span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ADHero</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;AD Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ADHero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="父类显式提供两个构造方法"><a href="#父类显式提供两个构造方法" class="headerlink" title="父类显式提供两个构造方法"></a>父类显式提供两个构造方法</h3><p>分别是无参的构造方法和带一个参数的构造方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useItem</span>(<span class="params">Item i</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;hero use item&quot;</span>);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Hero的有一个参数的构造方法&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类显式调用父类带参构造方法"><a href="#子类显式调用父类带参构造方法" class="headerlink" title="子类显式调用父类带参构造方法"></a>子类显式调用父类带参构造方法</h3><p>使用关键字<strong>super</strong> 显式调用父类带参的构造方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ADHero</span> <span class="title">extends</span> <span class="title">Hero</span> <span class="title">implements</span> <span class="title">AD</span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ADHero</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;AD Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ADHero</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;AD Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ADHero(<span class="string">&quot;德莱文&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用父类属性"><a href="#调用父类属性" class="headerlink" title="调用父类属性"></a>调用父类属性</h3><p>通过super调用父类的moveSpeed属性 ADHero也提供了属性moveSpeed</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ADHero</span> <span class="title">extends</span> <span class="title">Hero</span> <span class="title">implements</span> <span class="title">AD</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> moveSpeed = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getMoveSpeed</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getMoveSpeed2</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> super.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ADHero h = <span class="keyword">new</span> ADHero();</span><br><span class="line">        System.<span class="keyword">out</span>.println(h.getMoveSpeed());</span><br><span class="line">        System.<span class="keyword">out</span>.println(h.getMoveSpeed2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">	Hero的构造方法</span><br><span class="line">    <span class="number">400</span></span><br><span class="line">    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h3><p>ADHero重写了useItem方法，并且在useItem中<strong>通过super调用父类的useItem方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">moveSpeed</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">physicAttack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoveSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoveSpeed2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写useItem，并在其中调用父类的userItem方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useItem</span><span class="params">(Item i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adhero use item&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.useItem(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ADHero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">        <span class="type">LifePotion</span> <span class="variable">lp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifePotion</span>();</span><br><span class="line">        h.useItem(lp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">	Hero的构造方法</span><br><span class="line">    adhero use item</span><br><span class="line">    hero use item</span><br><span class="line">    血瓶使用后，可以回血</span><br></pre></td></tr></table></figure>

<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的父类</p>
<h3 id="Object类是所有类的父类"><a href="#Object类是所有类的父类" class="headerlink" title="Object类是所有类的父类"></a>Object类是所有类的父类</h3><p>声明一个类的时候，默认是继承了Object public class Hero <strong>extends Object</strong></p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>Object类提供一个toString方法，所以所有的类都有toString方法 toString()的意思是返回当前对象的<strong>字符串表达</strong> 通过 System.out.println 打印对象就是打印该对象的toString()返回值</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Hero &#123;</span><br><span class="line">    String <span class="type">name</span>;</span><br><span class="line">    <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Hero h = <span class="built_in">new</span> Hero();</span><br><span class="line">        h.name = &quot;盖伦&quot;;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(h.toString());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    盖伦</span><br><span class="line">    盖伦</span><br></pre></td></tr></table></figure>

<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件</p>
<p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p>
<p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="type">String</span> name;</span><br><span class="line">    <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;这个英雄正在被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一引用</span></span><br><span class="line">        Hero h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//不断生成新的对象</span></span><br><span class="line">            <span class="comment">//每创建一个对象，前一个对象，就没有引用指向了</span></span><br><span class="line">            <span class="comment">//那些对象，就满足垃圾回收的条件</span></span><br><span class="line">            <span class="comment">//当，垃圾堆积的比较多的时候，就会触发垃圾回收</span></span><br><span class="line">            <span class="comment">//一旦这个对象被回收，它的finalize()方法就会被调用</span></span><br><span class="line">            h = <span class="keyword">new</span> <span class="built_in">Hero</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    这个英雄正在被回收</span><br><span class="line">    这个英雄正在被回收</span><br><span class="line">    这个英雄正在被回收</span><br><span class="line">    这个英雄正在被回收</span><br><span class="line">    这个英雄正在被回收</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>equals() 用于判断两个对象的内容是否相同</p>
<p>假设，当两个英雄的hp相同的时候，我们就认为这两个英雄相同</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">    String name<span class="comment">;</span></span><br><span class="line">    float hp<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o instanceof Hero) &#123;</span><br><span class="line">            Hero h <span class="operator">=</span> (Hero)o<span class="comment">;</span></span><br><span class="line">            return this.hp <span class="operator">=</span><span class="operator">=</span> h.hp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        return false<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1 <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">        h1.hp <span class="operator">=</span> <span class="number">300</span><span class="comment">;</span></span><br><span class="line">        Hero h2 <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">        h2.hp <span class="operator">=</span> <span class="number">400</span><span class="comment">;</span></span><br><span class="line">        Hero h3 <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">        h3.hp <span class="operator">=</span> <span class="number">500</span><span class="comment">;</span></span><br><span class="line">        System.out.println(h1.equals(h2))<span class="comment">;</span></span><br><span class="line">        System.out.println(h1.equals(h3))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h3><p>这不是Object的方法，但是用于判断两个对象是否相同 <strong>更准确的讲</strong>，用于判断两个引用，是否指向了同一个对象</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">public class Hero &#123;</span><br><span class="line">    String name<span class="comment">;</span></span><br><span class="line">    float hp<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o instanceof Hero) &#123;</span><br><span class="line">            Hero h <span class="operator">=</span> (Hero)o<span class="comment">;</span></span><br><span class="line">            return this.hp <span class="operator">=</span><span class="operator">=</span> h.hp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        return false<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1 <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">        h1.hp <span class="operator">=</span> <span class="number">300</span><span class="comment">;</span></span><br><span class="line">        Hero h2 <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">        h2.hp <span class="operator">=</span> <span class="number">400</span><span class="comment">;</span></span><br><span class="line">        Hero h3 <span class="operator">=</span> new Hero()<span class="comment">;</span></span><br><span class="line">        h3.hp <span class="operator">=</span> <span class="number">500</span><span class="comment">;</span></span><br><span class="line">        System.out.println(h1 <span class="operator">=</span><span class="operator">=</span> h2)<span class="comment">;</span></span><br><span class="line">        System.out.println(h1 <span class="operator">=</span><span class="operator">=</span> h3)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode方法返回一个对象的哈希值，但是在了解哈希值的意义之前，讲解这个方法没有意义。</p>
<p>hashCode的意义，将放在<a href="https://how2j.cn/k/collection/collection-hashcode/371.html">hashcode 原理</a>章节讲解</p>
<h3 id="线程同步相关方法"><a href="#线程同步相关方法" class="headerlink" title="线程同步相关方法"></a>线程同步相关方法</h3><p>Object还提供线程同步相关方法 wait() notify() notifyAll() 这部分内容的理解需要建立在对线程安全有足够的理解的基础之上，所以会放在<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html">线程交互</a> 的章节讲解</p>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>getClass()会返回一个对象的<a href="https://how2j.cn/k/reflection/reflection-class/108.html">类对象</a>，属于高级内容，不适合初学者过早接触，关于类对象的详细内容请参考<a href="https://how2j.cn/k/reflection/reflection-reflection/107.html">反射机制</a></p>
<h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><p>final修饰类，方法，基本类型变量，引用的时候分别有不同的意思。</p>
<h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><p>当Hero被修饰成final的时候，表示Hero不能够被继承 其子类会出现编译错误</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">String</span> name; <span class="comment">//姓名</span></span><br><span class="line">        </span><br><span class="line">    float hp; <span class="comment">//血量</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>Hero的useItem方法被修饰成final,那么该方法在ADHero中，不能够被重写</p>
<h3 id="final修饰基本类型变量"><a href="#final修饰基本类型变量" class="headerlink" title="final修饰基本类型变量"></a>final修饰基本类型变量</h3><p>final修饰基本类型变量，表示该变量只有一次赋值机会 16行进行了赋值，17行就不可以再进行赋值了</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> extends Object &#123;</span><br><span class="line">    <span class="type">String</span> name; <span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hp;</span><br><span class="line">        hp = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//hp = 6;报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final修饰引用"><a href="#final修饰引用" class="headerlink" title="final修饰引用"></a>final修饰引用</h3><p>final修饰引用 h引用被修饰成final，表示该引用只有<strong>1</strong>次指向对象的机会 所以17行会出现编译错误 但是，依然通过h引用修改对象的属性值hp，因为hp并没有final修饰</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> h;</span><br><span class="line">        h = <span class="keyword">new</span> <span class="type">Hero</span>();</span><br><span class="line">        <span class="comment">//h = new Hero();报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量指的是可以公开，直接访问，不会变化的值 比如 itemTotalNumber 物品栏的数量是6个</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public static <span class="keyword">final</span> int <span class="type">ITEMTOTALNUMBER</span> = <span class="number">6</span>;</span><br><span class="line">    float hp;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> h;</span><br><span class="line">        h = <span class="keyword">new</span> <span class="type">Hero</span>();</span><br><span class="line">        h.hp = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</p>
<p>这样的方法就叫抽象方法，使用修饰符“abstract”</p>
<p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p>
<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>为Hero增加一个<strong>抽象方法 attack</strong>，并且把Hero声明为abstract的。 APHero,ADHero,ADAPHero是Hero的子类，继承了Hero的属性和方法。 但是各自的攻击手段是不一样的，所以继承Hero类后，这些<strong>子类就必须提供</strong>不一样的attack方法实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="title class_">String</span> name;</span><br><span class="line"></span><br><span class="line">    float hp;</span><br><span class="line"></span><br><span class="line">    float armor;</span><br><span class="line"></span><br><span class="line">    int moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法attack</span></span><br><span class="line">    <span class="comment">// Hero的子类会被要求实现attack方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">attack</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Hero</span> <span class="keyword">implements</span> <span class="variable constant_">AD</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">physicAttack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">attack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">physicAttack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APHero</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Hero</span> <span class="keyword">implements</span> <span class="variable constant_">AP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">magicAttack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进行魔法攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">attack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">magicAttack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADAPHero</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Hero</span> <span class="keyword">implements</span> <span class="variable constant_">AD</span>, <span class="variable constant_">AP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">attack</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;既可以进行物理攻击，也可以进行魔法攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">physicAttack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">magicAttack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进行魔法攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类可以没有抽象方法"><a href="#抽象类可以没有抽象方法" class="headerlink" title="抽象类可以没有抽象方法"></a>抽象类可以没有抽象方法</h3><p>Hero类可以在不提供抽象方法的前提下，声明为抽象类 一旦一个类被声明为抽象类，就不能够被直接实例化</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//Hero h = new Hero();报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p><strong>区别1：</strong></p>
<ul>
<li>子类只能继承一个抽象类，不能继承多个</li>
<li>子类可以实现<strong>多个</strong>接口</li>
</ul>
<p><strong>区别2：</strong></p>
<ul>
<li>抽象类可以定义 public,protected,package,private</li>
<li>静态和非静态属性 final和非final属性</li>
<li>但是接口中声明的属性，只能是 public 静态 final的</li>
<li>即便没有显式的声明</li>
</ul>
<p>注: 抽象类和接口都可以有实体方法。 接口中的实体方法，叫做<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-default-method/676.html">默认方法</a></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> resistPhysic = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//resistMagic即便没有显式的声明为 public static final</span></span><br><span class="line">    <span class="comment">//但依然默认为public static final</span></span><br><span class="line">    <span class="keyword">int</span> resistMagic = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">magicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>非静态内部类 BattleScore “战斗成绩” 非静态内部类可以直接在一个类里面定义</p>
<p>比如： 战斗成绩只有在一个英雄对象存在的时候才有意义 所以实例化BattleScore 的时候，必须建立在一个存在的英雄的基础上 语法: <strong>new 外部类().new 内部类()</strong> 作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span></span><br><span class="line">    <span class="comment">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">BattleScore</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> kill;</span><br><span class="line">        <span class="built_in">int</span> die;</span><br><span class="line">        <span class="built_in">int</span> assit;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">legendary</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kill &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(name + <span class="string">&quot;超神！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(name + <span class="string">&quot;尚未超神！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Hero garen = <span class="keyword">new</span> Hero();</span><br><span class="line">        garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化内部类</span></span><br><span class="line">        <span class="comment">// BattleScore对象只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">        <span class="comment">// 所以其实例化必须建立在一个外部类对象的基础之上</span></span><br><span class="line">        BattleScore score = garen.<span class="function"><span class="keyword">new</span> <span class="title">BattleScore</span>()</span>;</span><br><span class="line">        score.kill = <span class="number">9</span>;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    盖伦超神！</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>在一个类里面声明一个静态内部类 比如敌方水晶，当敌方水晶没有血的时候，己方所有英雄都取得胜利，而不只是某一个具体的英雄取得胜利。 与非静态内部类不同，<strong>静态内部类</strong>水晶类的实例化 <strong>不需要一个外部类的实例为基础</strong>，可以直接实例化 语法：<strong>new 外部类.静态内部类();</strong> 因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong> 除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌方的水晶</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnemyCrystal</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> hp = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果水晶的血量为0，则宣布胜利</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkIfVictory</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hp == <span class="number">0</span>) &#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//静态内部类不能直接访问外部类的对象属性</span></span><br><span class="line">                <span class="comment">//可以访问外部类的私有静态成员</span></span><br><span class="line">                <span class="comment">//静态方法 不能访问这个类中的普通属性 ，因为那些属性属于一个对象，但可以访问静态属性</span></span><br><span class="line">                <span class="comment">//System.out.println(name + &quot; win this game&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化静态内部类</span></span><br><span class="line">        Hero.EnemyCrystal crystal = <span class="keyword">new</span> Hero.EnemyCrystal();</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练 通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</p>
<p>有的时候，为了快速使用，直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。 既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。 这样的类，叫做匿名类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ADHero adh = <span class="keyword">new</span> ADHero();</span><br><span class="line">        adh.attack();<span class="comment">//进行物理攻击</span></span><br><span class="line">        <span class="comment">//通过打印adh，可以看到adh这个对象属于ADHero类</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(adh);<span class="comment">//ADHero@1b6d3586</span></span><br><span class="line"></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero() &#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span>()</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();<span class="comment">//新的进攻手段</span></span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(h);<span class="comment">//Hero$1@4554617c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="本地类"><a href="#本地类" class="headerlink" title="本地类"></a>本地类</h3><p>本地类可以理解为有名字的匿名类 内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。 本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="built_in">float</span> armor;</span><br><span class="line">    <span class="built_in">int</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//与匿名类的区别在于，本地类有了自定义的类名</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title">SomeHero</span> <span class="title">extends</span> <span class="title">Hero</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span>()</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(name+ <span class="string">&quot; 新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SomeHero h = <span class="keyword">new</span> SomeHero();</span><br><span class="line">        h.name = <span class="string">&quot;地卜师&quot;</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    地卜师 新的进攻手段</span><br></pre></td></tr></table></figure>

<h3 id="在匿名类中使用外部的局部变量"><a href="#在匿名类中使用外部的局部变量" class="headerlink" title="在匿名类中使用外部的局部变量"></a>在匿名类中使用外部的局部变量</h3><p>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</p>
<p>为什么要声明为final，其机制比较复杂，请参考第二个Hero代码中的解释</p>
<p><strong>注：</strong>在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器<strong>偷偷的</strong>帮你加上了看不见的final</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</span></span><br><span class="line">        final <span class="built_in">int</span> damage = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span>()</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.printf(<span class="string">&quot;新的进攻手段，造成%d点伤害&quot;</span>, damage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    新的进攻手段，造成<span class="number">5</span>点伤害</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span>()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在匿名类中使用外部的局部变量damage 必须修饰为final</span></span><br><span class="line">        <span class="built_in">int</span> damage = <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//这里使用本地类AnonymousHero来模拟匿名类的隐藏属性机制</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//事实上的匿名类，会在匿名类里声明一个damage属性，并且使用构造方法初始化该属性的值</span></span><br><span class="line">        <span class="comment">//在attack中使用的damage，真正使用的是这个内部damage，而非外部damage</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//假设外部属性不需要声明为final</span></span><br><span class="line">        <span class="comment">//那么在attack中修改damage的值，就会被暗示为修改了外部变量damage的值</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//但是他们俩是不同的变量，是不可能修改外部变量damage的</span></span><br><span class="line">        <span class="comment">//所以为了避免产生误导，外部的damage必须声明为final,&quot;看上去&quot;就不能修改了</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title">AnonymousHero</span> <span class="title">extends</span> <span class="title">Hero</span>&#123;</span><br><span class="line">            <span class="built_in">int</span> damage;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">AnonymousHero</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.damage = damage;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span>()</span> &#123;</span><br><span class="line">                damage = <span class="number">10</span>;</span><br><span class="line">                System.<span class="keyword">out</span>.printf(<span class="string">&quot;新的进攻手段，造成%d点伤害&quot;</span>,<span class="keyword">this</span>.damage );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Hero h = <span class="keyword">new</span> AnonymousHero(damage);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><h3 id="什么是默认方法"><a href="#什么是默认方法" class="headerlink" title="什么是默认方法"></a>什么是默认方法</h3><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p>
<p>Mortal 这个接口，增加了一个<strong>默认方法</strong> revive，这个方法有实现体，并且被声明为了<strong>default</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Mortal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">die</span>()</span>;</span><br><span class="line">    <span class="function"><span class="literal">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么会有默认方法"><a href="#为什么会有默认方法" class="headerlink" title="为什么会有默认方法"></a>为什么会有默认方法</h3><p><strong>default的中文意思就是“默认”</strong></p>
<p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p>
<h1 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h1><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><h3 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h3><p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong> 比如int对应的类是Integer 这种类就叫做封装类</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//把一个基本类型的变量,转换为Integer对象</span></span><br><span class="line">        Integer it = <span class="keyword">new</span> <span class="built_in">Integer</span>(i);</span><br><span class="line">        <span class="comment">//把一个Integer对象，转换为一个基本类型的int</span></span><br><span class="line">        <span class="type">int</span> i2 = it.<span class="built_in">intValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h3><p>数字封装类有 Byte,Short,Integer,Long,Float,Double 这些类都是抽象类Number的子类</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220109230821025.png" alt="image-20220109230821025"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestNumber &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="type">Integer</span> it = <span class="built_in">new</span> <span class="type">Integer</span>(i);</span><br><span class="line">        //<span class="type">Integer</span>是Number的子类，所以打印<span class="keyword">true</span></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(it instanceof Number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动装箱-x2F-拆箱"><a href="#自动装箱-x2F-拆箱" class="headerlink" title="自动装箱&#x2F;拆箱"></a>自动装箱&#x2F;拆箱</h3><p>不需要调用构造方法，<strong>通过&#x3D;符号自动</strong>把 基本类型 转换为 类类型 就叫装箱</p>
<p>不需要调用Integer的intValue方法，通过&#x3D;就自动转换成int类型，就叫拆箱</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">        Integer it = i;</span><br><span class="line">        <span class="type">int</span> i2 = it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int的最大值，最小值"><a href="#int的最大值，最小值" class="headerlink" title="int的最大值，最小值"></a>int的最大值，最小值</h3><p>int的最大值可以通过其对应的封装类Integer.MAX_VALUE获取</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestNumber &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        //<span class="type">int</span>的最大值</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">        //<span class="type">int</span>的最小值</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">Integer</span>.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">2147483647</span></span><br><span class="line">	<span class="number">-2147483648</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><h3 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h3><p>方法1： 使用String类的静态方法valueOf 方法2： 先把基本类型装箱为对象，然后调用对象的toString</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//方法1</span></span><br><span class="line">        <span class="type">String</span> str = <span class="type">String</span>.<span class="built_in">valueOf</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        Integer it = i;</span><br><span class="line">        <span class="type">String</span> str2 = it.<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h3><p>调用Integer的静态方法parseInt</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">&quot;999&quot;</span>;</span><br><span class="line">        <span class="type">int</span> i = Integer.<span class="property">parseInt</span>(<span class="built_in">str</span>);</span><br><span class="line">        System.<span class="property">out</span>.<span class="property">println</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>java.lang.Math提供了一些常用的数学运算方法，并且都是以静态方法的形式存在</p>
<h3 id="四舍五入-随机数，开方，次方，π，自然常数"><a href="#四舍五入-随机数，开方，次方，π，自然常数" class="headerlink" title="四舍五入, 随机数，开方，次方，π，自然常数"></a>四舍五入, 随机数，开方，次方，π，自然常数</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">float</span> f1 = <span class="number">5.4</span>f;</span><br><span class="line">        <span class="type">float</span> f2 = <span class="number">5.5</span>f;</span><br><span class="line">        //<span class="number">5.4</span>四舍五入即<span class="number">5</span></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.round(f1));</span><br><span class="line">        //<span class="number">5.5</span>四舍五入即<span class="number">6</span></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.round(f2));</span><br><span class="line">         </span><br><span class="line">        //得到一个<span class="number">0</span><span class="number">-1</span>之间的随机浮点数（取不到<span class="number">1</span>）</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.random());</span><br><span class="line">         </span><br><span class="line">        //得到一个<span class="number">0</span><span class="number">-10</span>之间的随机整数 （取不到<span class="number">10</span>）</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println((<span class="type">int</span>)( Math.random()*<span class="number">10</span>));</span><br><span class="line">        //开方</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.sqrt(<span class="number">9</span>));</span><br><span class="line">        //次方（<span class="number">2</span>的<span class="number">4</span>次方）</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">         </span><br><span class="line">        //π</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        //自然常数</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐 使用格式化输出，就可以简洁明了</p>
<p>%s 表示字符串 %d 表示数字 %n 表示换行</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> name =<span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> kill = <span class="number">8</span>;</span><br><span class="line">        <span class="type">String</span> title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span></span><br><span class="line">        <span class="type">String</span> sentence = name+ <span class="string">&quot; 在进行了连续 &quot;</span> + kill + <span class="string">&quot; 次击杀后，获得了 &quot;</span> + title +<span class="string">&quot; 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//使用格式化输出</span></span><br><span class="line">        <span class="comment">//%s表示字符串，%d表示数字,%n表示换行</span></span><br><span class="line">        <span class="type">String</span> sentenceFormat =<span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        System.out.<span class="built_in">printf</span>(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="printf和format"><a href="#printf和format" class="headerlink" title="printf和format"></a>printf和format</h3><p>printf和format能够达到一模一样的效果，<a href="https://how2j.cn/k/helloworld/helloworld-eclipse-tips/300.html#step706">如何通过eclipse查看java源代码</a> 可以看到，在printf中直接调用了format</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> name =<span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> kill = <span class="number">8</span>;</span><br><span class="line">        <span class="type">String</span> title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> sentenceFormat =<span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        <span class="comment">//使用printf格式化输出</span></span><br><span class="line">        System.out.<span class="built_in">printf</span>(sentenceFormat,name,kill,title);</span><br><span class="line">        <span class="comment">//使用format格式化输出</span></span><br><span class="line">        System.out.format(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p><strong>换行符</strong>就是另起一行 — ‘\n’ 换行（newline） <strong>回车符</strong>就是回到一行的开头 — ‘\r’ 回车（return） 在eclipse里敲一个回车，实际上是<strong>回车换行符</strong> Java是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如Windows,Linux,Mac 然而在不同的操作系统，换行符是不一样的 （1）在DOS和Windows中，每行结尾是 “\r\n”； （2）Linux系统里，每行结尾只有 “\n”； （3）Mac系统里，每行结尾是只有 “\r”。 为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用%n，就可以做到平台无关的换行</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">printf</span>(<span class="string">&quot;这是换行符%n&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">printf</span>(<span class="string">&quot;这是换行符%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达"><a href="#总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达" class="headerlink" title="总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达"></a>总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestNumber &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span> year = <span class="number">2020</span>;</span><br><span class="line">        //总长度，左对齐，补<span class="number">0</span>，千位分隔符，小数点位数，本地化表达</span><br><span class="line">          </span><br><span class="line">        //直接打印数字</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(&quot;%d%n&quot;,year);</span><br><span class="line">        //总长度是<span class="number">8</span>,默认右对齐</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(&quot;%8d%n&quot;,year);</span><br><span class="line">        //总长度是<span class="number">8</span>,左对齐</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(&quot;%-8d%n&quot;,year);</span><br><span class="line">        //总长度是<span class="number">8</span>,不够补<span class="number">0</span></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(&quot;%08d%n&quot;,year);</span><br><span class="line">        //千位分隔符</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(&quot;%,8d%n&quot;,year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        //小数点位数</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(&quot;%.2f%n&quot;,Math.PI);</span><br><span class="line">          </span><br><span class="line">        //不同国家的千位分隔符</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(Locale.FRANCE,&quot;%,.2f%n&quot;,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(Locale.US,&quot;%,.2f%n&quot;,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(Locale.UK,&quot;%,.2f%n&quot;,Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="保存一个字符的时候使用char"><a href="#保存一个字符的时候使用char" class="headerlink" title="保存一个字符的时候使用char"></a>保存一个字符的时候使用char</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChar</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> c2 = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//字符1,而非数字1</span></span><br><span class="line">        <span class="keyword">char</span> c3 = <span class="string">&#x27;中&#x27;</span>;<span class="comment">//汉字字符</span></span><br><span class="line">        <span class="keyword">char</span> c4 = <span class="string">&#x27;ab&#x27;</span>; <span class="comment">//只能放一个字符</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="char对应的封装类"><a href="#char对应的封装类" class="headerlink" title="char对应的封装类"></a>char对应的封装类</h3><p>char对应的封装类是Character 装箱拆箱概念，参考 <a href="https://how2j.cn/k/number-string/number-string-wrap/22.html">拆箱装箱</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        Character c = c1; <span class="comment">//自动装箱</span></span><br><span class="line">        c1 = c;<span class="comment">//自动拆箱</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Character常见方法"><a href="#Character常见方法" class="headerlink" title="Character常见方法"></a>Character常见方法</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> TestChar &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Letter(&#x27;<span class="params">a</span>&#x27;)</span>);<span class="comment">//判断是否为字母</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(&#x27;<span class="params">a</span>&#x27;)</span>); <span class="comment">//判断是否为数字</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Whitespace(&#x27; &#x27;)</span>); <span class="comment">//是否是空白</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">UpperCase(&#x27;<span class="params">a</span>&#x27;)</span>); <span class="comment">//是否是大写</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LowerCase(&#x27;<span class="params">a</span>&#x27;)</span>); <span class="comment">//是否是小写</span></span><br><span class="line">         </span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">UpperCase(&#x27;<span class="params">a</span>&#x27;)</span>); <span class="comment">//转换为大写</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(&#x27;A&#x27;)</span>); <span class="comment">//转换为小写</span></span><br><span class="line"> </span><br><span class="line">        String a = <span class="character">&#x27;a&#x27;</span>; <span class="comment">//不能够直接把一个字符转换成字符串</span></span><br><span class="line">        String a2 = <span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">String(&#x27;<span class="params">a</span>&#x27;)</span>; <span class="comment">//转换为字符串</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见转义"><a href="#常见转义" class="headerlink" title="常见转义"></a>常见转义</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">public class TestChar &#123;</span><br><span class="line">  </span><br><span class="line">    public static void mai<span class="meta">n</span>(String[] args) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;使用空格无法达到对齐的效果&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;abc def&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;ab def&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;a def&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;使用\\t制表符可以达到对齐的效果&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;abc\tdef&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;ab\tdef&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;a\tdef&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;一个\\t制表符长度是8&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;12345678def&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;换行符 \\n&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;abc\ndef&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;单引号 \\&#x27;&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;abc\&#x27;def&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;双引号 \\\&quot;&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;abc\&quot;def&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;反斜杠本身 \\&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;abc\\def&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>字符串即字符的组合，在Java中，字符串是一个类，所以我们见到的字符串都是对象 常见创建字符串手段： \1. 每当有一个<strong>字面值</strong>出现的时候，虚拟机就会创建一个字符串 \2. 调用String的构造方法创建一个字符串对象 \3. 通过+加号进行字符串拼接也会创建新的字符串对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">String</span> garen =<span class="string">&quot;盖伦&quot;</span>; <span class="comment">//字面值,虚拟机碰到字面值就会创建一个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="title class_">String</span> teemo = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;提莫&quot;</span>); <span class="comment">//创建了两个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        char[] cs = <span class="keyword">new</span> char[]&#123;<span class="string">&#x27;崔&#x27;</span>,<span class="string">&#x27;斯&#x27;</span>,<span class="string">&#x27;特&#x27;</span>&#125;;</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">String</span> hero = <span class="keyword">new</span> <span class="title class_">String</span>(cs);<span class="comment">//  通过字符数组创建一个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="title class_">String</span> hero3 = garen + teemo;<span class="comment">//  通过+加号进行字符串拼接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final-2"><a href="#final-2" class="headerlink" title="final"></a>final</h3><p>String 被修饰为final,所以是不能被继承的</p>
<h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p>immutable 是指不可改变的 比如创建了一个字符串对象 String garen &#x3D;”盖伦”; <strong>不可改变</strong>的具体含义是指： 不能增加长度 不能减少长度 不能插入字符 不能删除字符 不能修改字符 一旦创建好这个字符串，里面的内容 <strong>永远</strong> 不能改变</p>
<p>String 的表现就像是一个<strong>常量</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">String</span> garen =<span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>如果不使用字符串格式化，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐 使用<strong>字符串格式化</strong>，就可以<strong>简洁明了</strong> 更多的格式化规则，参考<a href="https://how2j.cn/k/number-string/number-string-foramt/320.html">格式化输出</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> name =<span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> kill = <span class="number">8</span>;</span><br><span class="line">        <span class="type">String</span> title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span></span><br><span class="line">        <span class="type">String</span> sentence = name+ <span class="string">&quot; 在进行了连续 &quot;</span> + kill + <span class="string">&quot; 次击杀后，获得了 &quot;</span> + title +<span class="string">&quot; 的称号&quot;</span>;</span><br><span class="line">          </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//格式化字符串</span></span><br><span class="line">        <span class="comment">//%s表示字符串，%d表示数字,%n表示换行</span></span><br><span class="line">        <span class="type">String</span> sentenceFormat =<span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> sentence2 = <span class="type">String</span>.format(sentenceFormat, name,kill,title);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>length方法返回当前字符串的长度 可以有长度为0的字符串,即空字符串</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestString &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        String <span class="type">name</span> =&quot;盖伦&quot;;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>.length());</span><br><span class="line">         </span><br><span class="line">        String unknowHero = &quot;&quot;;</span><br><span class="line">         </span><br><span class="line">        //可以有长度为<span class="number">0</span>的字符串,即空字符串</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(unknowHero.length());</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操纵字符串"><a href="#操纵字符串" class="headerlink" title="操纵字符串"></a>操纵字符串</h2><h3 id="获取字符"><a href="#获取字符" class="headerlink" title="获取字符"></a>获取字符</h3><p>charAt(int index)获取指定位置的字符</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">String</span> sentence = <span class="string">&quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">char</span> c = sentence.<span class="built_in">charAt</span>(<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(c);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取对应的字符数组"><a href="#获取对应的字符数组" class="headerlink" title="获取对应的字符数组"></a>获取对应的字符数组</h3><p>toCharArray() 获取对应的字符数组</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">String</span> sentence = <span class="string">&quot;盖伦,在进行了连续8次击杀后,获得了超神 的称号&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">char</span>[] cs = sentence.<span class="built_in">toCharArray</span>(); <span class="comment">//获取对应的字符数组</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.<span class="built_in">length</span>() == cs.length);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="截取子字符串"><a href="#截取子字符串" class="headerlink" title="截取子字符串"></a>截取子字符串</h3><p>subString 截取子字符串</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="title class_">String</span> sentence = <span class="string">&quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//截取从第3个开始的字符串 （基0）</span></span><br><span class="line">        <span class="title class_">String</span> subString1 = sentence.<span class="title function_">substring</span>(<span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(subString1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//截取从第3个开始的字符串 （基0）</span></span><br><span class="line">        <span class="comment">//到5-1的位置的字符串</span></span><br><span class="line">        <span class="comment">//左闭右开</span></span><br><span class="line">        <span class="title class_">String</span> subString2 = sentence.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(subString2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分隔"><a href="#分隔" class="headerlink" title="分隔"></a>分隔</h3><p>split 根据分隔符进行分隔</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence = <span class="string">&quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="regexp">//</span>根据,进行分割，得到<span class="number">3</span>个子字符串</span><br><span class="line">        String subSentences[] = sentence.<span class="keyword">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String <span class="function"><span class="keyword">sub</span> : <span class="title">subSentences</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="function"><span class="keyword">sub</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="去掉首尾空格"><a href="#去掉首尾空格" class="headerlink" title="去掉首尾空格"></a>去掉首尾空格</h3><p>trim 去掉首尾空格</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="title class_">String</span> sentence = <span class="string">&quot;        盖伦,在进行了连续8次击杀后,获得了 超神 的称号      &quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(sentence);</span><br><span class="line">        <span class="comment">//去掉首尾空格</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(sentence.<span class="title function_">trim</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>toLowerCase 全部变成小写 toUpperCase 全部变成大写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="title class_">String</span> sentence = <span class="string">&quot;Garen&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//全部变成小写</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(sentence.<span class="title function_">toLowerCase</span>());</span><br><span class="line">        <span class="comment">//全部变成大写</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(sentence.<span class="title function_">toUpperCase</span>());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>indexOf 判断字符或者子字符串出现的位置 contains 是否包含子字符串</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestString</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        String sentence = <span class="string">&quot;盖伦,在进行了连续8次击杀后,获得了超神 的称号&quot;</span>;</span><br><span class="line">  </span><br><span class="line">        System.<span class="keyword">out</span>.println(sentence.indexOf(<span class="string">&#x27;8&#x27;</span>)); <span class="comment">//字符第一次出现的位置</span></span><br><span class="line">          </span><br><span class="line">        System.<span class="keyword">out</span>.println(sentence.indexOf(<span class="string">&quot;超神&quot;</span>)); <span class="comment">//字符串第一次出现的位置</span></span><br><span class="line">          </span><br><span class="line">        System.<span class="keyword">out</span>.println(sentence.lastIndexOf(<span class="string">&quot;了&quot;</span>)); <span class="comment">//字符串最后出现的位置</span></span><br><span class="line">          </span><br><span class="line">        System.<span class="keyword">out</span>.println(sentence.indexOf(<span class="string">&#x27;,&#x27;</span>,<span class="number">5</span>)); <span class="comment">//从位置5开始，出现的第一次,的位置</span></span><br><span class="line">          </span><br><span class="line">        System.<span class="keyword">out</span>.println(sentence.contains(<span class="string">&quot;击杀&quot;</span>)); <span class="comment">//是否包含字符串&quot;击杀&quot;</span></span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>replaceAll 替换所有的 replaceFirst 只替换第一个</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestString &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence = &quot;盖伦,在进行了连续8次击杀后,获得了超神 的称号&quot;;</span><br><span class="line"> </span><br><span class="line">        String <span class="keyword">temp</span> = sentence.replaceAll(&quot;击杀&quot;, &quot;被击杀&quot;); //替换所有的</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">temp</span> = <span class="keyword">temp</span>.replaceAll(&quot;超神&quot;, &quot;超鬼&quot;);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">temp</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">temp</span> = sentence.replaceFirst(&quot;,&quot;,&quot;&quot;);//只替换第一个</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">temp</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><h3 id="是否是同一个对象"><a href="#是否是同一个对象" class="headerlink" title="是否是同一个对象"></a>是否是同一个对象</h3><p>str1和str2的内容一定是一样的！ 但是，并不是同一个字符串对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="title class_">String</span> str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">String</span> str2 = <span class="keyword">new</span> <span class="title class_">String</span>(str1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//==用于判断是否是同一个字符串对象</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>( str1  ==  str2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否是同一个对象-特例"><a href="#是否是同一个对象-特例" class="headerlink" title="是否是同一个对象-特例"></a>是否是同一个对象-特例</h3><p><strong>字符串常量池的存在</strong></p>
<p>一般说来，编译器每碰到一个字符串的字面值，就会创建一个新的对象 所以在第6行会创建了一个新的字符串”the light” 但是在第7行，编译器发现已经存在现成的”the light”，那么就直接拿来使用，而没有进行重复创建</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">String</span> str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">        <span class="title class_">String</span> str3 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>( str1  ==  str3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内容是否相同"><a href="#内容是否相同" class="headerlink" title="内容是否相同"></a>内容是否相同</h3><p>使用equals进行字符串内容的比较，必须大小写一致 equalsIgnoreCase，忽略大小写判断内容是否一致</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="variable">public</span> <span class="keyword">static</span> <span class="variable">void</span> <span class="title function_">main</span>(<span class="params">String</span>[] <span class="params">args</span>) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="title class_">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="title class_">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="variable">new</span> <span class="title class_">String</span>(<span class="variable">str1</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="variable">str1</span>.<span class="property">toUpperCase</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//==用于判断是否是同一个字符串对象</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>( <span class="variable">str1</span>  <span class="operator">==</span>  <span class="variable">str2</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">str1</span>.<span class="property">equals</span>(<span class="variable">str2</span>));<span class="comment">//完全一样返回true</span></span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">str1</span>.<span class="property">equals</span>(<span class="variable">str3</span>));<span class="comment">//大小写不一样，返回false</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">str1</span>.<span class="property">equalsIgnoreCase</span>(<span class="variable">str3</span>));<span class="comment">//忽略大小写的比较，返回true</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否以子字符串开始或者结束"><a href="#是否以子字符串开始或者结束" class="headerlink" title="是否以子字符串开始或者结束"></a>是否以子字符串开始或者结束</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">String</span> str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> start = <span class="string">&quot;the&quot;</span>;</span><br><span class="line">        <span class="type">String</span> end = <span class="string">&quot;Ight&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(str1.<span class="built_in">startsWith</span>(start));<span class="comment">//以...开始</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(str1.<span class="built_in">endsWith</span>(end));<span class="comment">//以...结束</span></span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer是可变长的字符串</p>
<h3 id="追加-删除-插入-反转"><a href="#追加-删除-插入-反转" class="headerlink" title="追加 删除 插入 反转"></a>追加 删除 插入 反转</h3><p>append追加 delete 删除 insert 插入 reverse 反转</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestString &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        String str1 = <span class="string">&quot;let there &quot;</span>;</span><br><span class="line"> </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(str1); <span class="comment">//根据str1创建一个StringBuffer对象</span></span><br><span class="line">        sb.<span class="keyword">append</span>(<span class="string">&quot;be light&quot;</span>); <span class="comment">//在最后追加</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="keyword">println</span>(sb);</span><br><span class="line">         </span><br><span class="line">        sb.<span class="keyword">delete</span>(<span class="number">4</span>, <span class="number">10</span>);<span class="comment">//删除4-10之间的字符</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="keyword">println</span>(sb);</span><br><span class="line">         </span><br><span class="line">        sb.insert(<span class="number">4</span>, <span class="string">&quot;there &quot;</span>);<span class="comment">//在4这个位置插入 there</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="keyword">println</span>(sb);</span><br><span class="line">         </span><br><span class="line">        sb.<span class="keyword">reverse</span>(); <span class="comment">//反转</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="keyword">println</span>(sb);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="长度-容量"><a href="#长度-容量" class="headerlink" title="长度 容量"></a>长度 容量</h3><p>为什么StringBuffer可以变长？ 和String<strong>内部是一个字符数组</strong>一样，StringBuffer也维护了一个字符数组。 但是，这个字符数组，<strong>留有冗余长度</strong> 比如说new StringBuffer(“the”)，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。 如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，<strong>看上去</strong> 数组长度就变长了 参考<a href="https://how2j.cn/k/number-string/number-string-mystringbuilder/331.html">MyStringBuffer</a> length: “the”的长度 3 capacity: 分配的总空间 19</p>
<p><strong>注：</strong> 19这个数量，不同的JDK数量是不一样的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">String</span> str1 = <span class="string">&quot;the&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="title class_">StringBuffer</span> sb = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(sb.<span class="title function_">length</span>()); <span class="comment">//内容长度</span></span><br><span class="line">         </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(sb.<span class="title function_">capacity</span>());<span class="comment">//总空间</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MyStringBuffer"><a href="#MyStringBuffer" class="headerlink" title="MyStringBuffer"></a>MyStringBuffer</h2><h3 id="IStringBuffer接口"><a href="#IStringBuffer接口" class="headerlink" title="IStringBuffer接口"></a>IStringBuffer接口</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IStringBuffer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">String</span> str)</span></span>; <span class="comment">//追加字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> c)</span></span>;  <span class="comment">//追加字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos,<span class="type">char</span> b)</span></span>; <span class="comment">//指定位置插入字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos,<span class="type">String</span> b)</span></span>; <span class="comment">//指定位置插入字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">delete</span><span class="params">(<span class="type">int</span> start)</span></span>; <span class="comment">//从开始位置删除剩下的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>; <span class="comment">//从开始位置删除结束位置-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>; <span class="comment">//反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>; <span class="comment">//返回长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="value和capacity"><a href="#value和capacity" class="headerlink" title="value和capacity"></a>value和capacity</h3><p>value：用于存放字符数组 capacity： 容量 无参构造方法： 根据容量初始化value</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringBuffer</span> <span class="keyword">implements</span> <span class="title">IStringBuffer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStringBuffer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带参构造方法"><a href="#带参构造方法" class="headerlink" title="带参构造方法"></a>带参构造方法</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringBuffer</span> <span class="keyword">implements</span> <span class="title">IStringBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != str) &#123;</span><br><span class="line">            value = str.toCharArray();</span><br><span class="line">        &#125;</span><br><span class="line">        length = value.length;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; value.length) &#123;</span><br><span class="line">            capacity = value.length * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, String b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转-reverse"><a href="#反转-reverse" class="headerlink" title="反转 reverse"></a>反转 reverse</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStringBuffer</span> <span class="keyword">implements</span> <span class="title class_">IStringBuffer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != str) &#123;</span><br><span class="line">            value = str.toCharArray();</span><br><span class="line">        &#125;</span><br><span class="line">        length = value.length;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; value.length) &#123;</span><br><span class="line">            capacity = value.length * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">char</span> c)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> pos, String b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> value[i];</span><br><span class="line">            value[i] = value[length - i - <span class="number">1</span>];</span><br><span class="line">            value[length - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] realValue = <span class="keyword">new</span> <span class="title class_">char</span>[length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, realValue, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(realValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStringBuffer</span>(<span class="string">&quot;the light&quot;</span>);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入insert-和-append"><a href="#插入insert-和-append" class="headerlink" title="插入insert 和 append"></a>插入insert 和 append</h3><p><strong>边界条件判断</strong> 插入之前，首先要判断的是一些边界条件。 比如插入位置是否合法，插入的字符串是否为空</p>
<p><strong>扩容</strong> \1. 要判断是否需要<strong>扩容</strong>。 如果插入的字符串加上已经存在的内容的总长度超过了容量，那么就需要扩容。 \2. 数组的长度是固定的，不能改变的，数组本身不支持<strong>扩容</strong>。 我们使用变通的方式来解决这个问题。 \3. 根据需要插入的字符串的长度和已经存在的内容的长度，计算出一个新的容量。 然后根据这个容量，创建一个新的数组，接着把原来的数组的内容，复制到这个新的数组中来。并且让value这个引用，指向新的数组，从而达到<strong>扩容</strong>的效果。</p>
<p><strong>插入字符串</strong> \1. 找到要插入字符串的位置，从这个位置开始，把原数据<strong>看成两段</strong>，把后半段向后挪动一个距离，这个距离刚好是插入字符串的长度 \2. 然后把要插入的数据，插入这个挪出来的，刚刚好的位置里。</p>
<p><strong>修改length的值</strong> 最后修改length的值，是原来的值加上插入字符串的长度</p>
<p><strong>insert(int, char)</strong> 参数是字符的insert方法，通过调用insert(int, String) 也就实现了。</p>
<p><strong>append</strong> 追加，就是在最后位置插入。 所以不需要单独开发方法，直接调用insert方法，就能达到最后位置插入的效果</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MyStringBuffer implements IStringBuffer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] <span class="keyword">value</span>;</span><br><span class="line">    <span class="built_in">public</span> MyStringBuffer() &#123;</span><br><span class="line">        <span class="keyword">value</span> = <span class="built_in">new</span> <span class="type">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> MyStringBuffer(String str) &#123;</span><br><span class="line">        this();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == str) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; str.length()) &#123;</span><br><span class="line">            capacity = <span class="keyword">value</span>.length * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">value</span> = <span class="built_in">new</span> <span class="type">char</span>[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (capacity &gt;= str.length()) &#123;</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(str.toCharArray(), <span class="number">0</span>, <span class="keyword">value</span>, <span class="number">0</span>, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        length = str.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> append(String str) &#123;</span><br><span class="line">        <span class="keyword">insert</span>(length, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> append(<span class="type">char</span> c) &#123;</span><br><span class="line">        append(String.valueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">insert</span>(<span class="type">int</span> pos, <span class="type">char</span> c) &#123;</span><br><span class="line">        //String.valueOf(c)将c转换为字符串</span><br><span class="line">        <span class="keyword">insert</span>(pos, String.valueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">insert</span>(<span class="type">int</span> pos, String b) &#123;</span><br><span class="line">        //边界条件判断</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == b) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //扩容</span><br><span class="line">        <span class="keyword">while</span> (length + b.length() &gt; capacity) &#123;</span><br><span class="line">            capacity = (<span class="type">int</span>)((length + b.length()) * <span class="number">1.5</span>f);</span><br><span class="line">            <span class="type">char</span>[] newValue = <span class="built_in">new</span> <span class="type">char</span>[capacity];</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, <span class="number">0</span>, newValue, <span class="number">0</span>, length);</span><br><span class="line">            <span class="keyword">value</span> = newValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] cs = b.toCharArray();</span><br><span class="line"></span><br><span class="line">        //先把已经存在的数据往后移</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, pos, <span class="keyword">value</span>, pos + cs.length, length - pos);</span><br><span class="line">        //把要插入的数据插入到指定位置</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(cs, <span class="number">0</span>, <span class="keyword">value</span>, pos, cs.length);</span><br><span class="line"></span><br><span class="line">        length = length + cs.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">delete</span>(<span class="type">int</span> <span class="keyword">start</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">delete</span>(<span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> reverse() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="keyword">temp</span> = <span class="keyword">value</span>[i];</span><br><span class="line">            <span class="keyword">value</span>[i] = <span class="keyword">value</span>[length - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">value</span>[length - i - <span class="number">1</span>] = <span class="keyword">temp</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">int</span> length() &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String toString() &#123;</span><br><span class="line">        <span class="type">char</span>[] realValue = <span class="built_in">new</span> <span class="type">char</span>[length];</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, <span class="number">0</span>, realValue, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span> String(realValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        MyStringBuffer sb = <span class="built_in">new</span> MyStringBuffer(&quot;there light&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.<span class="keyword">insert</span>(<span class="number">0</span>, &quot;let &quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line"></span><br><span class="line">        sb.<span class="keyword">insert</span>(<span class="number">10</span>, &quot;be &quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.<span class="keyword">insert</span>(<span class="number">0</span>, &quot;God Say:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.append(&quot;!&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.append(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除 delete"></a>删除 delete</h3><p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110100035409.png" alt="image-20220110100035409"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MyStringBuffer implements IStringBuffer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] <span class="keyword">value</span>;</span><br><span class="line">    <span class="built_in">public</span> MyStringBuffer() &#123;</span><br><span class="line">        <span class="keyword">value</span> = <span class="built_in">new</span> <span class="type">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> MyStringBuffer(String str) &#123;</span><br><span class="line">        this();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == str) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; str.length()) &#123;</span><br><span class="line">            capacity = <span class="keyword">value</span>.length * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">value</span> = <span class="built_in">new</span> <span class="type">char</span>[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (capacity &gt;= str.length()) &#123;</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(str.toCharArray(), <span class="number">0</span>, <span class="keyword">value</span>, <span class="number">0</span>, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        length = str.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> append(String str) &#123;</span><br><span class="line">        <span class="keyword">insert</span>(length, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> append(<span class="type">char</span> c) &#123;</span><br><span class="line">        append(String.valueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">insert</span>(<span class="type">int</span> pos, <span class="type">char</span> c) &#123;</span><br><span class="line">        //String.valueOf(c)将c转换为字符串</span><br><span class="line">        <span class="keyword">insert</span>(pos, String.valueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">insert</span>(<span class="type">int</span> pos, String b) &#123;</span><br><span class="line">        //边界条件判断</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == b) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //扩容</span><br><span class="line">        <span class="keyword">while</span> (length + b.length() &gt; capacity) &#123;</span><br><span class="line">            capacity = (<span class="type">int</span>)((length + b.length()) * <span class="number">1.5</span>f);</span><br><span class="line">            <span class="type">char</span>[] newValue = <span class="built_in">new</span> <span class="type">char</span>[capacity];</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, <span class="number">0</span>, newValue, <span class="number">0</span>, length);</span><br><span class="line">            <span class="keyword">value</span> = newValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] cs = b.toCharArray();</span><br><span class="line"></span><br><span class="line">        //先把已经存在的数据往后移</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, pos, <span class="keyword">value</span>, pos + cs.length, length - pos);</span><br><span class="line">        //把要插入的数据插入到指定位置</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(cs, <span class="number">0</span>, <span class="keyword">value</span>, pos, cs.length);</span><br><span class="line"></span><br><span class="line">        length = length + cs.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">delete</span>(<span class="type">int</span> <span class="keyword">start</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>(<span class="keyword">start</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">delete</span>(<span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>) &#123;</span><br><span class="line">        //边界条件判断</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">start</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">start</span> &gt; length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">end</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">end</span> &gt; length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">start</span> &gt;= <span class="keyword">end</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, <span class="keyword">end</span>, <span class="keyword">value</span>, <span class="keyword">start</span>, length - <span class="keyword">end</span>);</span><br><span class="line">        length -= <span class="keyword">end</span> - <span class="keyword">start</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> reverse() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="keyword">temp</span> = <span class="keyword">value</span>[i];</span><br><span class="line">            <span class="keyword">value</span>[i] = <span class="keyword">value</span>[length - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">value</span>[length - i - <span class="number">1</span>] = <span class="keyword">temp</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">int</span> length() &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String toString() &#123;</span><br><span class="line">        <span class="type">char</span>[] realValue = <span class="built_in">new</span> <span class="type">char</span>[length];</span><br><span class="line">        <span class="keyword">System</span>.arraycopy(<span class="keyword">value</span>, <span class="number">0</span>, realValue, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span> String(realValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        MyStringBuffer sb = <span class="built_in">new</span> MyStringBuffer(&quot;there light&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.<span class="keyword">insert</span>(<span class="number">0</span>, &quot;let &quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line"></span><br><span class="line">        sb.<span class="keyword">insert</span>(<span class="number">10</span>, &quot;be &quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.<span class="keyword">insert</span>(<span class="number">0</span>, &quot;God Say:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.append(&quot;!&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.append(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line"></span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line"></span><br><span class="line">        sb.<span class="keyword">delete</span>(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">        sb.<span class="keyword">delete</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date类 注意：是<strong>java.util.Date;</strong> 而非 java.sql.Date，此类是给数据库访问的时候使用的</p>
<h3 id="时间原点概念"><a href="#时间原点概念" class="headerlink" title="时间原点概念"></a>时间原点概念</h3><p>所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。</p>
<p>日期类型也不例外，换句话说，一个日期，比如2020年10月1日，在计算机里，会用一个数字来代替。</p>
<p>那么最特殊的一个数字，就是零. 零这个数字，就代表Java中的时间原点，其对应的日期是1970年1月1日 8点0分0秒 。 (为什么是8点，因为中国的太平洋时区是UTC-8，刚好和格林威治时间差8个小时)</p>
<p>为什么对应1970年呢？ 因为1969年发布了第一个 UNIX 版本：AT&amp;T，综合考虑，当时就把1970年当做了时间原点。</p>
<p>所有的日期，都是以为这个0点为基准，每过一毫秒，就+1。</p>
<h3 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package <span class="type">date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestDate &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        // 当前时间</span><br><span class="line">        <span class="type">Date</span> d1 = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;当前时间:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(d1);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line"></span><br><span class="line">        // 从<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 早上<span class="number">8</span>点<span class="number">0</span>分<span class="number">0</span>秒 开始经历的毫秒数</span><br><span class="line">        <span class="type">Date</span> d2 = <span class="built_in">new</span> <span class="type">Date</span>(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;从1970年1月1日 早上8点0分0秒 开始经历了5秒的时间&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getTime"><a href="#getTime" class="headerlink" title="getTime"></a>getTime</h3><p>getTime() 得到一个long型的整数 这个整数代表 从<strong>1970.1.1 08:00:00:000</strong> 开始 每经历一毫秒，增加1 直接打印对象，会看到 “Tue Jan 05 09:51:48 CST 2016” 这样的格式，可读性比较差，为了获得“2016&#x2F;1&#x2F;5 09:51:48”这样的格式 请参考<a href="https://how2j.cn/k/date/date-format/348.html">日期格式化</a></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package <span class="type">date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestDate &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">Date</span> now= <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line">        //打印当前时间</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;当前时间:&quot;+now.toString());</span><br><span class="line">        //getTime() 得到一个long型的整数</span><br><span class="line">        //这个整数代表 <span class="number">1970.1</span><span class="number">.1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">000</span>，每经历一毫秒，增加<span class="number">1</span></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;当前时间getTime()返回的值是：&quot;+now.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> zero = <span class="built_in">new</span> <span class="type">Date</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;用0作为构造方法，得到的日期是:&quot;+zero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="System-currentTimeMillis"><a href="#System-currentTimeMillis" class="headerlink" title="System.currentTimeMillis()"></a>System.currentTimeMillis()</h3><p>当前日期的毫秒数 new Date().getTime() 和 System.currentTimeMillis() 是一样的 不过由于机器性能的原因，可能会相差几十毫秒，毕竟每执行一行代码，都是需要时间的</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package <span class="type">date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestDate &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">Date</span> now= <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line">        //当前日期的毫秒数</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Date.getTime() \t\t\t返回值: &quot;+now.getTime());</span><br><span class="line">        //通过<span class="keyword">System</span>.currentTimeMillis()获取当前日期的毫秒数</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;System.currentTimeMillis() \t返回值: &quot;+<span class="keyword">System</span>.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>SimpleDateFormat 日期格式化类</p>
<h3 id="日期转字符串"><a href="#日期转字符串" class="headerlink" title="日期转字符串"></a>日期转字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//y 代表年</span></span><br><span class="line">        <span class="comment">//M 代表月</span></span><br><span class="line">        <span class="comment">//d 代表日</span></span><br><span class="line">        <span class="comment">//H 代表24进制的小时</span></span><br><span class="line">        <span class="comment">//h 代表12进制的小时</span></span><br><span class="line">        <span class="comment">//m 代表分钟</span></span><br><span class="line">        <span class="comment">//s 代表秒</span></span><br><span class="line">        <span class="comment">//S 代表毫秒</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;</span>+str);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span> );</span><br><span class="line">        Date d1= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> sdf1.format(d1);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间通过 yyyy-MM-dd 格式化后的输出: &quot;</span>+str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式（yyyy&#x2F;MM&#x2F;dd HH:mm:ss）需要和字符串格式保持一致，如果不一样就会抛出解析异常ParseException</p>
<p>关于异常的详细讲解在<a href="https://how2j.cn/k/exception/exception-tutorial/332.html">Java 异常 Exception</a> 章节展开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2016/1/5 12:12:12&quot;</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">             System.out.printf(<span class="string">&quot;字符串 %s 通过格式  yyyy/MM/dd HH:mm:ss %n转换为日期对象: %s&quot;</span>,str,d.toString());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>Calendar类即日历类，常用于进行“翻日历”，比如<strong>下个月的今天是多久</strong></p>
<h3 id="Calendar与Date进行转换"><a href="#Calendar与Date进行转换" class="headerlink" title="Calendar与Date进行转换"></a>Calendar与Date进行转换</h3><p>采用<a href="https://how2j.cn/k/class-object/class-object-singleton/349.html">单例模式</a>获取日历对象Calendar.getInstance();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//采用单例模式获取日历对象Calendar.getInstance();</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">//通过日历对象得到日期对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> c.getTime();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>);</span><br><span class="line">        c.setTime(d2);<span class="comment">//把这个日历，调成日期 : 1970.1.1 08:00:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="翻日历"><a href="#翻日历" class="headerlink" title="翻日历"></a>翻日历</h3><p>add方法，在原日期上增加年&#x2F;月&#x2F;日 set方法，直接设置年&#x2F;月&#x2F;日</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package <span class="type">date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestDate &#123;</span><br><span class="line">    private static SimpleDateFormat sdf = <span class="built_in">new</span> SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        //采用单例模式获取日历对象Calendar.getInstance();</span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        //通过日历对象得到日期对象</span><br><span class="line">        <span class="type">Date</span> now = c.getTime();</span><br><span class="line">        // 当前日期</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;当前日期：\t&quot; + format(c.getTime()));</span><br><span class="line"></span><br><span class="line">        // 下个月的今天</span><br><span class="line">        c.setTime(now);</span><br><span class="line">        c.<span class="keyword">add</span>(Calendar.MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;下个月的今天:\t&quot; +format(c.getTime()));</span><br><span class="line"></span><br><span class="line">        // 去年的今天</span><br><span class="line">        c.setTime(now);</span><br><span class="line">        c.<span class="keyword">add</span>(Calendar.YEAR, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;去年的今天:\t&quot; +format(c.getTime()));</span><br><span class="line"></span><br><span class="line">        // 上个月的第三天</span><br><span class="line">        c.setTime(now);</span><br><span class="line">        c.<span class="keyword">add</span>(Calendar.MONTH, <span class="number">-1</span>);</span><br><span class="line">        c.<span class="keyword">set</span>(Calendar.DATE, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;上个月的第三天:\t&quot; +format(c.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String format(<span class="type">Date</span> <span class="type">time</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.format(<span class="type">time</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>异常定义： 导致程序的正常流程被中断的事件，叫做异常</p>
<h3 id="文件不存在异常"><a href="#文件不存在异常" class="headerlink" title="文件不存在异常"></a>文件不存在异常</h3><p>比如要打开d盘的LOL.exe文件，这个文件是有可能不存在的 Java中通过 new FileInputStream(f) 试图打开某文件，就有可能抛出<strong>文件不存在异常FileNotFoundException</strong> 如果不处理该异常，就会有编译错误 处理办法参见 <a href="https://how2j.cn/k/exception/exception-trycatch/336.html">异常处理</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="comment">//试图打开文件LOL.exe，会抛出FileNotFoundException，如果不处理该异常，就会有编译错误</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>异常处理常见手段： try catch finally throws</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>3.如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的catch块中</p>
<p>4.e.printStackTrace(); 会打印出方法的调用痕迹，如此例，会打印出异常开始于TestException的第16行，这样就便于定位和分析到底哪里出了异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用异常的父类进行catch"><a href="#使用异常的父类进行catch" class="headerlink" title="使用异常的父类进行catch"></a>使用异常的父类进行catch</h3><p>FileNotFoundException是Exception的子类，使用Exception也可以catch住FileNotFoundException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多异常捕捉办法1"><a href="#多异常捕捉办法1" class="headerlink" title="多异常捕捉办法1"></a>多异常捕捉办法1</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">new FileInputStream(f)<span class="comment">;</span></span><br><span class="line">Date d <span class="operator">=</span> sdf.parse(<span class="string">&quot;2016-06-03&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这段代码，会抛出 文件不存在异常 FileNotFoundException 和 解析异常ParseException 解决办法之一是分别进行catch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;日期格式解析错误&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2016-06-03&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;日期格式解析错误&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多异常捕捉办法2"><a href="#多异常捕捉办法2" class="headerlink" title="多异常捕捉办法2"></a>多异常捕捉办法2</h3><p>另一个种办法是把多个异常，放在一个catch里统一捕捉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2016-06-03&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException | ParseException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileNotFoundException) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParseException) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;日期格式解析错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>无论是否出现异常，finally中的代码都会被执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无论文件是否存在， 都会执行的代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>考虑如下情况： 主方法调用method1 method1调用method2 method2中打开文件</p>
<p>method2中需要进行异常处理 但是method2<strong>不打算处理</strong>，而是把这个异常通过<em>*throws*<em><strong>抛出去</strong> 那么method1就会</em>*接到该异常</em>*。 处理办法也是两种，要么是try catch处理掉，要么也是<strong>抛出去</strong>。 method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        <span class="comment">//碰见异常方法就结束了，下面就不会执行了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>throws与throw这两个关键字接近，不过意义不一样，有如下区别： \1. throws 出现在方法声明上，而throw通常都出现在方法体内。 \2. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。</p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>异常分类： 可查异常，运行时异常和错误3种 其中，运行时异常和错误又叫非可查异常</p>
<h3 id="可查异常"><a href="#可查异常" class="headerlink" title="可查异常"></a>可查异常</h3><p>可查异常： CheckedException 可查异常即<strong>必须进行处理的异常</strong>，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException 如果不处理，编译器，就不让你通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        File f= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常RuntimeException指： <strong>不是必须进行try catch的异常</strong> <strong>常见运行时异常:</strong> 除数不能为0异常:ArithmeticException 下标越界异常:ArrayIndexOutOfBoundsException 空指针异常:NullPointerException 在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，<strong>即便不进行try catch，也不会有编译错误</strong> Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟糕。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//任何除数不能为0:ArithmeticException</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//下标越界异常：ArrayIndexOutOfBoundsException</span></span><br><span class="line">        <span class="type">int</span> j[] = <span class="keyword">new </span><span class="class title_">int</span>[<span class="number">5</span>];</span><br><span class="line">        j[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//空指针异常：NullPointerException</span></span><br><span class="line">        <span class="built_in">String</span> <span class="built_in">str</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">str</span>.<span class="property">length</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>错误Error，指的是<strong>系统级别的异常</strong>，通常是内存用光了 在<strong>默认设置下</strong>，一般java程序启动的时候，最大可以使用16m的内存 如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出<strong>OutOfMemoryError</strong> 与运行时异常一样，错误也是不要求强制捕捉的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种分类"><a href="#三种分类" class="headerlink" title="三种分类"></a>三种分类</h3><p>总体上异常分三类： \1. 错误 \2. 运行时异常 \3. 可查异常</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110112546216.png" alt="image-20220110112546216"></p>
<p>1.CheckedException：FileNotFoundException ……，必须 throw 或者利用 try …… catch 进行捕获 </p>
<p>2.UnCheckedException（RuntimeException）：NullPointerException …… </p>
<p>3.Error</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">ArithmeticException——由于除数为<span class="number">0</span>引起的异常； </span><br><span class="line">ArrayStoreException——由于数组存储空间不够引起的异常； </span><br><span class="line">ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常； </span><br><span class="line">IllegalMonitorStateException——监控器状态出错引起的异常； </span><br><span class="line">NegativeArraySizeException—一数组长度是负数，则产生异常； </span><br><span class="line">NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常； </span><br><span class="line">OutofMemoryException——用<span class="keyword">new</span><span class="type"></span>语句创建对象时，如系统无法为其分配内存空 间则产生异常； </span><br><span class="line">SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常； </span><br><span class="line">IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常； </span><br><span class="line">IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常； </span><br><span class="line">ClassNotFoundException——未找到指定名字的类或接口引起异常； </span><br><span class="line">CloneNotSupportedException——一程序中的一个对象引用Object类的clone方法，但 此对象并没有连接Cloneable接口，从而引起异常； </span><br><span class="line">InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述； </span><br><span class="line">NoSuchMethodException一所调用的方法未找到，引起异常； </span><br><span class="line">Illega1AccessExcePtion—一试图访问一个非<span class="keyword">public</span>方法； </span><br><span class="line">StringIndexOutOfBoundsException——访问字符串序号越界，引起异常； </span><br><span class="line">ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常； </span><br><span class="line">NumberFormatException——字符的UTF代码数据格式有错引起异常； </span><br><span class="line">IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常； </span><br><span class="line">FileNotFoundException——未找到指定文件引起异常； </span><br><span class="line">EOFException——未完成输入操作即遇文件结束引起异常。</span><br></pre></td></tr></table></figure>

<h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>Throwable是类，Exception和Error都继承了该类 所以在捕捉的时候，也可以使用Throwable进行捕捉 如图： 异常分<strong>Error</strong>和<strong>Exception</strong> Exception里又分<strong>运行时异常</strong>和<strong>可查异常</strong>。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110140710465.png" alt="image-20220110140710465"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h3><p>一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException 创建一个类EnemyHeroIsDeadException，并继承Exception 提供两个构造方法 \1. 无参的构造方法 \2. 带参的构造方法，并调用父类的对应的构造方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EnemyHeroIsDeadException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    public <span class="type">EnemyHeroIsDeadException</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">EnemyHeroIsDeadException</span>(<span class="type">String</span> msg) &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抛出自定义异常"><a href="#抛出自定义异常" class="headerlink" title="抛出自定义异常"></a>抛出自定义异常</h3><p>在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常 \1. 创建一个EnemyHeroIsDeadException实例 \2. 通过<strong>throw</strong> 抛出该异常 \3. 当前方法通过 <strong>throws</strong> 抛出该异常</p>
<p>在外部调用attack方法的时候，就需要进行捕捉，并且捕捉的时候，可以通过e.getMessage() 获取当时出错的具体原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> <span class="keyword">throws</span> EnemyHeroIsDeadException &#123;</span><br><span class="line">        <span class="keyword">if</span> (h.hp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EnemyHeroIsDeadException</span>(h.name + <span class="string">&quot; 已经挂了,不需要施放技能&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EnemyHeroIsDeadException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">EnemyHeroIsDeadException</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">EnemyHeroIsDeadException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        garen.hp = <span class="number">616</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            garen.attackHero(teemo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EnemyHeroIsDeadException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常的具体原因:&quot;</span>+e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h2><h3 id="创建一个文件对象"><a href="#创建一个文件对象" class="headerlink" title="创建一个文件对象"></a>创建一个文件对象</h3><p>使用绝对路径或者相对路径创建File对象</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">file</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestFile &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">// 绝对路径</span></span><br><span class="line">        <span class="keyword">File</span> f1 = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;f:/LOLFolder&quot;</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">&quot;f1的绝对路径：&quot;</span> + f1.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相对路径,相对于工作目录，如果在idea中，就是项目目录</span></span><br><span class="line">        <span class="keyword">File</span> f2 = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;LOL.exe&quot;</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">&quot;f2的绝对路径：&quot;</span> + f2.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把f1作为父目录创建文件对象</span></span><br><span class="line">        <span class="keyword">File</span> f3 = <span class="keyword">new</span> <span class="keyword">File</span>(f1, <span class="string">&quot;LOL.exe&quot;</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">&quot;f3的绝对路径：&quot;</span> + f3.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    f1的绝对路径：f:\LOLFolder</span><br><span class="line">    f2的绝对路径：E:\Javahow2j\LOL.exe</span><br><span class="line">    f3的绝对路径：f:\LOLFolder\LOL.exe</span><br></pre></td></tr></table></figure>

<h3 id="文件常用方法1"><a href="#文件常用方法1" class="headerlink" title="文件常用方法1"></a>文件常用方法1</h3><p><strong>注意1：</strong> 需要在D:\LOLFolder确实存在一个LOL.exe,才可以看到对应的文件长度、修改时间等信息</p>
<p><strong>注意2： renameTo方法用于对物理文件名称进行修改，但是并不会修改File对象的name属性。</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package file;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> TestFile2 &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> <span class="constructor">File(<span class="string">&quot;f:/LOLFolder/LOL.exe&quot;</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;当前文件是：&quot;</span> +f);</span><br><span class="line">        <span class="comment">//文件是否存在</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;判断是否存在：&quot;</span>+f.exists<span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否是文件夹</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;判断是否是文件夹：&quot;</span>+f.is<span class="constructor">Directory()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否是文件（非文件夹）</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;判断是否是文件：&quot;</span>+f.is<span class="constructor">File()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件长度</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;获取文件的长度：&quot;</span>+f.length<span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件最后修改时间</span></span><br><span class="line">        long time = f.last<span class="constructor">Modified()</span>;</span><br><span class="line">        Date d = <span class="keyword">new</span> <span class="constructor">Date(<span class="params">time</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;获取文件的最后修改时间：&quot;</span>+d);</span><br><span class="line">        <span class="comment">//设置文件修改时间为1970.1.1 08:00:00</span></span><br><span class="line">        f.set<span class="constructor">LastModified(0)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件重命名</span></span><br><span class="line">        File f2 =<span class="keyword">new</span> <span class="constructor">File(<span class="string">&quot;f:/LOLFolder/DOTA.exe&quot;</span>)</span>;</span><br><span class="line">        f.rename<span class="constructor">To(<span class="params">f2</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;把LOL.exe改名成了DOTA.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    当前文件是：f:\LOLFolder\<span class="module-access"><span class="module"><span class="identifier">LOL</span>.</span></span>exe</span><br><span class="line">    判断是否存在：<span class="literal">true</span></span><br><span class="line">    判断是否是文件夹：<span class="literal">false</span></span><br><span class="line">    判断是否是文件：<span class="literal">true</span></span><br><span class="line">    获取文件的长度：<span class="number">0</span></span><br><span class="line">    获取文件的最后修改时间：Mon Jan <span class="number">10</span> <span class="number">15</span>:<span class="number">49</span>:<span class="number">14</span> CST <span class="number">2022</span></span><br><span class="line">    把<span class="module-access"><span class="module"><span class="identifier">LOL</span>.</span></span>exe改名成了<span class="module-access"><span class="module"><span class="identifier">DOTA</span>.</span></span>exe</span><br><span class="line">    注意： 需要在D:\LOLFolder确实存在一个<span class="module-access"><span class="module"><span class="identifier">LOL</span>.</span></span>exe,</span><br><span class="line">    才可以看到对应的文件长度、修改时间等信息</span><br></pre></td></tr></table></figure>

<h3 id="文件常用方法2"><a href="#文件常用方法2" class="headerlink" title="文件常用方法2"></a>文件常用方法2</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">file</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestFile2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">File</span> f = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;f:/LOLFolder/skin/garen.ski&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        f.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        <span class="keyword">File</span>[]fs= f.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以字符串形式返回获取所在文件夹</span></span><br><span class="line">        f.getParent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以文件形式返回获取所在文件夹</span></span><br><span class="line">        f.getParentFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，创建就无效</span></span><br><span class="line">        f.mkdir();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹</span></span><br><span class="line">        f.mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个空文件,如果父文件夹skin不存在，就会抛出异常</span></span><br><span class="line">        f.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所以创建一个空文件之前，通常都会创建父目录</span></span><br><span class="line">        f.getParentFile().mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列出所有的盘符c: d: e: 等等</span></span><br><span class="line">        f.listRoots();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刪除文件</span></span><br><span class="line">        f.<span class="keyword">delete</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM结束的时候，刪除文件，常用于临时文件的删除</span></span><br><span class="line">        f.deleteOnExit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><h3 id="什么是流-1"><a href="#什么是流-1" class="headerlink" title="什么是流"></a>什么是流</h3><p>当不同的介质之间有数据交互的时候，JAVA就使用流来实现。 数据源可以是文件，还可以是数据库，网络甚至是其他的程序</p>
<p>比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流 输入流： InputStream 输出流：OutputStream</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110155952110.png" alt="image-20220110155952110"></p>
<h3 id="文件输入流"><a href="#文件输入流" class="headerlink" title="文件输入流"></a>文件输入流</h3><p>如下代码，就建立了一个文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)。</p>
<p>目前代码只是建立了流，还没有开始读取，真正的读取在下个章节讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f/lol.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建基于文件的输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="comment">// 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中</span></span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>InputStream字节输入流 OutputStream字节输出流 用于以字节的形式读取和写入数据</p>
<h3 id="ASCII码-概念"><a href="#ASCII码-概念" class="headerlink" title="ASCII码 概念"></a>ASCII码 概念</h3><p>所有的数据存放在计算机中都是以数字的形式存放的。 所以<strong>字母就需要转换为数字才能够存放</strong>。 比如A就对应的数字65，a对应的数字97. 不同的字母和符号对应不同的数字，就是一张码表。 ASCII是这样的一种码表。 只<strong>包含简单的英文字母</strong>，符号，数字等等。 <strong>不包含中文，德文，俄语等复杂</strong>的。</p>
<p>示例中列出了可见的ASCII码以及对应的十进制和十六进制数字，不可见的暂未列出</p>
<h3 id="以字节流的形式读取文件内容"><a href="#以字节流的形式读取文件内容" class="headerlink" title="以字节流的形式读取文件内容"></a>以字节流的形式读取文件内容</h3><p>InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。 FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建基于文件的输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建字节数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="type">byte</span>[] all = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以字节流的形式读取文件所有内容</span></span><br><span class="line">            fis.read(all);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                <span class="comment">//打印出来是65 66</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次使用完流，都应该进行关闭</span></span><br><span class="line">            fis.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">65</span></span><br><span class="line">    <span class="number">66</span></span><br></pre></td></tr></table></figure>

<h3 id="以字节流的形式向文件写入数据"><a href="#以字节流的形式向文件写入数据" class="headerlink" title="以字节流的形式向文件写入数据"></a>以字节流的形式向文件写入数据</h3><p>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。 FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据</p>
<p>注: 如果文件d:&#x2F;lol2.txt不存在，写出操作会自动创建该文件。 但是如果是文件 d:&#x2F;xyz&#x2F;lol2.txt，而目录xyz又不存在，会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol2.txt其中的内容是空的</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y</span></span><br><span class="line">        <span class="type">byte</span>[] data = &#123;<span class="number">88</span>, <span class="number">89</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建基于文件的输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            <span class="comment">// 把数据写入到输出流</span></span><br><span class="line">            fos.write(data);</span><br><span class="line">            <span class="comment">// 关闭输出流</span></span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭流的方式"><a href="#关闭流的方式" class="headerlink" title="关闭流的方式"></a>关闭流的方式</h2><h3 id="在try中关闭"><a href="#在try中关闭" class="headerlink" title="在try中关闭"></a>在try中关闭</h3><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端； 如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 <strong>不推荐</strong>使用</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestStream2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">File</span> f = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;f:/LOLFolder/lol.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">            fis.<span class="keyword">read</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在try 里关闭流</span></span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在finally中关闭"><a href="#在finally中关闭" class="headerlink" title="在finally中关闭"></a>在finally中关闭</h3><p>这是标准的关闭流的方式 \1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. \2. 在finally关闭之前，要先判断该引用是否为空 \3. 关闭的时候，需要再一次进行try catch处理</p>
<p>这是标准的严谨的关闭流的方式，但是看上去很繁琐，所以写不重要的或者测试代码的时候，都会采用上面的<strong>有隐患</strong>try的方式，因为不麻烦~</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestStream2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">File</span> f = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;f:/LOLFolder/lol.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">            fis.<span class="keyword">read</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在finally 里关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用try-的方式"><a href="#使用try-的方式" class="headerlink" title="使用try()的方式"></a>使用try()的方式</h3><p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭 这种编写代码的方式叫做 <strong>try-with-resources</strong>， 这是从JDK7开始支持的技术</p>
<p>所有的流，都实现了一个接口叫做 <strong>AutoCloseable</strong>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestStream2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">File</span> f = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;f:/LOLFolder/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(f)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">            fis.<span class="keyword">read</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader字符输入流 Writer字符输出流 专门用于字符的形式读取和写入数据</p>
<h3 id="使用字符流读取文件"><a href="#使用字符流读取文件" class="headerlink" title="使用字符流读取文件"></a>使用字符流读取文件</h3><p>FileReader 是Reader子类，以FileReader 为例进行文件读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是AB</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Reader</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="type">char</span>[] all = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">            <span class="comment">// 以字符流的形式读取文件所有内容</span></span><br><span class="line">            fr.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    A</span><br><span class="line">    B</span><br></pre></td></tr></table></figure>

<h3 id="使用字符流把字符串写入到文件"><a href="#使用字符流把字符串写入到文件" class="headerlink" title="使用字符流把字符串写入到文件"></a>使用字符流把字符串写入到文件</h3><p>FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol2.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Writer</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 以字符流的形式把数据写入到文件中</span></span><br><span class="line">            String data=<span class="string">&quot;abcdefg1234567890&quot;</span>;</span><br><span class="line">            <span class="type">char</span>[] cs = data.toCharArray();</span><br><span class="line">            fr.write(cs);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h2><h3 id="编码概念"><a href="#编码概念" class="headerlink" title="编码概念"></a>编码概念</h3><p>计算机存放数据只能存放数字，所有的字符都会被转换为不同的数字。 就像一个棋盘一样，不同的字，处于不同的位置，而不同的位置，有不同的数字编号。 有的棋盘很小，只能放数字和英文 有的大一点，还能放中文 有的“足够”大，能够放下世界人民所使用的所有文字和符号</p>
<p>如图所示，英文字符 <strong>A</strong> 能够放在所有的棋盘里，而且位置都差不多 中文字符, 中文字符 <strong>中</strong> 能够放在后两种棋盘里，并且位置不一样，而且在小的那个棋盘里，就放不下中文</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110165738376.png" alt="image-20220110165738376"></p>
<h3 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h3><p>工作后经常接触的编码方式有如下几种： <strong>ISO-8859-1 ASCII</strong> 数字和西欧字母 <strong>GBK GB2312 BIG5</strong> 中文 <strong>UNICODE</strong> (统一码，万国码)</p>
<p>其中 ISO-8859-1 包含 ASCII GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。 UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中</p>
<h3 id="UNICODE和UTF"><a href="#UNICODE和UTF" class="headerlink" title="UNICODE和UTF"></a>UNICODE和UTF</h3><p>根据前面的学习，我们了解到不同的编码方式对应不同的<strong>棋盘</strong>，而UNICODE因为要存放所有的数据，那么它的棋盘是最大的。 不仅如此，棋盘里每个数字都是很长的(4个字节)，因为不仅要表示字母，还要表示汉字等。</p>
<p>如果完全按照UNICODE的方式来存储数据，就会有很大的浪费。 比如在ISO-8859-1中，<strong>a</strong> 字符对应的数字是0x61 而UNICODE中对应的数字是 0x00000061，倘若一篇文章大部分都是英文字母，那么按照UNICODE的方式进行数据保存就会消耗很多空间</p>
<p>在这种情况下，就出现了UNICODE的各种<strong>减肥</strong>子编码, 比如UTF-8对数字和字母就使用一个字节，而对汉字就使用3个字节，从而达到了<strong>减肥还能保证健康</strong>的效果</p>
<p>UTF-8，UTF-16和UTF-32 针对不同类型的数据有不同的<strong>减肥效果</strong>，一般说来UTF-8是比较常用的方式</p>
<p>UTF-8，UTF-16和UTF-32 彼此的区别在此不作赘述，有兴趣的可以参考 <a href="http://baike.baidu.com/link?url=ty4mEX5hSfK2xAyPO8N2zgxTibBE59CShSb5yFxbVkBun_QVz65llOPEXOepgPeqe3AQDLt6LLjTayn6tioS4_#4">unicode-百度百科</a></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110165956056.png" alt="image-20220110165956056"></p>
<h3 id="Java采用的是Unicode"><a href="#Java采用的是Unicode" class="headerlink" title="Java采用的是Unicode"></a>Java采用的是Unicode</h3><p>写在.java源代码中的汉字，在执行之后，都会变成JVM中的字符。 而这些中文字符采用的编码方式，都是使用UNICODE. “中”字对应的UNICODE是<strong>4E2D</strong>,所以在内存中，实际保存的数据就是十六进制的0x4E2D, 也就是十进制的20013。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">&quot;中&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个汉字使用不同编码方式的表现"><a href="#一个汉字使用不同编码方式的表现" class="headerlink" title="一个汉字使用不同编码方式的表现"></a>一个汉字使用不同编码方式的表现</h3><p>以字符 <strong>中</strong> 为例，查看其在不同编码方式下的值是多少</p>
<p>也即在不同的<strong>棋盘上的位置</strong></p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">UnsupportedEncodingException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">&quot;中&quot;</span>;</span><br><span class="line">        <span class="title function_">showCode</span>(<span class="built_in">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showCode</span>(<span class="built_in">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="built_in">String</span>[] encodes = &#123;<span class="string">&quot;BIG5&quot;</span>, <span class="string">&quot;GBK&quot;</span>, <span class="string">&quot;GB2312&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;UTF-16&quot;</span>, <span class="string">&quot;UTF-32&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">String</span> encode : encodes) &#123;</span><br><span class="line">            <span class="title function_">showCode</span>(<span class="built_in">str</span>, encode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showCode</span>(<span class="built_in">String</span> <span class="built_in">str</span>, <span class="built_in">String</span> encode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.<span class="property">out</span>.<span class="property">printf</span>(<span class="string">&quot;字符: \&quot;%s\&quot; 的在编码方式%s下的十六进制值是%n&quot;</span>, <span class="built_in">str</span>, encode);</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="built_in">str</span>.<span class="property">getBytes</span>(encode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : bs) &#123;</span><br><span class="line">                <span class="type">int</span> i = b&amp;<span class="number">0xff</span>;</span><br><span class="line">                System.<span class="property">out</span>.<span class="property">print</span>(Integer.<span class="property">toHexString</span>(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="property">out</span>.<span class="property">println</span>();</span><br><span class="line">            System.<span class="property">out</span>.<span class="property">println</span>();</span><br><span class="line">        &#125; <span class="title function_">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.<span class="property">out</span>.<span class="property">printf</span>(<span class="string">&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\n&quot;</span>, encode, <span class="built_in">str</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    字符: <span class="string">&quot;中&quot;</span> 的在编码方式BIG5下的十六进制值是</span><br><span class="line">    a4	a4	</span><br><span class="line"></span><br><span class="line">    字符: <span class="string">&quot;中&quot;</span> 的在编码方式GBK下的十六进制值是</span><br><span class="line">    d6	d0	</span><br><span class="line"></span><br><span class="line">    字符: <span class="string">&quot;中&quot;</span> 的在编码方式GB2312下的十六进制值是</span><br><span class="line">    d6	d0	</span><br><span class="line"></span><br><span class="line">    字符: <span class="string">&quot;中&quot;</span> 的在编码方式UTF<span class="number">-8</span>下的十六进制值是</span><br><span class="line">    e4	b8	ad	</span><br><span class="line"></span><br><span class="line">    字符: <span class="string">&quot;中&quot;</span> 的在编码方式UTF<span class="number">-16</span>下的十六进制值是</span><br><span class="line">    fe	ff	<span class="number">4</span>e	<span class="number">2</span>d	</span><br><span class="line"></span><br><span class="line">    字符: <span class="string">&quot;中&quot;</span> 的在编码方式UTF<span class="number">-32</span>下的十六进制值是</span><br><span class="line">    <span class="number">0</span>	<span class="number">0</span>	<span class="number">4</span>e	<span class="number">2</span>d	</span><br></pre></td></tr></table></figure>

<h3 id="文件的编码方式-记事本"><a href="#文件的编码方式-记事本" class="headerlink" title="文件的编码方式-记事本"></a>文件的编码方式-记事本</h3><p>接下来讲，字符在文件中的保存 字符保存在文件中肯定也是以数字形式保存的，即对应在不同的<strong>棋盘</strong>上的不同的数字 用<strong>记事本</strong>打开任意文本文件，并且<strong>另存为</strong>，就能够在编码这里看到一个下拉。 <strong>ANSI</strong> 这个<em>*不是*<em><strong>ASCII</strong>的意思，而是采用</em>*本地编码</em>*的意思。如果你是中文的操作系统，就会使GBK，如果是英文的就会是ISO-8859-1</p>
<p><strong>Unicode</strong> UNICODE原生的编码方式 <strong>Unicode big endian</strong> 另一个 UNICODE编码方式 <strong>UTF-8</strong> 最常见的UTF-8编码方式，数字和字母用一个字节， 汉字用3个字节。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110171246317.png" alt="image-20220110171246317"></p>
<h3 id="用FileInputStream-字节流正确读取中文"><a href="#用FileInputStream-字节流正确读取中文" class="headerlink" title="用FileInputStream 字节流正确读取中文"></a>用FileInputStream 字节流正确读取中文</h3><p>为了能够正确的读取中文内容 \1. 必须了解文本是以哪种编码方式保存字符的 \2. 使用字节流读取了文本后，再使用对应的<strong>编码方式去识别这些数字</strong>，得到正确的字符 如本例，一个文件中的内容是字符<strong>中</strong>，编码方式是GBK，那么读出来的数据一定是D6D0。 再使用GBK编码方式识别D6D0，就能正确的得到字符<strong>中</strong></p>
<p><strong>注：</strong> 在GBK的棋盘上找到的<strong>中</strong>字后，JVM会自动找到<strong>中</strong>在UNICODE这个棋盘上对应的数字，并且以<a href="https://how2j.cn/k/io/io-encoding/695.html#step2486">UNICODE上的数字保存在内存中</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\LOLFolder\\lol.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);) &#123;</span><br><span class="line">            <span class="type">byte</span>[] all = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//文件中读出来的数据是</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件中读出来的数据是：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b&amp;<span class="number">0x000000ff</span>;  <span class="comment">//只取16进制的后两位</span></span><br><span class="line">                System.out.println(Integer.toHexString(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;把这个数字，放在GBK的棋盘上去：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(all,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用FileReader-字符流正确读取中文"><a href="#用FileReader-字符流正确读取中文" class="headerlink" title="用FileReader 字符流正确读取中文"></a>用FileReader 字符流正确读取中文</h3><p>FileReader得到的是字符，所以一定是已经把字节<strong>根据某种编码识别成了字符</strong>了 而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK</p>
<ul>
<li>感觉jdk8好像底层已经变成UTF-8了</li>
</ul>
<p>FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替，像这样：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">InputStreamReader(<span class="params">new</span> FileInputStream(<span class="params">f</span>)</span>,<span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;UTF-8&quot;</span>)</span>); </span><br></pre></td></tr></table></figure>

<p>在本例中，用记事本另存为UTF-8格式，然后用UTF-8就能识别对应的中文了。</p>
<p><strong>解释：</strong> 为什么中字前面有一个? 如果是使用记事本另存为UTF-8的格式，那么在第一个字节有一个<strong>标示符</strong>，叫做BOM用来标志这个文件是用UTF-8来编码的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> TestStream5 &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> <span class="constructor">File(<span class="string">&quot;F:\\LOLFolder\\text.txt&quot;</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;默认编码方式:&quot;</span>+ <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>);</span><br><span class="line">        <span class="comment">//FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了</span></span><br><span class="line">        <span class="comment">//而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK</span></span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> <span class="constructor">FileReader(<span class="params">f</span>)</span>) &#123;</span><br><span class="line">            <span class="built_in">char</span><span class="literal">[]</span> cs = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[(<span class="identifier">int</span>) <span class="identifier">f</span>.<span class="identifier">length</span>()]</span>;</span><br><span class="line">            fr.read(cs);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.printf(<span class="string">&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;</span>,<span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">cs</span>)</span>);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替</span></span><br><span class="line">        <span class="comment">//并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式</span></span><br><span class="line">        <span class="keyword">try</span> (InputStreamReader isr = <span class="keyword">new</span> <span class="constructor">InputStreamReader(<span class="params">new</span> FileInputStream(<span class="params">f</span>)</span>,<span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;UTF-8&quot;</span>)</span>)) &#123;</span><br><span class="line">            <span class="built_in">char</span><span class="literal">[]</span> cs = <span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[(<span class="identifier">int</span>) <span class="identifier">f</span>.<span class="identifier">length</span>()]</span>;</span><br><span class="line">            isr.read(cs);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.printf(<span class="string">&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">cs</span>)</span>);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    默认编码方式:UTF-<span class="number">8</span></span><br><span class="line">    FileReader会使用默认的编码方式UTF-<span class="number">8</span>,识别出来的字符是：</span><br><span class="line">    中  </span><br><span class="line">    InputStreamReader 指定编码方式UTF-<span class="number">8</span>,识别出来的字符是：</span><br><span class="line">    中  </span><br></pre></td></tr></table></figure>

<h2 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h2><p>以介质是硬盘为例，<strong>字节流和字符流的弊端</strong>： 在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。</p>
<p>为了解决以上弊端，采用缓存流。 缓存流在读取的时候，<strong>会一次性读较多的数据到缓存中</strong>，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。</p>
<p>就好比吃饭，<strong>不用缓存就是每吃一口都到锅里去铲</strong>。<strong>用缓存就是先把饭盛到碗里</strong>，碗里的吃完了，再到锅里去铲</p>
<p>缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区<strong>达到一定的量</strong>，才把这些数据，<strong>一起写入到硬盘中去</strong>。按照这种操作模式，就不会像字节流，字符流那样<strong>每写一个字节都访问硬盘</strong>，从而减少了IO操作</p>
<h3 id="使用缓存流读取数据"><a href="#使用缓存流读取数据" class="headerlink" title="使用缓存流读取数据"></a>使用缓存流读取数据</h3><p>缓存字符输入流 BufferedReader 可以一次读取一行数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是</span></span><br><span class="line">        <span class="comment">// garen kill teemo</span></span><br><span class="line">        <span class="comment">// teemo revive after 1 minutes</span></span><br><span class="line">        <span class="comment">// teemo try to garen, but killed again</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建文件字符流</span></span><br><span class="line">        <span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 一次读一行</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == line) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用缓存流写出数据"><a href="#使用缓存流写出数据" class="headerlink" title="使用缓存流写出数据"></a>使用缓存流写出数据</h3><p>PrintWriter 缓存字符输出流， 可以一次写出一行数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 创建文件字符流</span></span><br><span class="line">             <span class="comment">//后面加true可以接着原有的文字加，不然就会覆盖原有文字</span></span><br><span class="line">             <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f, <span class="literal">true</span>);</span><br><span class="line">             <span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">             <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw);) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>有的时候，需要<strong>立即把数据写入到硬盘</strong>，而不是等缓存满了才写出去。 这时候就需要用到flush</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 创建文件字符流</span></span><br><span class="line">             <span class="comment">//后面加true可以接着原有的文字加，不然就会覆盖原有文字</span></span><br><span class="line">             <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f, <span class="literal">true</span>);</span><br><span class="line">             <span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">             <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw);) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.flush();</span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.flush();</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream 数据输入流 DataOutputStream 数据输出流</p>
<h3 id="直接进行字符串的读写"><a href="#直接进行字符串的读写" class="headerlink" title="直接进行字符串的读写"></a>直接进行字符串的读写</h3><p>使用数据流的writeUTF()和readUTF() 可以进行数据的<strong>格式化顺序读写</strong> 如本例，通过DataOutputStream 向文件顺序写出 布尔值，整数和字符串。 然后再通过DataInputStream 顺序读入这些数据。</p>
<p><strong>注：</strong> 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;读取到布尔值:&quot;</span>+b);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到整数:&quot;</span>+i);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到字符串:&quot;</span>+str);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/LOLFolder/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            dos.writeInt(<span class="number">300</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;123 this is gareen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流指的是可以直接<strong>把一个对象以流的形式</strong>传输给其他的介质，比如硬盘</p>
<p>一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口</p>
<h3 id="序列化一个对象"><a href="#序列化一个对象" class="headerlink" title="序列化一个对象"></a>序列化一个对象</h3><p>创建一个Hero对象，设置其名称为garen。 把该对象序列化到一个文件garen.lol。 然后再通过序列化把该文件转换为一个Hero对象</p>
<p><strong>注：</strong>把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Hero garen</span></span><br><span class="line">        <span class="comment">//要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">        h.hp = <span class="number">616</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备一个文件用于保存该对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\LOLFolder\\garen.lol&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建对象输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            oos.writeObject(h);</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span> (Hero)ois.readObject();</span><br><span class="line">            System.out.println(h2.name);</span><br><span class="line">            System.out.println(h2.hp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h2><p>System.out 是常用的在控制台输出数据的 System.in 可以从控制台输入数据</p>
<h3 id="System-in-1"><a href="#System-in-1" class="headerlink" title="System.in"></a>System.in</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 控制台输入</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 敲入a,然后敲回车可以看到</span></span><br><span class="line">                <span class="comment">// 97 13 10</span></span><br><span class="line">                <span class="comment">// 97是a的ASCII码</span></span><br><span class="line">                <span class="comment">// 13 10分别对应回车换行</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> is.read();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scanner读取字符串"><a href="#Scanner读取字符串" class="headerlink" title="Scanner读取字符串"></a>Scanner读取字符串</h3><p>使用System.in.read虽然可以读取数据，但是很不方便 使用Scanner就可以逐行读取了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scanner从控制台读取整数"><a href="#Scanner从控制台读取整数" class="headerlink" title="Scanner从控制台读取整数"></a>Scanner从控制台读取整数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个整数：&quot;</span>+a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个整数：&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流关系图"><a href="#流关系图" class="headerlink" title="流关系图"></a>流关系图</h2><h3 id="流关系图-1"><a href="#流关系图-1" class="headerlink" title="流关系图"></a>流关系图</h3><p>这个图把本章节学到的流关系做了个简单整理 \1. 流分为字节流和字符流 \2. 字节流下面常用的又有数据流和对象流 \3. 字符流下面常用的又有缓存流</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110201229853.png" alt="image-20220110201229853"></p>
<h3 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h3><p>除了上图所接触的流之外，还有很多其他流，如图所示InputStream下面有很多的子类。 这些子类不需要立即掌握，他们大体上用法是差不多的，只是在一些特殊场合下用起来更方便，在工作中用到的时候再进行学习就行了。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220110201316979.png" alt="image-20220110201316979"></p>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="与数组的区别"><a href="#与数组的区别" class="headerlink" title="与数组的区别"></a>与数组的区别</h3><h4 id="使用数组的局限性"><a href="#使用数组的局限性" class="headerlink" title="使用数组的局限性"></a>使用数组的局限性</h4><p>如果要存放多个对象，可以使用数组，但是数组有局限性 比如 声明长度是10的数组 不用的数组就浪费了 超过10的个数，又放不下</p>
<h4 id="ArrayList存放对象"><a href="#ArrayList存放对象" class="headerlink" title="ArrayList存放对象"></a>ArrayList存放对象</h4><p>为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是 ArrayList <a href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step724">容器的容量</a>“capacity”会随着对象的增加，自动增长 只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//容器类ArrayList，用于存放对象</span></span><br><span class="line">        ArrayList heros = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">        System.out.<span class="keyword">println</span>(heros.<span class="keyword">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//容器的容量&quot;capacity&quot;会随着对象的增加，自动增长</span></span><br><span class="line">        <span class="comment">//只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</span></span><br><span class="line">        heros.add( <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>));</span><br><span class="line">        System.out.<span class="keyword">println</span>(heros.<span class="keyword">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p><strong>add</strong> 有两种用法</p>
<p>第一种是直接add对象，把对象加在最后面</p>
<p>第二种是在指定位置加对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把5个对象加入到ArrayList中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(heros);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置增加对象</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">specialHero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">        heros.add(<span class="number">3</span>, specialHero);</span><br><span class="line"></span><br><span class="line">        System.out.println(heros.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个初始化name的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h4><p>通过方法<strong>contains</strong> 判断一个对象是否在容器中 判断标准： 是否是同一个对象，而不是name是否相同</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayList heros = <span class="built_in">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        // 把<span class="number">5</span>个对象加入到ArrayList中</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line"></span><br><span class="line">        // 在指定位置增加对象</span><br><span class="line">        Hero specialHero = <span class="built_in">new</span> Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.<span class="keyword">add</span>(<span class="number">3</span>, specialHero);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros.toString());</span><br><span class="line"></span><br><span class="line">        // 判断一个对象是否在容器中</span><br><span class="line">        // 判断标准： 是否是同一个对象，而不是<span class="type">name</span>是否相同</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.print(&quot;虽然一个新的对象名字也叫 hero 1，但是contains的返回是:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros.contains(<span class="built_in">new</span> Hero(&quot;hero1&quot;)));</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.print(&quot;而对specialHero的判断，contains的返回是:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros.contains(specialHero));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取指定位置的对象"><a href="#获取指定位置的对象" class="headerlink" title="获取指定位置的对象"></a>获取指定位置的对象</h4><p>通过get获取指定位置的对象，如果输入的下标越界，一样会报错</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ArrayList heros = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;hero&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero = <span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">        heros.add(<span class="number">3</span>, specialHero);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定位置的对象</span></span><br><span class="line">        System.out.println(heros.<span class="keyword">get</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//如果超出了范围，依然会报错</span></span><br><span class="line">        System.out.println(heros.<span class="keyword">get</span>(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取对象所处的位置"><a href="#获取对象所处的位置" class="headerlink" title="获取对象所处的位置"></a>获取对象所处的位置</h4><p><strong>indexOf</strong>用于判断一个对象在ArrayList中所处的位置 与<a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2454">contains</a>一样，判断标准是对象是否相同，而非对象的name值是否相等</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayList heros = <span class="built_in">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero = <span class="built_in">new</span> Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.<span class="keyword">add</span>(specialHero);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;specialHero所处的位置:&quot; + heros.indexOf(specialHero));</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;新的英雄，但是名字是\&quot;hero <span class="number">1</span>\&quot;所处的位置:&quot; + heros.indexOf(<span class="built_in">new</span> Hero(&quot;hero1&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    [hero0, hero1, hero2, hero3, hero4, special hero]</span><br><span class="line">	specialHero所处的位置:<span class="number">5</span></span><br><span class="line">	新的英雄，但是名字是&quot;hero 1&quot;所处的位置:<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>remove</strong>用于把对象从ArrayList中删除</p>
<p>remove可以根据下标删除ArrayList的元素</p>
<p>也可以根据对象删除</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayList heros = <span class="built_in">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero = <span class="built_in">new</span> Hero(&quot;special hero&quot;);</span><br><span class="line">        heros.<span class="keyword">add</span>(specialHero);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line">        heros.remove(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line">        heros.remove(specialHero);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替换-1"><a href="#替换-1" class="headerlink" title="替换"></a>替换</h4><p><strong>set</strong>用于替换指定位置的元素</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ArrayList heros = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;hero&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        Hero specialHero = <span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line"></span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        heros.<span class="keyword">set</span>(<span class="number">5</span>, <span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;hero 5&quot;</span>));</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取大小"><a href="#获取大小" class="headerlink" title="获取大小"></a>获取大小</h4><p><strong>size</strong> 用于获取ArrayList的大小</p>
<h4 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h4><p><strong>toArray</strong>可以把一个ArrayList对象转换为数组。 需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">specialHero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">        heros.add(specialHero);</span><br><span class="line"></span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        Hero[] hs = (Hero[])heros.toArray(<span class="keyword">new</span> <span class="title class_">Hero</span>[]&#123;&#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组:&quot;</span> + hs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="把另一个容器所有对象都加进来"><a href="#把另一个容器所有对象都加进来" class="headerlink" title="把另一个容器所有对象都加进来"></a>把另一个容器所有对象都加进来</h4><p><strong>addAll</strong> 把另一个容器所有对象都加进来</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayList heros = <span class="built_in">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        // 初始化<span class="number">5</span>个对象</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;ArrayList heros:\t&quot; + heros);</span><br><span class="line"></span><br><span class="line">        //把另一个容器里所有的元素，都加入到该容器里来</span><br><span class="line">        ArrayList anotherHeros = <span class="built_in">new</span> ArrayList();</span><br><span class="line">        anotherHeros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero a&quot;));</span><br><span class="line">        anotherHeros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero b&quot;));</span><br><span class="line">        anotherHeros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero c&quot;));</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;anotherHeros heros:\t&quot; + anotherHeros);</span><br><span class="line">        heros.addAll(anotherHeros);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;把另一个ArrayList的元素都加入到当前ArrayList:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;ArrayList heros:\t&quot; + heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p><strong>clear</strong> 清空一个ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        heros.clear();</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="ArrayList和List"><a href="#ArrayList和List" class="headerlink" title="ArrayList和List"></a>ArrayList和List</h4><p>ArrayList实现了接口List 常见的写法会把引用声明为接口List类型 注意：是<strong>java.util.List</strong>,而<strong>不是</strong>java.awt.List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ArrayList实现了接口List</span></span><br><span class="line">        <span class="comment">//常见的写法会把引用声明为接口List类型</span></span><br><span class="line">        <span class="comment">//注意：是java.util.List,而不是java.awt.List</span></span><br><span class="line">        <span class="comment">//接口引用指向子类对象（多态）</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="List接口的方法"><a href="#List接口的方法" class="headerlink" title="List接口的方法"></a>List接口的方法</h4><p>因为ArrayList实现了List接口，所以List接口的方法ArrayList都实现了。 在<a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList 常用方法</a>章节有详细的讲解，在此不作赘述</p>
<h3 id="泛型Generic"><a href="#泛型Generic" class="headerlink" title="泛型Generic"></a>泛型Generic</h3><h4 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型 Generic"></a>泛型 Generic</h4><p>不指定泛型的容器，可以存放任何类型的元素 指定了泛型的容器，只能存放指定类型的元素以及其子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">effect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;物品使用后，可以有效果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.APHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"><span class="keyword">import</span> LOL.Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于不使用泛型的容器，可以往里面放英雄，也可以往里面放物品</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本来用于存放英雄的容器，现在也可以存放物品了</span></span><br><span class="line">        heros.add(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;冰杖&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象转型会出现问题</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span> (Hero) heros.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//尤其是在容器里放的对象太多的时候，就记不清楚哪个位置放的是哪种类型的对象了</span></span><br><span class="line">        <span class="comment">//Hero h2=  (Hero) heros.get(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//引入泛型Generic</span></span><br><span class="line">        <span class="comment">//声明容器的时候，就指定了这种容器，只能放Hero，放其他的就会出错</span></span><br><span class="line">        List&lt;Hero&gt; genericheros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        genericheros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">        <span class="comment">//如果不是Hero类型，根本就放不进去</span></span><br><span class="line">        <span class="comment">//genericheros.add(new Item(&quot;冰杖&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//除此之外，还能存放Hero的子类</span></span><br><span class="line">        genericheros.add(<span class="keyword">new</span> <span class="title class_">APHero</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> genericheros.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型的简写"><a href="#泛型的简写" class="headerlink" title="泛型的简写"></a>泛型的简写</h4><p>为了不使编译器出现警告，需要前后都使用泛型，像这样：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">List&lt;Hero&gt; genericheros <span class="operator">=</span> new ArrayList&lt;Hero&gt;()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>不过JDK7提供了一个可以略微减少代码量的泛型简写方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Hero&gt; genericheros2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.APHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"><span class="keyword">import</span> LOL.Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Hero&gt; genericheros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        List&lt;Hero&gt; genericheros2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型的系统学习"><a href="#泛型的系统学习" class="headerlink" title="泛型的系统学习"></a>泛型的系统学习</h4><p>泛型的知识还包含 <a href="https://how2j.cn/k/generic/generic-generic-class/374.html">支持泛型的类</a> <a href="https://how2j.cn/k/generic/generic-casting/375.html">泛型转型</a> <a href="https://how2j.cn/k/generic/generic-wildcard/376.html">通配符</a> 这些内容都在<a href="https://how2j.cn/k/generic/generic-generic/373.html">泛型章节</a>详细展开</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="用for循环遍历"><a href="#用for循环遍历" class="headerlink" title="用for循环遍历"></a>用for循环遍历</h4><p>通过前面的学习，知道了可以用size()和get()分别得到大小，和获取指定位置的元素，结合for循环就可以遍历出ArrayList的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Hero&gt; heroes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heroes.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero name &quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种遍历 for循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------for 循环-------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heroes.size(); i++) &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> heroes.get(i);</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h4><p>使用迭代器Iterator遍历集合中的元素</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111135158788.png" alt="image-20220111135158788"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Hero&gt; heroes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heroes.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero name &quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种遍历，使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------使用while的iterator-------&quot;</span>);</span><br><span class="line">        Iterator&lt;Hero&gt; it = heroes.iterator();</span><br><span class="line">        <span class="comment">//从最开始的位置判断&quot;下一个&quot;位置是否有数据</span></span><br><span class="line">        <span class="comment">//如果有就通过next取出来，并且把指针向下移动</span></span><br><span class="line">        <span class="comment">//直到&quot;下一个&quot;位置没有数据</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器的for写法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------使用for的iterator-------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Hero&gt; iterator = heroes.iterator(); iterator.hasNext(); )&#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用增强型for循环"><a href="#用增强型for循环" class="headerlink" title="用增强型for循环"></a>用增强型for循环</h4><p>使用增强型for循环可以非常方便的遍历ArrayList中的元素，这是很多开发人员的首选。</p>
<p>不过增强型for循环也有不足： 无法用来进行ArrayList的初始化 无法得知当前是第几个元素了，当需要只打印单数元素的时候，就做不到了。 必须再自定下标变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Hero&gt; heroes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heroes.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero name &quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种，增强型for循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------增强型for循环-------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Hero h : heroes) &#123;</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他集合"><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h2><h3 id="LinkedList-与-List接口"><a href="#LinkedList-与-List接口" class="headerlink" title="LinkedList 与 List接口"></a>LinkedList 与 List接口</h3><p>与<a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList</a>一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。 详细使用，请参考 <a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList 常用方法</a>，在此不作赘述。</p>
<p>接下来要讲的是LinkedList的一些特别的地方</p>
<h3 id="双向链表-Deque"><a href="#双向链表-Deque" class="headerlink" title="双向链表 - Deque"></a>双向链表 - Deque</h3><p>除了实现了List接口外，LinkedList还实现了<strong>双向链表结构</strong>Deque，可以很方便的在头尾插入删除数据</p>
<p>什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，不用关心除此之外的其他佛珠在哪里。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111140747126.png" alt="image-20220111140747126"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import LOL.Hero;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="comment">//LinkedList是一个双向链表结构的list</span></span><br><span class="line">        LinkedList&lt;Hero&gt; ll = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以可以很方便的在头部和尾部插入数据</span></span><br><span class="line">        <span class="comment">//在最后插入新的英雄</span></span><br><span class="line">        ll.add<span class="constructor">Last(<span class="params">new</span> Hero(<span class="string">&quot;hero1&quot;</span>)</span>);</span><br><span class="line">        ll.add<span class="constructor">Last(<span class="params">new</span> Hero(<span class="string">&quot;hero2&quot;</span>)</span>);</span><br><span class="line">        ll.add<span class="constructor">Last(<span class="params">new</span> Hero(<span class="string">&quot;hero3&quot;</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在最前面插入新的英雄</span></span><br><span class="line">        ll.add<span class="constructor">First(<span class="params">new</span> Hero(<span class="string">&quot;heroX&quot;</span>)</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最前面的英雄</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll.get<span class="constructor">First()</span>);</span><br><span class="line">        <span class="comment">//查看最后面的英雄</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll.get<span class="constructor">Last()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看不会导致英雄被删除</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll);</span><br><span class="line">        <span class="comment">//取出最前面的英雄</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll.remove<span class="constructor">First()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出最后面的英雄</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll.remove<span class="constructor">Last()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出会导致英雄被删除</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 - Queue"></a>队列 - Queue</h4><p>LinkedList 除了实现了List和Deque外，还实现了<strong>Queue</strong>接口(队列)。 Queue是先进先出队列 <strong>FIFO</strong>，常用方法： <strong>offer</strong> 在最后添加元素 <strong>poll</strong> 取出第一个元素 <strong>peek</strong> 查看第一个元素</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//和ArrayList一样，LinkedList也实现了List接口</span></span><br><span class="line">        List ll = <span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口</span></span><br><span class="line">        <span class="comment">//Queue代表FIFO 先进先出的队列</span></span><br><span class="line">        Queue&lt;Hero&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加在队列的最后面</span></span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">&quot;初始化队列：\t&quot;</span>);</span><br><span class="line">        q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero3&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero4&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.<span class="keyword">println</span>(q);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">&quot;把第一个元素取poll()出来:\t&quot;</span>);</span><br><span class="line">        <span class="comment">//取出第一个Hero，FIFO 先进先出</span></span><br><span class="line">        Hero h = q.poll();</span><br><span class="line">        System.out.<span class="keyword">println</span>(h);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">&quot;取出第一个元素之后的队列:\t&quot;</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把第一个拿出来看一看，但是不取出来</span></span><br><span class="line">        h = q.peek();</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">&quot;查看peek()第一个元素:\t&quot;</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(h);</span><br><span class="line">        System.out.<span class="keyword">print</span>(<span class="string">&quot;查看并不会导致第一个元素被取出来:\t&quot;</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-与-LinkedList的区别"><a href="#ArrayList-与-LinkedList的区别" class="headerlink" title="ArrayList 与 LinkedList的区别"></a>ArrayList 与 LinkedList的区别</h4><p>ArrayList 与 LinkedList的区别是面试常常会问到的考题 具体区别，详见 <a href="https://how2j.cn/k/collection/collection-arraylist-vs-linkedlist/690.html">ArrayList 与 LinkedList的区别</a></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h4><p>二叉树由各种<strong>节点</strong>组成 二叉树特点： 每个节点都可以有<strong>左子</strong>节点，<strong>右子</strong>节点 每一个节点都有一个<strong>值</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111143846421.png" alt="image-20220111143846421"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树排序-插入数据"><a href="#二叉树排序-插入数据" class="headerlink" title="二叉树排序-插入数据"></a>二叉树排序-插入数据</h4><p>假设通过二叉树对如下10个随机数进行排序 67,7,30,73,10,0,78,81,10,74 排序的第一个步骤是把数据插入到该二叉树中 插入基本逻辑是，<strong>小、相同的放左边</strong>，<strong>大的放右边</strong> \1. 67 放在根节点 \2. 7 比 67小，放在67的左节点 \3. 30 比67 小，找到67的左节点7，30比7大，就放在7的右节点 \4. 73 比67大， 放在67的右节点 \5. 10 比 67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，放在30的左节点。 … … \9. 10比67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，找到30的左节点10，10和10一样大，放在左边</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111144534819.png" alt="image-20220111144534819"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Node</span> leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Node</span> rightNode;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">Object</span> v</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有值，就把数据放在当前节点上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新增的值，比当前值小或者相同</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="title class_">Integer</span>)v - (<span class="title class_">Integer</span>)value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == leftNode) &#123;</span><br><span class="line">                    leftNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                leftNode.<span class="title function_">add</span>(v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新增的值，比当前值大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == rightNode) &#123;</span><br><span class="line">                    rightNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                rightNode.<span class="title function_">add</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        int[] randoms = <span class="keyword">new</span> int[] &#123;<span class="number">67</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">10</span>, <span class="number">74</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="title class_">Node</span> roots = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (int <span class="built_in">number</span> : randoms) &#123;</span><br><span class="line">            roots.<span class="title function_">add</span>(<span class="built_in">number</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树排序-遍历"><a href="#二叉树排序-遍历" class="headerlink" title="二叉树排序-遍历"></a>二叉树排序-遍历</h4><p>通过上一个步骤的插入行为，实际上，数据就已经排好序了。 接下来要做的是看，把<strong>这些已经排好序的数据</strong>，遍历成我们常用的List或者数组的形式</p>
<p>二叉树的遍历分左序，中序，右序 <strong>左序</strong>即： 中间的数遍历后放在<strong>左边</strong> <strong>中序</strong>即： 中间的数遍历后放在<strong>中间</strong> <strong>右序</strong>即： 中间的数遍历后放在<strong>右边</strong> 如图所见，我们希望遍历后的结果是从小到大的，所以应该采用<strong>中序遍历</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111150418422.png" alt="image-20220111150418422"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">ArrayList</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Node</span> leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Node</span> rightNode;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">Object</span> v</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有值，就把数据放在当前节点上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新增的值，比当前值小或者相同</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="title class_">Integer</span>)v - (<span class="title class_">Integer</span>)value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == leftNode) &#123;</span><br><span class="line">                    leftNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                leftNode.<span class="title function_">add</span>(v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新增的值，比当前值大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == rightNode) &#123;</span><br><span class="line">                    rightNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                rightNode.<span class="title function_">add</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历所有的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">List</span>&lt;<span class="title class_">Object</span>&gt; <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">Object</span>&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左节点的遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != leftNode) &#123;</span><br><span class="line">            values.<span class="title function_">addAll</span>(leftNode.<span class="title function_">values</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        values.<span class="title function_">add</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右节点的遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rightNode) &#123;</span><br><span class="line">            values.<span class="title function_">addAll</span>(rightNode.<span class="title function_">values</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        int[] randoms = <span class="keyword">new</span> int[] &#123;<span class="number">67</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">10</span>, <span class="number">74</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Node</span> roots = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (int <span class="built_in">number</span> : randoms) &#123;</span><br><span class="line">            roots.<span class="title function_">add</span>(<span class="built_in">number</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(roots.<span class="title function_">values</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap的键值对"><a href="#HashMap的键值对" class="headerlink" title="HashMap的键值对"></a>HashMap的键值对</h4><p>HashMap储存数据的方式是—— 键值对</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; <span class="keyword">dictionary</span> = <span class="built_in">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">dictionary</span>.put(&quot;abc&quot;, &quot;物理英雄&quot;);</span><br><span class="line">        <span class="keyword">dictionary</span>.put(&quot;apc&quot;, &quot;魔法英雄&quot;);</span><br><span class="line">        <span class="keyword">dictionary</span>.put(&quot;t&quot;, &quot;坦克&quot;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">dictionary</span>.<span class="keyword">get</span>(&quot;t&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键不能重复，值可以重复"><a href="#键不能重复，值可以重复" class="headerlink" title="键不能重复，值可以重复"></a>键不能重复，值可以重复</h4><p>对于HashMap而言，key是唯一的，不可以重复的。 所以，<strong>以相同的key 把不同的value插入到 Map中会导致旧元素被覆盖，只留下最后插入的元素</strong> 不过，同一个对象可以作为值插入到map中，只要对应的key不一样</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        HashMap&lt;<span class="keyword">String</span>, Hero&gt; heroMap = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        heroMap.put(<span class="string">&quot;gareen&quot;</span>, <span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;gareen1&quot;</span>));</span><br><span class="line">        System.out.println(heroMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key为gareen已经有value了，再以gareen作为key放入数据，会导致原英雄，被覆盖</span></span><br><span class="line">        <span class="comment">//不会增加新的元素到Map中</span></span><br><span class="line">        heroMap.put(<span class="string">&quot;gareen&quot;</span>, <span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;gareen2&quot;</span>));</span><br><span class="line">        System.out.println(heroMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空map</span></span><br><span class="line">        heroMap.clear();</span><br><span class="line">        System.out.println(heroMap.size());</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> <span class="type">Hero</span>(<span class="string">&quot;gareen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同一个对象可以作为值插入到map中，只要对应的key不一样</span></span><br><span class="line">        heroMap.put(<span class="string">&quot;hero1&quot;</span>, gareen);</span><br><span class="line">        heroMap.put(<span class="string">&quot;hero2&quot;</span>, gareen);</span><br><span class="line"></span><br><span class="line">        System.out.println(heroMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h4 id="元素不能重复"><a href="#元素不能重复" class="headerlink" title="元素不能重复"></a>元素不能重复</h4><p>Set中的元素，不能重复(是利用了equals判断重复的，所以就算new String(“gareen”);也插不进去</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        HashSet&lt;<span class="keyword">String</span>&gt; names = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        names.add(<span class="string">&quot;gareen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次插入同样的数据，是插不进去的，容器中只会保留一个</span></span><br><span class="line">        names.add(<span class="keyword">new</span> <span class="type">String</span>(<span class="string">&quot;gareen&quot;</span>));</span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="没有顺序"><a href="#没有顺序" class="headerlink" title="没有顺序"></a>没有顺序</h4><p>Set中的元素，没有顺序。 严格的说，是没有按照元素的插入顺序排列</p>
<p>HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。关于hashcode有专门的章节讲解: <a href="https://how2j.cn/k/collection/collection-hashcode/371.html">hashcode 原理</a>。</p>
<p>以下是<strong>HashSet源代码</strong>中的部分注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It makes no guarantees as to the iteration order of the set; </span></span><br><span class="line"><span class="comment"> * in particular, it does not guarantee that the order will remain constant over time. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样</span></span><br></pre></td></tr></table></figure>

<p>换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种<strong>臆测的顺序</strong>，这个顺序本身是<strong>不稳定的</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCollection</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        numbers.<span class="keyword">add</span>(<span class="number">99</span>);</span><br><span class="line">        numbers.<span class="keyword">add</span>(<span class="number">55</span>);</span><br><span class="line">        numbers.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set中的元素排列，不是按照插入顺序</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    [<span class="meta">1, 99, 55</span>]</span><br></pre></td></tr></table></figure>

<h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>Set不提供get()来获取指定位置的元素 所以遍历需要用到迭代器，或者增强型for循环</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;<span class="type">Integer</span>&gt; numbers = <span class="built_in">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            numbers.<span class="keyword">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //<span class="keyword">Set</span>不提供<span class="keyword">get</span>方法来获取指定位置的元素</span><br><span class="line">        //numbers.<span class="keyword">get</span>(<span class="number">0</span>)</span><br><span class="line">        //遍历<span class="keyword">Set</span>可以采用迭代器iterator</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;<span class="type">Integer</span>&gt; iterator = numbers.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">Integer</span> i = iterator.next();</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //或者采用增强型<span class="keyword">for</span>循环</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Integer</span> i : numbers) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashSet和HashMap的关系"><a href="#HashSet和HashMap的关系" class="headerlink" title="HashSet和HashMap的关系"></a>HashSet和HashMap的关系</h4><p>通过观察HashSet的源代码（<a href="https://how2j.cn/k/helloworld/helloworld-eclipse-tips/300.html#step706">如何查看源代码</a>） 可以发现HashSet自身并没有独立的实现，而是在里面封装了一个Map. HashSet是作为Map的key而存在的 而value是一个命名为PRESENT的static的Object对象，因为是一个类属性，所以只会有一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.AbstractSet;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//HashSet里封装了一个HashMap</span></span><br><span class="line">    <span class="keyword">private</span>  HashMap&lt;E,Object&gt; map;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的构造方法初始化这个HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向HashSet中增加元素，其实就是把该元素作为key，增加到Map中</span></span><br><span class="line">    <span class="comment">//value是PRESENT，静态，final的对象，所有的HashSet都使用这么同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的size就是map的size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//清空Set就是清空Map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//迭代Set,就是把Map的键拿出来迭代</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection是一个接口</p>
<p>Collection是 Set List Queue和 Deque的接口 Queue: 先进先出队列 Deque: 双向链表</p>
<p><strong>注：</strong>Collection和Map之间没有关系，Collection是放一个一个对象的，Map 是放键值对的 <strong>注：</strong>Deque 继承 Queue,间接的继承了 Collection</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111181358186.png" alt="image-20220111181358186"></p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类</p>
<h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><p><strong>reverse</strong> 使List中的数据发生翻转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">        Collections.reverse(numbers);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p><strong>shuffle</strong> 混淆List中数据的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">        Collections.shuffle(numbers);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p><strong>sort</strong> 对List中的数据进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">        Collections.shuffle(numbers);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">        Collections.sort(numbers);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p><strong>swap</strong> 交换两个数据的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">        Collections.swap(numbers, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p><strong>rotate</strong> 把List中的数据，向右滚动指定单位的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">        <span class="keyword">import</span> java.util.Collection;</span><br><span class="line">        <span class="keyword">import</span> java.util.Collections;</span><br><span class="line">        <span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">        Collections.rotate(numbers, <span class="number">2</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全化"><a href="#线程安全化" class="headerlink" title="线程安全化"></a>线程安全化</h4><p><strong>synchronizedList</strong> 把非线程安全的List转换为线程安全的List。 因为截至目前为止，还没有学习<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全</a>的内容，暂时不展开。 线程安全的内容将在<a href="https://how2j.cn/k/thread/thread-start/353.html">多线程</a>章节展开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;)Collections.synchronizedList(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关系与区别"><a href="#关系与区别" class="headerlink" title="关系与区别"></a>关系与区别</h2><h3 id="ArrayList-和-HasetSet"><a href="#ArrayList-和-HasetSet" class="headerlink" title="ArrayList 和 HasetSet"></a>ArrayList 和 HasetSet</h3><h4 id="是否有顺序"><a href="#是否有顺序" class="headerlink" title="是否有顺序"></a>是否有顺序</h4><p>ArrayList: 有顺序 HashSet: 无顺序</p>
<p>HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。关于hashcode有专门的章节讲解: <a href="https://how2j.cn/k/collection/collection-hashcode/371.html">hashcode 原理</a>。</p>
<p>以下是<strong>HasetSet源代码</strong>中的部分注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It makes no guarantees as to the iteration order of the set; </span></span><br><span class="line"><span class="comment"> * in particular, it does not guarantee that the order will remain constant over time. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样</span></span><br></pre></td></tr></table></figure>

<p>换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种<strong>臆测的顺序</strong>，这个顺序本身是<strong>不稳定的</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">Integer</span>&gt; numberList = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        //List中的数据按照插入顺序存放</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;----------List----------&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;向List 中插入 9 5 1&quot;);</span><br><span class="line">        numberList.<span class="keyword">add</span>(<span class="number">9</span>);</span><br><span class="line">        numberList.<span class="keyword">add</span>(<span class="number">5</span>);</span><br><span class="line">        numberList.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;List 按照顺序存放数据:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberList);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;----------Set----------&quot;);</span><br><span class="line">        HashSet&lt;<span class="type">Integer</span>&gt; numberSet = <span class="built_in">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;向Set 中插入9 5 1&quot;);</span><br><span class="line">        //<span class="keyword">Set</span>中的数据不是按照插入顺序存放</span><br><span class="line">        numberSet.<span class="keyword">add</span>(<span class="number">9</span>);</span><br><span class="line">        numberSet.<span class="keyword">add</span>(<span class="number">5</span>);</span><br><span class="line">        numberSet.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Set 不是按照顺序存放数据:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="comment">----------List----------</span></span><br><span class="line">    向List 中插入 <span class="number">9</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">    List 按照顺序存放数据:</span><br><span class="line">    [<span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="comment">----------Set----------</span></span><br><span class="line">    向<span class="keyword">Set</span> 中插入<span class="number">9</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">Set</span> 不是按照顺序存放数据:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h4 id="能否重复"><a href="#能否重复" class="headerlink" title="能否重复"></a>能否重复</h4><p>List中的数据可以重复 Set中的数据不能够重复 重复判断标准是: 首先看hashcode是否相同 如果hashcode不同，则认为是不同数据 如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据 更多关系hashcode，请参考<a href="https://how2j.cn/k/collection/collection-hashcode/371.html">hashcode原理</a></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        ArrayList&lt;<span class="type">Integer</span>&gt; numberList =<span class="built_in">new</span> ArrayList&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        //List中的数据可以重复</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;----------List----------&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;向List 中插入 9 9&quot;);</span><br><span class="line">        numberList.<span class="keyword">add</span>(<span class="number">9</span>);</span><br><span class="line">        numberList.<span class="keyword">add</span>(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;List 中出现两个9:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberList);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;----------Set----------&quot;);</span><br><span class="line">        HashSet&lt;<span class="type">Integer</span>&gt; numberSet =<span class="built_in">new</span> HashSet&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;向Set 中插入9 9&quot;);</span><br><span class="line">        //<span class="keyword">Set</span>中的数据不能重复</span><br><span class="line">        numberSet.<span class="keyword">add</span>(<span class="number">9</span>);</span><br><span class="line">        numberSet.<span class="keyword">add</span>(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Set 中只会保留一个9:&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberSet);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h3><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p>ArrayList <strong>插入，删除数据慢</strong> LinkedList， <strong>插入，删除数据快</strong> ArrayList是顺序结构，所以<strong>定位很快</strong>，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。 LinkedList 是链表结构，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以<strong>定位慢</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111183737129.png" alt="image-20220111183737129"></p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; l;</span><br><span class="line">        l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        insertFirst(l, <span class="string">&quot;ArrayList&quot;</span>);</span><br><span class="line"></span><br><span class="line">        l = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        insertFirst(l, <span class="string">&quot;LinkedList&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertFirst</span><span class="params">(List&lt;Integer&gt; l, String type)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            l.add(<span class="number">0</span>, number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">&quot;在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n&quot;</span>, type, total, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    在ArrayList 最前面插入<span class="number">100000</span>条数据，总共耗时 <span class="number">1289</span> 毫秒 </span><br><span class="line">	在LinkedList 最前面插入<span class="number">100000</span>条数据，总共耗时 <span class="number">4</span> 毫秒 </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="定位数据"><a href="#定位数据" class="headerlink" title="定位数据"></a>定位数据</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        List&lt;<span class="type">Integer</span>&gt; l;</span><br><span class="line">        l = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        modify(l, &quot;ArrayList&quot;);</span><br><span class="line"></span><br><span class="line">        l = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        modify(l, &quot;LinkedList&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static <span class="type">void</span> modify(List&lt;<span class="type">Integer</span>&gt; l, String <span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">100</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">index</span> = total/<span class="number">2</span>;</span><br><span class="line">        final <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">        //初始化</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            l.<span class="keyword">add</span>(number);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long start = <span class="keyword">System</span>.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="type">int</span> n = l.<span class="keyword">get</span>(<span class="keyword">index</span>);</span><br><span class="line">            n++;</span><br><span class="line">            l.<span class="keyword">set</span>(<span class="keyword">index</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        long end = <span class="keyword">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.printf(&quot;%s总长度是%d，定位到第%d个数据，取出来，加1，再放回去%n 重复%d遍，总共耗时 %d 毫秒 %n&quot;, <span class="keyword">type</span>,total, <span class="keyword">index</span>,total, <span class="keyword">end</span> - <span class="keyword">start</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    ArrayList总长度是<span class="number">100000</span>，定位到第<span class="number">50000</span>个数据，取出来，加<span class="number">1</span>，再放回去</span><br><span class="line">     重复<span class="number">100000</span>遍，总共耗时 <span class="number">4</span> 毫秒 </span><br><span class="line"></span><br><span class="line">    LinkedList总长度是<span class="number">100000</span>，定位到第<span class="number">50000</span>个数据，取出来，加<span class="number">1</span>，再放回去</span><br><span class="line">     重复<span class="number">100000</span>遍，总共耗时 <span class="number">19169</span> 毫秒 </span><br></pre></td></tr></table></figure>

<h3 id="HashMap-和-Hashtable"><a href="#HashMap-和-Hashtable" class="headerlink" title="HashMap 和 Hashtable"></a>HashMap 和 Hashtable</h3><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式 <strong>区别1：</strong> HashMap可以存放 null Hashtable不能存放null <strong>区别2：</strong> HashMap不是<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全的类</a> Hashtable是线程安全的类</p>
<p>鉴于目前学习的进度，不对线程安全做展开，在<a href="https://how2j.cn/k/thread/thread-start/353.html">线程章节</a>会详细讲解</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">//HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式</span></span><br><span class="line">        HashMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; hashMap = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap可以用null作key,作value</span></span><br><span class="line">        hashMap.put(<span class="literal">null</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;123&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; hashtable = <span class="keyword">new</span> <span class="type">Hashtable</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//Hashtable不能用null作key，不能用null作value</span></span><br><span class="line">        <span class="comment">/*hashtable.put(null, &quot;123&quot;);</span></span><br><span class="line"><span class="comment">        hashtable.put(&quot;123&quot;, null);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="几种Set"><a href="#几种Set" class="headerlink" title="几种Set"></a>几种Set</h3><h4 id="HashSet，LinkedHashSet，TreeSet"><a href="#HashSet，LinkedHashSet，TreeSet" class="headerlink" title="HashSet，LinkedHashSet，TreeSet"></a>HashSet，LinkedHashSet，TreeSet</h4><p>HashSet： 无序 LinkedHashSet： 按照插入顺序 TreeSet： 从小到大排序</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;<span class="type">Integer</span>&gt; numberSet1 =<span class="built_in">new</span> HashSet&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        //HashSet中的数据不是按照插入顺序存放</span><br><span class="line">        numberSet1.<span class="keyword">add</span>(<span class="number">88</span>);</span><br><span class="line">        numberSet1.<span class="keyword">add</span>(<span class="number">8</span>);</span><br><span class="line">        numberSet1.<span class="keyword">add</span>(<span class="number">888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberSet1);</span><br><span class="line"></span><br><span class="line">        LinkedHashSet&lt;<span class="type">Integer</span>&gt; numberSet2 =<span class="built_in">new</span> LinkedHashSet&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        //LinkedHashSet中的数据是按照插入顺序存放</span><br><span class="line">        numberSet2.<span class="keyword">add</span>(<span class="number">88</span>);</span><br><span class="line">        numberSet2.<span class="keyword">add</span>(<span class="number">8</span>);</span><br><span class="line">        numberSet2.<span class="keyword">add</span>(<span class="number">888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberSet2);</span><br><span class="line">        TreeSet&lt;<span class="type">Integer</span>&gt; numberSet3 =<span class="built_in">new</span> TreeSet&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        //TreeSet 中的数据是进行了排序的</span><br><span class="line">        numberSet3.<span class="keyword">add</span>(<span class="number">88</span>);</span><br><span class="line">        numberSet3.<span class="keyword">add</span>(<span class="number">8</span>);</span><br><span class="line">        numberSet3.<span class="keyword">add</span>(<span class="number">888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(numberSet3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    [<span class="number">88</span>, <span class="number">8</span>, <span class="number">888</span>]</span><br><span class="line">    [<span class="number">88</span>, <span class="number">8</span>, <span class="number">888</span>]</span><br><span class="line">    [<span class="number">8</span>, <span class="number">88</span>, <span class="number">888</span>]</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="hashcode-原理"><a href="#hashcode-原理" class="headerlink" title="hashcode 原理"></a>hashcode 原理</h3><h4 id="List查找的低效率"><a href="#List查找的低效率" class="headerlink" title="List查找的低效率"></a>List查找的低效率</h4><p>假设在List中存放着无重复名称，没有顺序的2000000个Hero 要把名字叫做“hero 1000000”的对象找出来 List的做法是对每一个进行挨个遍历，直到找到名字叫做“hero 1000000”的英雄。 <strong>最差的情况下，需要遍历和比较2000000次</strong>，才能找到对应的英雄。 测试逻辑： \1. 初始化2000000个对象到ArrayList中 \2. 打乱容器中的数据顺序 \3. 进行10次查询，统计每一次消耗的时间 不同计算机的配置情况下，所花的时间是有区别的。 在本机上，花掉的时间大概是600毫秒左右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2000000</span>; j++) &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero &quot;</span> + j);</span><br><span class="line">            heros.add(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行10次查找，观察大体的平均值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 打乱heros中元素的顺序</span></span><br><span class="line">            Collections.shuffle(heros);</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;Hero 1000000&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hero.name.equals(target)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;找到了 hero!&quot;</span> );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">elapsed</span> <span class="operator">=</span> end - start;</span><br><span class="line">            System.out.println(<span class="string">&quot;一共花了：&quot;</span> + elapsed + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">55</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">68</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">40</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">66</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">9</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">104</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">88</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">22</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">43</span> 毫秒</span><br><span class="line">    找到了 hero!</span><br><span class="line">    一共花了：<span class="number">29</span> 毫秒</span><br></pre></td></tr></table></figure>

<h4 id="HashMap的性能表现"><a href="#HashMap的性能表现" class="headerlink" title="HashMap的性能表现"></a>HashMap的性能表现</h4><p>使用HashMap 做同样的查找 \1. 初始化2000000个对象到HashMap中。 \2. 进行10次查询 \3. 统计每一次的查询消耗的时间 可以观察到，几乎不花时间，花费的时间在1毫秒以内</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestCollection &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,Hero&gt; heroMap = <span class="built_in">new</span> HashMap&lt;String,Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000000</span>; j++) &#123;</span><br><span class="line">            Hero h = <span class="built_in">new</span> Hero(&quot;Hero &quot; + j);</span><br><span class="line">            heroMap.put(h.name, h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;数据准备完成&quot;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            long start = <span class="keyword">System</span>.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            //查找名字是Hero <span class="number">1000000</span>的对象</span><br><span class="line">            Hero target = heroMap.<span class="keyword">get</span>(&quot;Hero 1000000&quot;);</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;找到了 hero!&quot; + target.name);</span><br><span class="line"></span><br><span class="line">            long end = <span class="keyword">System</span>.currentTimeMillis();</span><br><span class="line">            long elapsed = <span class="keyword">end</span> - <span class="keyword">start</span>;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;一共花了：&quot; + elapsed + &quot; 毫秒&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    数据准备完成</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br><span class="line">    找到了 hero!Hero <span class="number">1000000</span></span><br><span class="line">    一共花了：<span class="number">0</span> 毫秒</span><br></pre></td></tr></table></figure>

<h4 id="HashMap原理与字典"><a href="#HashMap原理与字典" class="headerlink" title="HashMap原理与字典"></a>HashMap原理与字典</h4><p>在展开HashMap原理的讲解之前，首先回忆一下大家初中和高中使用的汉英字典。</p>
<p>比如要找一个单词对应的中文意思，假设单词是Lengendary,首先在目录找到Lengendary在第 555页。</p>
<p>然后，翻到第555页，这页不只一个单词，但是量已经很少了，逐一比较，很快就定位目标单词Lengendary。</p>
<p>555相当于就是Lengendary对应的<strong>hashcode</strong></p>
<h4 id="分析HashMap性能卓越的原因"><a href="#分析HashMap性能卓越的原因" class="headerlink" title="分析HashMap性能卓越的原因"></a>分析HashMap性能卓越的原因</h4><p><strong>—–hashcode概念—–</strong> 所有的对象，都有一个对应的<strong>hashcode（散列值）</strong> 比如字符串“gareen”对应的是1001 (实际上不是，这里是方便理解，假设的值) 比如字符串“temoo”对应的是1004 比如字符串“db”对应的是1008 比如字符串“annie”对应的**也**<strong>是1008</strong></p>
<p><strong>—–保存数据—–</strong> 准备一个数组，其长度是2000，并且设定特殊的hashcode算法，使得所有字符串对应的hashcode，都会落在0-1999之间 要存放名字是”gareen”的英雄，就把该英雄和名称组成一个<strong>键值对</strong>，存放在数组的1001这个位置上 要存放名字是”temoo”的英雄，就把该英雄存放在数组的1004这个位置上 要存放名字是”db”的英雄，就把该英雄存放在数组的1008这个位置上 要存放名字是”annie”的英雄，然而 “annie”的hashcode 1008对应的位置<strong>已经有db英雄了</strong>，那么就在这里创建一个链表，<strong>接在db英雄后面存放annie</strong></p>
<p><strong>—–查找数据—–</strong> 比如要查找gareen，首先计算”gareen”的hashcode是1001，根据1001这个下标，到数组中进行定位，（<strong>根据数组下标进行定位，是非常快速的</strong>） 发现1001这个位置就只有一个英雄，那么该英雄就是gareen. 比如要查找annie，首先计算”annie”的hashcode是1008，根据1008这个下标，到数组中进行定位，发现1008这个位置<strong>有两个英雄</strong>，那么就对两个英雄的名字进行逐一比较(<strong>equals</strong>)，因为此时需要比较的量就已经少很多了，很快也就可以找出目标英雄 这就是使用hashmap进行查询，非常快原理。</p>
<p>这是一种用<strong>空间换时间</strong>的思维方式</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111191305319.png" alt="image-20220111191305319"></p>
<h4 id="HashSet判断是否重复"><a href="#HashSet判断是否重复" class="headerlink" title="HashSet判断是否重复"></a>HashSet判断是否重复</h4><p>HashSet的数据是不能重复的，相同数据不能保存在一起，到底如何判断是否是重复的呢？ 根据<a href="https://how2j.cn/k/collection/collection-hashset/364.html#step825">HashSet和HashMap的关系</a>，我们了解到因为HashSet没有自身的实现，而是里面封装了一个HashMap，所以本质上就是判断HashMap的key是否重复。</p>
<p>再通过上一步的学习，key是否重复，是由两个步骤判断的： hashcode是否一样 如果hashcode不一样，就是在<strong>不同的坑里</strong>，一定是不重复的 如果hashcode一样，就是在<strong>同一个坑里</strong>，还需要进行equals比较 如果equals一样，则是重复数据 如果equals不一样，则是不同数据。</p>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>假设Hero有三个属性 name,hp,damage 一个集合中放存放10个Hero,通过Collections.sort对这10个进行排序 那么<strong>到底是hp小的放前面？还是damage小的放前面？</strong>Collections.sort也无法确定 所以要指定到底按照哪种属性进行排序 这里就需要提供一个Comparator给定如何进行两个对象之间的<strong>大小</strong>比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hp=&quot;</span> + hp +</span><br><span class="line">                <span class="string">&quot;, damage=&quot;</span> + damage +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接调用sort会出现编译错误，因为Hero有各种属性</span></span><br><span class="line">        <span class="comment">//到底按照哪种属性进行比较，Collections也不知道，不确定，所以没法排</span></span><br><span class="line">        <span class="comment">//Collections.sort(heros);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//引入Comparator，指定比较的算法</span></span><br><span class="line">        Comparator&lt;Hero&gt; c = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Hero h1, Hero h2)</span> &#123;</span><br><span class="line">                <span class="comment">//按照hp进行排序</span></span><br><span class="line">                <span class="keyword">if</span> (h1.hp &gt;= h2.hp) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//正数表示h1比h2要大</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Collections.sort(heros, c);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><p>使Hero类实现Comparable接口 在类里面提供比较算法 Collections.sort就有足够的信息进行排序了，也无需额外提供比较器Comparator <strong>注：</strong> 如果返回-1, 就表示当前的更小，否则就是更大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hp=&quot;</span> + hp +</span><br><span class="line">                <span class="string">&quot;, damage=&quot;</span> + damage +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (damage &lt; anotherHero.damage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Hero类实现了接口Comparable，即自带比较信息。</span></span><br><span class="line">        <span class="comment">//Collections直接进行排序，无需额外的Comparator</span></span><br><span class="line">        Collections.sort(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照伤害高低排序后的集合: &quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><h4 id="聚合操作-1"><a href="#聚合操作-1" class="headerlink" title="聚合操作"></a>聚合操作</h4><p>JDK8之后，引入了对集合的聚合操作，可以非常容易的遍历，筛选，比较集合中的元素。</p>
<p>像这样：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> name =heros</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted<span class="function"><span class="params">((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    .<span class="title">skip</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    .<span class="title">map</span><span class="params">(h-&gt;h.getName())</span></span></span><br><span class="line"><span class="function">    .<span class="title">findFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    .<span class="title">get</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>

<p>但是要用好聚合，必须先掌握<a href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html">Lambda表达式</a>，聚合的章节讲放在<a href="https://how2j.cn/k/lambda/lambda-stream/700.html">Lambda与聚合操作</a>部分详细讲解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hp=&quot;</span> + hp +</span><br><span class="line">                <span class="string">&quot;, damage=&quot;</span> + damage +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (damage &lt; anotherHero.damage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        Collections.sort(heros,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Hero o1, Hero o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>) (o2.hp-o1.hp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> heros.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过传统方式找出来的hp第三高的英雄名称是:&quot;</span> + hero.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//聚合方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>heros</span><br><span class="line">                .stream()</span><br><span class="line">                .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">                .skip(<span class="number">2</span>)</span><br><span class="line">                .map(h-&gt;h.getName())</span><br><span class="line">                .findFirst()</span><br><span class="line">                .get();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;通过聚合操作找出来的hp第三高的英雄名称是:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="集合中的泛型"><a href="#集合中的泛型" class="headerlink" title="集合中的泛型"></a>集合中的泛型</h2><h3 id="不使用泛型"><a href="#不使用泛型" class="headerlink" title="不使用泛型"></a>不使用泛型</h3><p>不使用泛型带来的问题 ADHero（物理攻击英雄） APHero（魔法攻击英雄）都是Hero的子类 ArrayList 默认接受Object类型的对象，所以所有对象都可以放进ArrayList中 所以get(0) <strong>返回的类型是Object</strong> 接着，需要进行强制转换才可以得到APHero类型或者ADHero类型。 如果软件开发人员记忆比较好，能<strong>记得哪个是哪个</strong>，还是可以的。 但是开发人员会犯错误，比如第20行，会记错，把第0个对象转换为ADHero,这样就会出现类型转换异常</p>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>使用泛型的好处： 泛型的用法是在容器后面添加<Type> Type可以是类，抽象类，接口 泛型表示这种容器，<strong>只能存放APHero</strong>，ADHero就放不进去了。</p>
<h3 id="子类对象"><a href="#子类对象" class="headerlink" title="子类对象"></a>子类对象</h3><p>假设容器的泛型是Hero,那么<strong>Hero的子类</strong>APHero,ADHero<strong>都可以放进去</strong> 和Hero无关的类型Item还是放不进去</p>
<h3 id="泛型的简写-1"><a href="#泛型的简写-1" class="headerlink" title="泛型的简写"></a>泛型的简写</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Hero&gt; heros2 <span class="operator">=</span> new ArrayList&lt;&gt;()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="支持泛型的类"><a href="#支持泛型的类" class="headerlink" title="支持泛型的类"></a>支持泛型的类</h2><h3 id="不支持泛型的Stack"><a href="#不支持泛型的Stack" class="headerlink" title="不支持泛型的Stack"></a>不支持泛型的Stack</h3><p>以<a href="https://how2j.cn/k/collection/collection-linkedlist/370.html#step2475">Stack栈</a>为例子，如果不使用泛型 当需要一个只能放Hero的栈的时候，就需要设计一个HeroStack 当需要一个只能放Item的栈的时候，就需要一个ItemStack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeroStack</span> &#123;</span><br><span class="line">    LinkedList&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        heros.addLast(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Hero <span class="title function_">pull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heros.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Hero <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heros.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeroStack</span> <span class="variable">heroStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroStack</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero name &quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;压入 hero:&quot;</span> + h);</span><br><span class="line">            heroStack.push(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span>heroStack.pull();</span><br><span class="line">            System.out.println(<span class="string">&quot;弹出 hero:&quot;</span> + h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持泛型的Stack"><a href="#支持泛型的Stack" class="headerlink" title="支持泛型的Stack"></a>支持泛型的Stack</h3><p>设计一个支持泛型的栈MyStack 设计这个类的时候，在类的声明上，加上一个<T>，表示该类支持泛型。 T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">LOL</span>.<span class="property">Hero</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">LOL</span>.<span class="property">Item</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">LinkedList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">LinkedList</span>&lt;T&gt; values = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">push</span>(<span class="params">T t</span>) &#123;</span><br><span class="line">        values.<span class="title function_">addLast</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pull</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> values.<span class="title function_">removeLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> values.<span class="title function_">getLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">//在声明这个Stack的时候，使用泛型&lt;Hero&gt;就表示该Stack只能放Hero</span></span><br><span class="line">        <span class="title class_">MyStack</span>&lt;<span class="title class_">Hero</span>&gt; heroMyStack = <span class="keyword">new</span> <span class="title class_">MyStack</span>&lt;&gt;();</span><br><span class="line">        heroMyStack.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Hero</span>());</span><br><span class="line">        <span class="comment">//不能放Item</span></span><br><span class="line">        <span class="comment">//heroMyStack.push(Item);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在声明这个Stack的时候，使用泛型&lt;Item&gt;就表示该Stack只能放Item</span></span><br><span class="line">        <span class="title class_">MyStack</span>&lt;<span class="title class_">Item</span>&gt; itemStack = <span class="keyword">new</span> <span class="title class_">MyStack</span>&lt;&gt;();</span><br><span class="line">        itemStack.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Item</span>());</span><br><span class="line">        <span class="comment">//不能放Hero</span></span><br><span class="line">        <span class="comment">//itemStack.push(new Hero());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h3><p>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型 heroList 的泛型可能是Hero heroList 的泛型可能是APHero heroList 的泛型可能是ADHero 所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p>
<p>但是，不能往里面放东西，因为 放APHero就不满足<ADHero> 放ADHero又不满足<APHero></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111212918775.png" alt="image-20220111212918775"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.ADHero;</span><br><span class="line"><span class="keyword">import</span> LOL.APHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;APHero&gt;();</span><br><span class="line">        apHeroList.add(<span class="keyword">new</span> <span class="type">APHero</span>());</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//? extends Hero 表示这是一个Hero泛型的子类泛型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使APHero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使ADHero</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的</span></span><br><span class="line"></span><br><span class="line">        Hero h= heroList.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是，不能往里面放东西</span></span><br><span class="line">        <span class="comment">//heroList.add(new ADHero()); //编译错误，因为heroList的泛型 有可能是APHero</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="super-1"><a href="#super-1" class="headerlink" title="? super"></a>? super</h3><p>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型 heroList的泛型可能是Hero heroList的泛型可能是Object</p>
<p><strong>可以往里面插入Hero以及Hero的子类</strong> 但是取出来有风险，因为不确定取出来是Hero还是Object</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111213514036.png" alt="image-20220111213514036"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.ADHero;</span><br><span class="line"><span class="keyword">import</span> LOL.APHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//? super Hero 表示 heroList的泛型是Hero或者其父类泛型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以就可以插入Hero</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="type">Hero</span>());</span><br><span class="line">        <span class="comment">//也可以插入Hero的子类</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="type">APHero</span>());</span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="type">ADHero</span>());</span><br><span class="line">        <span class="comment">//不能插入Object</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="type">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败</span></span><br><span class="line">        <span class="comment">//Hero h = heroList.get(0);</span></span><br><span class="line">        <span class="comment">//可以这样取出来</span></span><br><span class="line">        Object h = heroList.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符?"></a>泛型通配符?</h3><p>泛型通配符? 代表任意泛型 既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能</p>
<p>所以只能以Object的形式取出来 并且不能往里面放对象，因为不知道到底是一个什么泛型的容器</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111213719183.png" alt="image-20220111213719183"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.ADHero;</span><br><span class="line"><span class="keyword">import</span> LOL.APHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"><span class="keyword">import</span> LOL.Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;APHero&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//?泛型通配符，表示任意泛型</span></span><br><span class="line">        ArrayList&lt;?&gt; generalList = apHeroList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型</span></span><br><span class="line">        <span class="comment">//所以只能以Object的形式取出来</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> generalList.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item</span></span><br><span class="line">        <span class="comment">//所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去</span></span><br><span class="line">        <span class="comment">//generalList.add(new Item()); //编译错误 因为?代表任意泛型，很有可能不是Item</span></span><br><span class="line">        <span class="comment">//generalList.add(new Hero()); //编译错误 因为?代表任意泛型，很有可能不是Hero</span></span><br><span class="line">        <span class="comment">//generalList.add(new APHero()); //编译错误  因为?代表任意泛型，很有可能不是APHero</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果希望只取出，不插入，就使用? extends Hero 如果希望只插入，不取出，就使用? super Hero 如果希望，又能插入，又能取出，就不要用通配符？</p>
<h2 id="泛型转型"><a href="#泛型转型" class="headerlink" title="泛型转型"></a>泛型转型</h2><h3 id="对象转型-1"><a href="#对象转型-1" class="headerlink" title="对象转型"></a>对象转型</h3><p>根据面向对象学习的知识，<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-casting/308.html#step624">子类转父类</a> 是一定可以成功的</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.ADHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> <span class="type">Hero</span>();</span><br><span class="line">        ADHero ad = <span class="keyword">new</span> <span class="type">ADHero</span>();</span><br><span class="line">        <span class="comment">//子类转父类</span></span><br><span class="line">        h = ad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类泛型转父类泛型"><a href="#子类泛型转父类泛型" class="headerlink" title="子类泛型转父类泛型"></a>子类泛型转父类泛型</h3><p>既然 子类对象 转 父类对象是可以成功的，那么子类泛型转父类泛型能成功吗？ 如代码 hs的泛型是父类Hero adhs 的泛型是子类ADHero</p>
<p>那么 把adhs转换为hs能成功吗？</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.ADHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子类泛型转父类泛型</span></span><br><span class="line">        hs = adhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="假设可以转型成功"><a href="#假设可以转型成功" class="headerlink" title="假设可以转型成功"></a>假设可以转型成功</h3><p>假设可以转型成功 引用hs指向了ADHero泛型的容器 作为Hero泛型的引用hs, 看上去是可以往里面加一个APHero的。 但是hs这个引用，实际上是指向的一个ADHero泛型的容器 如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</p>
<p>所以子类泛型<strong>不可以</strong>转换为父类泛型</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220111214809488.png" alt="image-20220111214809488"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.ADHero;</span><br><span class="line"><span class="keyword">import</span> LOL.APHero;</span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设能转换成功</span></span><br><span class="line">        hs = adhs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//作为Hero泛型的hs,是可以向其中加入APHero的</span></span><br><span class="line">        <span class="comment">//但是hs这个引用，实际上是指向的一个ADHero泛型的容器</span></span><br><span class="line">        <span class="comment">//如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</span></span><br><span class="line">        hs.add(<span class="keyword">new</span> <span class="type">APHero</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><h2 id="Hello-Lambda"><a href="#Hello-Lambda" class="headerlink" title="Hello Lambda"></a>Hello Lambda</h2><h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><p>使用一个普通方法，在for循环遍历中进行条件判断，筛选出满足条件的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hp=&quot;</span> + hp +</span><br><span class="line">                <span class="string">&quot;, damage=&quot;</span> + damage +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (damage &lt; anotherHero.damage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;</span>);</span><br><span class="line">        filter(heros);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List&lt;Hero&gt; heros)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hero.hp &gt; <span class="number">100</span> &amp;&amp; hero.damage &lt; <span class="number">50</span>) &#123;</span><br><span class="line">                System.out.println(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名类方式"><a href="#匿名类方式" class="headerlink" title="匿名类方式"></a>匿名类方式</h3><p>首先准备一个接口HeroChecker，提供一个test(Hero)方法 然后通过匿名类的方式，实现这个接口</p>
<p>接着调用filter，传递这个checker进去进行判断，这种方式就很像通过Collections.sort在对一个Hero集合排序，需要传一个<a href="https://how2j.cn/k/collection/collection-comparator-comparable/693.html#step828">Comparator</a>的匿名类对象进去一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HeroChecker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Hero h)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用匿名类的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;</span>);</span><br><span class="line">        <span class="type">HeroChecker</span> <span class="variable">checker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroChecker</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        filter(heros, checker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List&lt;Hero&gt; heros, HeroChecker checker)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checker.test(hero)) &#123;</span><br><span class="line">                System.out.println(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda方式"><a href="#Lambda方式" class="headerlink" title="Lambda方式"></a>Lambda方式</h3><p>使用Lambda方式筛选出数据</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">filter(heros,<span class="function"><span class="params">(h)</span>-&gt;</span>h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>同样是调用filter方法，从上一步的传递匿名类对象，变成了传递一个Lambda表达式进去</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">h</span>-&gt;h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>咋一看Lambda表达式似乎不好理解，其实很简单，下一步讲解如何从一个匿名类一点点<strong>演变成</strong>Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Lamdba的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;</span>);</span><br><span class="line">        filter(heros, h-&gt;h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List&lt;Hero&gt; heros, HeroChecker checker)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checker.test(hero)) &#123;</span><br><span class="line">                System.out.println(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从匿名类演变成Lambda表达式"><a href="#从匿名类演变成Lambda表达式" class="headerlink" title="从匿名类演变成Lambda表达式"></a>从匿名类演变成Lambda表达式</h3><p>Lambda表达式可以看成是匿名类一点点<strong>演变过来</strong></p>
<p>1.匿名类的正常写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HeroChecker</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroChecker</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.把外面的壳子去掉 只保留<strong>方法参数</strong>和<strong>方法体</strong> 参数和方法体之间加上符号 <strong>-&gt;</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">HeroChecker c2 = <span class="function"><span class="params">(Hero h)</span> -&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.把return和{}去掉</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">HeroChecker c3 = <span class="function"><span class="params">(Hero h)</span> -&gt;</span>h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>4.把 参数类型和圆括号去掉(只有一个参数的时候，才可以去掉圆括号)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HeroChecker</span> c4 = h -&gt;h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>5.把c4作为参数传递进去</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">filter</span>(heros<span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>6.直接把表达式传递进去</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>(heros, h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>与<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a> 概念相比较， Lambda 其实就是<strong>匿名方法</strong>，这是一种<strong>把方法作为参数</strong>进行传递的编程思想。</p>
<p>虽然代码是这么写</p>
<p>但是，Java会在背后，悄悄的，把这些都还原成<a href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html#step2552">匿名类方式</a>。 引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。</p>
<h3 id="Lambda的弊端"><a href="#Lambda的弊端" class="headerlink" title="Lambda的弊端"></a>Lambda的弊端</h3><p>Lambda表达式虽然带来了代码的简洁，但是也有其局限性。 \1. 可读性差，与<strong>啰嗦的</strong>但是<strong>清晰的</strong>匿名类代码结构比较起来，Lambda表达式一旦变得比较长，就难以理解 \2. 不便于调试，很难在Lambda表达式中增加调试信息，比如日志 \3. 版本支持，Lambda表达式在JDK8版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用。</p>
<p>Lambda比较适合用在简短的业务代码中，并不适合用在复杂的系统中，会加大维护成本。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestLambda &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Random r = <span class="built_in">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero &quot; + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line"></span><br><span class="line">        HeroChecker c = <span class="built_in">new</span> HeroChecker() &#123;</span><br><span class="line">            <span class="built_in">public</span> <span class="type">boolean</span> test(Hero h) &#123;</span><br><span class="line">                <span class="keyword">return</span> h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;使用匿名类过滤&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros, h-&gt;h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;在Lambda表达式中使用静态方法&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros, h -&gt; TestLambda.testHero(h));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;直接引用静态方法&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros, TestLambda::testHero);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static <span class="type">boolean</span> testHero(Hero h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static <span class="type">void</span> <span class="keyword">filter</span>(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checker.test(hero)) &#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用对象方法"><a href="#引用对象方法" class="headerlink" title="引用对象方法"></a>引用对象方法</h3><p>与引用静态方法很类似，只是传递方法的时候，需要一个对象的存在</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">TestLambda testLambda = new TestLambda()<span class="comment">;</span></span><br><span class="line">filter(<span class="name">heros</span>, testLambda:<span class="symbol">:testHero</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这种方式叫做<strong>引用对象方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用引用对象方法  的过滤结果：&quot;</span>);</span><br><span class="line">        <span class="comment">//使用类的对象方法</span></span><br><span class="line">        <span class="type">TestLambda</span> <span class="variable">testLambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestLambda</span>();</span><br><span class="line">        filter(heros, testLambda::testHero);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">testHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List&lt;Hero&gt; heros, HeroChecker checker)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checker.test(hero)) &#123;</span><br><span class="line">                System.out.println(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用容器中的对象的方法"><a href="#引用容器中的对象的方法" class="headerlink" title="引用容器中的对象的方法"></a>引用容器中的对象的方法</h3><p>首先为Hero添加一个方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean matched()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.hp&gt;<span class="number">100</span> &amp;&amp; <span class="keyword">this</span>.damage&lt;<span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>(heros,h-&gt; h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span> );</span><br></pre></td></tr></table></figure>

<p>在Lambda表达式中调用容器中的对象Hero的方法matched</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">filter(<span class="name">heros</span>,h-&gt; h.matched() )<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>matched恰好就是容器中的对象Hero的方法，那就可以进一步改写为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>(heros, Hero::matched);</span><br></pre></td></tr></table></figure>

<p>这种方式就叫做<strong>引用容器中的对象的方法</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestLambda &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Random r = <span class="built_in">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero &quot; + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Lambda表达式：&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros,h-&gt; h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Lambda表达式中调用容器中的对象的matched方法：&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros, h -&gt; h.matched());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;引用容器中对象的方法 之过滤结果：&quot;);</span><br><span class="line">        <span class="keyword">filter</span>(heros, Hero::matched);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="type">boolean</span> testHero(Hero h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static <span class="type">void</span> <span class="keyword">filter</span>(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checker.test(hero)) &#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h3><p>有的接口中的方法会返回一个对象，比如<strong>java.util.function.Supplier</strong>提供 了一个get方法，返回一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;List&gt; s = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;List&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> getList(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> getList(()-&gt;<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用构造器</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list3</span> <span class="operator">=</span> getList(ArrayList::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List <span class="title function_">getList</span><span class="params">(Supplier&lt;List&gt; s)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聚合操作-2"><a href="#聚合操作-2" class="headerlink" title="聚合操作"></a>聚合操作</h2><h3 id="传统方式与聚合操作方式遍历数据"><a href="#传统方式与聚合操作方式遍历数据" class="headerlink" title="传统方式与聚合操作方式遍历数据"></a>传统方式与聚合操作方式遍历数据</h3><p>遍历数据的传统方式就是使用for循环，然后条件判断，最后打印出满足条件的数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">   <span class="keyword">if</span> (h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">      <span class="keyword">System</span>.<span class="keyword">out</span>.println(h.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用聚合操作方式，<strong>画风</strong>就发生了变化：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"> heros</span><br><span class="line">	.stream()</span><br><span class="line">	.<span class="keyword">filter</span>(h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">	.<span class="keyword">forEach</span>(h -&gt; <span class="keyword">System</span>.<span class="keyword">out</span>.println(h.name));</span><br><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestAggregate &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Random r = <span class="built_in">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.<span class="keyword">add</span>(<span class="built_in">new</span> Hero(&quot;hero &quot; + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(heros);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;查询条件：hp&gt;100 &amp;&amp; damage&lt;50&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;通过传统操作方式找出满足条件的数据：&quot;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(h.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;通过聚合操作方式找出满足条件的数据：&quot;);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .<span class="keyword">filter</span>(h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">            .<span class="keyword">forEach</span>(h -&gt; <span class="keyword">System</span>.<span class="keyword">out</span>.println(h.name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream和管道的概念"><a href="#Stream和管道的概念" class="headerlink" title="Stream和管道的概念"></a>Stream和管道的概念</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">heros</span><br><span class="line">    .stream<span class="literal">()</span></span><br><span class="line">    .filter(h -&gt; h.hp &gt; <span class="number">100</span><span class="operator"> &amp;&amp; </span>h.damage &lt; <span class="number">50</span>)</span><br><span class="line">    .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>.<span class="params">name</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>要了解聚合操作，首先要建立<strong>Stream</strong>和<strong>管道</strong>的概念 <strong>Stream</strong> 和Collection结构化的数据不一样，Stream是一系列的元素，就像是生产线上的罐头一样，一串串的出来。 <strong>管道</strong>指的是一系列的聚合操作。</p>
<p>管道又分3个部分 <strong>管道源</strong>：在这个例子里，源是一个List <strong>中间操作</strong>： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。 <strong>结束操作</strong>：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断</p>
<p><strong>注：</strong> 这个Stream和I&#x2F;O章节的InputStream,OutputStream是不一样的概念。</p>
<h3 id="管道源"><a href="#管道源" class="headerlink" title="管道源"></a>管道源</h3><p>把Collection切换成管道源很简单，调用stream()就行了。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">heros.stream<span class="comment">()</span></span><br></pre></td></tr></table></figure>

<p>但是数组却没有stream()方法，需要使用</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Arrays.stream<span class="comment">(hs)</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(hs)</span><br><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line">import LOL.Hero;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Array;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> TestAggregate &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> <span class="constructor">Random()</span>;</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="constructor">Hero(<span class="string">&quot;hero &quot;</span> + <span class="params">i</span>, <span class="params">r</span>.<span class="params">nextInt</span>(1000)</span>, r.next<span class="constructor">Int(100)</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//管道源是集合</span></span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>.<span class="params">name</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//管道源是数组</span></span><br><span class="line">        Hero<span class="literal">[]</span> hs = heros.<span class="keyword">to</span><span class="constructor">Array(<span class="params">new</span> Hero[<span class="params">heros</span>.<span class="params">size</span>()</span>]);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>stream(hs)</span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>.<span class="params">name</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。 中间操作比较多，主要分两类 对元素进行筛选 和 转换为其他形式的流 <strong>对元素进行筛选：</strong> filter 匹配 distinct 去除重复(根据equals判断) sorted 自然排序 sorted(Comparator<T>) 指定排序 limit 保留 skip 忽略 <strong>转换为其他形式的流</strong> mapToDouble 转换为double的流 map 转换为任意类型的流</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line">import LOL.Hero;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> TestAggregate &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> <span class="constructor">Random()</span>;</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="constructor">Hero(<span class="string">&quot;hero &quot;</span> + <span class="params">i</span>, <span class="params">r</span>.<span class="params">nextInt</span>(1000)</span>, r.next<span class="constructor">Int(100)</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//制造一个重复数据</span></span><br><span class="line">        heros.add(heros.get(<span class="number">0</span>));</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(heros);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;满足条件hp&gt;100&amp;&amp;damage&lt;50的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .filter(h-&gt;h.hp &gt; <span class="number">100</span><span class="operator"> &amp;&amp; </span>h.damage &lt; <span class="number">50</span>)</span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;去除重复的数据，去除标准是看equals&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .distinct<span class="literal">()</span></span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt;System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;按照血量排序&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .sorted((h1, h2)-&gt;h1.hp &gt;= h2.hp ? <span class="number">1</span> : -<span class="number">1</span>)</span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;保留3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt;System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;忽略前3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .skip(<span class="number">3</span>)</span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt;System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;转换为double的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .map<span class="constructor">ToDouble(Hero::<span class="params">getHp</span>)</span></span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt;System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;转换任意类型的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream<span class="literal">()</span></span><br><span class="line">            .map(h-&gt; h.name + <span class="string">&quot; - &quot;</span> + h.hp + <span class="string">&quot; - &quot;</span> + h.damage)</span><br><span class="line">            .<span class="keyword">for</span><span class="constructor">Each(<span class="params">h</span>-&gt;System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">h</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h3><p>当进行结束操作后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回,。 结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。 常见结束操作如下： <strong>forEach()</strong> 遍历每个元素 <strong>toArray()</strong> 转换为数组 <strong>min(Comparator<T>)</strong> 取最小的元素 <strong>max(Comparator<T>)</strong> 取最大的元素 <strong>count()</strong> 总数 <strong>findFirst()</strong> 第一个元素</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">package lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历集合中的每个数据&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">                .stream()</span><br><span class="line">                .forEach(h-&gt;System.out.<span class="built_in">print</span>(h));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个数组&quot;</span>);</span><br><span class="line">        <span class="built_in">Object</span>[] hs = heros</span><br><span class="line">                .stream()</span><br><span class="line">                .toArray();</span><br><span class="line">        System.out.println(Arrays.toString(hs));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最低的那个英雄&quot;</span>);</span><br><span class="line">        Hero minDamageHero =</span><br><span class="line">                heros</span><br><span class="line">                        .stream()</span><br><span class="line">                        .min<span class="function"><span class="params">((h1, h2)-&gt;h2.damage-h2.damage)</span></span></span><br><span class="line"><span class="function">                        .<span class="title">get</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(minDamageHero)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;返回伤害最高的那个英雄&quot;</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">Hero</span> <span class="title">mxnDamageHero</span> =</span></span><br><span class="line"><span class="function">                <span class="title">heros</span></span></span><br><span class="line"><span class="function">                        .<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                        .<span class="title">max</span><span class="params">((h1,h2)-&gt;h1.damage-h2.damage)</span></span></span><br><span class="line"><span class="function">                        .<span class="title">get</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(mxnDamageHero)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;流中数据的总数&quot;</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">long</span> <span class="title">count</span> =</span></span><br><span class="line"><span class="function">                <span class="title">heros</span></span></span><br><span class="line"><span class="function">                        .<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                        .<span class="title">count</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(count)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">&quot;第一个英雄&quot;</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">Hero</span> <span class="title">firstHero</span> =</span></span><br><span class="line"><span class="function">                <span class="title">heros</span></span></span><br><span class="line"><span class="function">                        .<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                        .<span class="title">findFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                        .<span class="title">get</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(firstHero)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="启动一个线程"><a href="#启动一个线程" class="headerlink" title="启动一个线程"></a>启动一个线程</h2><p>多线程即在同一时间，可以做多件事情。</p>
<p>创建多线程有3种方式，分别是<a href="https://how2j.cn/k/thread/thread-start/353.html#step778">继承线程类</a>,<a href="https://how2j.cn/k/thread/thread-start/353.html#step779">实现Runnable接口</a>,<a href="https://how2j.cn/k/thread/thread-start/353.html#step780">匿名类</a></p>
<h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>首先要理解进程(Processor)和线程(Thread)的区别 <strong>进程：</strong>启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。 <strong>线程：</strong>线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如”盖伦” 击杀“提莫”，<strong>同时</strong>“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。</p>
<p>此处代码演示的是<strong>不使用多线程的情况</strong>： 只有在盖伦杀掉提莫后，赏金猎人才开始杀盲僧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero2 h)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//为了表示攻击需要时间，每次攻击暂停1000毫秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.out.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hero2 gareen= <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//盖伦攻击提莫</span></span><br><span class="line">        <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">            gareen.attackHero(teemo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赏金猎人攻击盲僧</span></span><br><span class="line">        <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">            bh.attackHero(leesin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多线程-继承线程类"><a href="#创建多线程-继承线程类" class="headerlink" title="创建多线程-继承线程类"></a>创建多线程-继承线程类</h3><p>使用多线程，就可以做到盖伦在攻击提莫的<strong>同时</strong>，赏金猎人也在攻击盲僧 设计一个类KillThread <strong>继承Thread</strong>，<strong>并且重写run方法</strong> 启动线程办法： 实例化一个KillThread对象，并且调用其<strong>start</strong>方法 就可以观察到 赏金猎人攻击盲僧的<strong>同时</strong>，盖伦也在攻击提莫</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero2 h)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//为了表示攻击需要时间，每次攻击暂停1000毫秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.out.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Hero2 h1;</span><br><span class="line">    <span class="keyword">private</span> Hero2 h2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KillThread</span><span class="params">(Hero2 h1, Hero2 h2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h1 = h1;</span><br><span class="line">        <span class="built_in">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!h2.isDead()) &#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hero2 gareen= <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>(gareen, teemo);</span><br><span class="line">        killThread1.start();</span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>(bh, leesin);</span><br><span class="line">        killThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多线程-实现Runnable接口"><a href="#创建多线程-实现Runnable接口" class="headerlink" title="创建多线程-实现Runnable接口"></a>创建多线程-实现Runnable接口</h3><p>创建类Battle，实现Runnable接口 启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Battle battle1 = <span class="keyword">new</span> <span class="constructor">Battle(<span class="params">gareen</span>,<span class="params">teemo</span>)</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">battle1</span>)</span>.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。 必须，借助一个线程对象的start()方法，才会启动一个新的线程。 所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battle</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hero2 h1;</span><br><span class="line">    <span class="keyword">private</span> Hero2 h2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Battle(Hero2 h1, Hero2 h2) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h1 = h1;</span><br><span class="line">        <span class="built_in">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!h2.isDead()) &#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Hero2 gareen= <span class="keyword">new</span> <span class="type">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        Hero2 teemo = <span class="keyword">new</span> <span class="type">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        Hero2 bh = <span class="keyword">new</span> <span class="type">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">        Hero2 leesin = <span class="keyword">new</span> <span class="type">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        Battle battle1 = <span class="keyword">new</span> <span class="type">Battle</span>(gareen, teemo);</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(battle1).start();</span><br><span class="line">        Battle battle2 = <span class="keyword">new</span> <span class="type">Battle</span>(bh, leesin);</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(battle2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多线程-匿名类"><a href="#创建多线程-匿名类" class="headerlink" title="创建多线程-匿名类"></a>创建多线程-匿名类</h3><p>使用<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a>，继承Thread,重写run方法，直接在run方法中写业务代码 匿名类的一个好处是可以很方便的访问外部的局部变量。 前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hero2 gareen= <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Hero2</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//匿名类中用到外部的局部变量teemo，必须把teemo声明为final</span></span><br><span class="line">                <span class="comment">//但是在JDK7以后，就不是必须加final的了</span></span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) &#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!leesin.isDead()) &#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多线程的三种方式"><a href="#创建多线程的三种方式" class="headerlink" title="创建多线程的三种方式"></a>创建多线程的三种方式</h3><p>把上述3种方式再整理一下：</p>
<p>\1. 继承Thread类 \2. 实现Runnable接口 \3. 匿名类的方式</p>
<p>注： 启动线程是start()方法，run()并不能启动一个新的线程</p>
<h2 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h2><h3 id="当前线程暂停"><a href="#当前线程暂停" class="headerlink" title="当前线程暂停"></a>当前线程暂停</h3><p>Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响 Thread.sleep(1000); 会抛出InterruptedException 中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出 InterruptedException</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.<span class="keyword">out</span>.printf(<span class="string">&quot;已经玩了LOL %d 秒%n&quot;</span>, seconds++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加入到当前线程中"><a href="#加入到当前线程中" class="headerlink" title="加入到当前线程中"></a>加入到当前线程中</h3><p>首先解释一下<strong>主线程</strong>的概念 所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个<strong>看不见</strong>的主线程存在。 在42行执行t.join，即表明<strong>在主线程中加入该线程</strong>。 主线程会等待该线程结束完毕， 才会往下运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Hero2 gareen= <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) &#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码执行到这里，一直是main线程在运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走</span></span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!leesin.isDead()) &#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会观察到盖伦把提莫杀掉后，才运行t2线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源 为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源 同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示 如图可见，线程1的优先级是MAX_PRIORITY，所以它争取到了更多的CPU资源执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Hero2 gareen= <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">6160</span>;</span><br><span class="line">        gareen.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">3000</span>;</span><br><span class="line">        teemo.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">5000</span>;</span><br><span class="line">        bh.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">4505</span>;</span><br><span class="line">        leesin.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) &#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!leesin.isDead()) &#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="临时暂停"><a href="#临时暂停" class="headerlink" title="临时暂停"></a>临时暂停</h3><p>当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Hero2 gareen= <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">61600</span>;</span><br><span class="line">        gareen.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">30000</span>;</span><br><span class="line">        teemo.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">50000</span>;</span><br><span class="line">        bh.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">45050</span>;</span><br><span class="line">        leesin.damage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) &#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!leesin.isDead()) &#123;</span><br><span class="line">                    <span class="comment">//临时暂停，使得t1可以占用CPU资源</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.setPriority(<span class="number">5</span>);</span><br><span class="line">        t2.setPriority(<span class="number">5</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</p>
<p>就好像一个公司有销售部，生产部这些和业务挂钩的部门。 除此之外，还有后勤，行政等这些支持部门。</p>
<p>如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。</p>
<p>守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。</p>
<p>守护线程通常会被用来做日志，性能统计等工作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> seconds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.<span class="keyword">out</span>.printf(<span class="string">&quot;已经玩了LOL %d 秒%n&quot;</span>, seconds++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题</p>
<p>多线程的问题，又叫<strong>Concurrency</strong> 问题</p>
<h3 id="演示同步问题"><a href="#演示同步问题" class="headerlink" title="演示同步问题"></a>演示同步问题</h3><p>假设盖伦有10000滴血，并且在基地里，同时又被对方多个英雄攻击 就是<strong>有多个线程在减少盖伦的hp</strong> 同时又有<strong>多个线程在恢复盖伦的hp</strong> 假设线程的数量是一样的，并且每次改变的值都是1，那么所有线程结束后，盖伦应该还是10000滴血。 但是。。。</p>
<p><strong>注意</strong>： 不是每一次运行都会看到错误的数据产生，多运行几次，或者增加运行的次数</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span>()</span> &#123;</span><br><span class="line">        hp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hurt</span>()</span> &#123;</span><br><span class="line">        hp -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackHero</span>(<span class="params">Hero2 h</span>)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.<span class="keyword">out</span>.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isDead</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        final Hero2 gareen = <span class="keyword">new</span> Hero2();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">&quot;盖伦的初始血量是 %.0f%n&quot;</span>, gareen.hp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多线程同步问题指的是多个线程同时修改一个数据的时候，导致的问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设盖伦有10000滴血，并且在基地里，同时又被对方多个英雄攻击</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用JAVA代码来表示，就是有多个线程在减少盖伦的hp</span></span><br><span class="line">        <span class="comment">//同时又有多个线程在恢复盖伦的hp</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//n个线程增加盖伦的hp</span></span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">10000</span>;</span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//n个线程减少盖伦的hp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有增加线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有减少线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码执行到这里，所有增加和减少线程都结束了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加和减少线程的数量是一样的，每次都增加，减少1.</span></span><br><span class="line">        <span class="comment">//那么所有线程都结束后，盖伦的hp应该还是初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是事实上观察到的是：</span></span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量变成了 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    盖伦的初始血量是 <span class="number">10000</span></span><br><span class="line">    <span class="number">10000</span>个增加线程和<span class="number">10000</span>个减少线程结束后</span><br><span class="line">    盖伦的血量变成了 <span class="number">9993</span></span><br></pre></td></tr></table></figure>

<h3 id="分析同步问题产生的原因"><a href="#分析同步问题产生的原因" class="headerlink" title="分析同步问题产生的原因"></a>分析同步问题产生的原因</h3><p>\1. 假设<strong>增加线程</strong>先进入，得到的hp是10000 \2. 进行增加运算 \3. 正在做增加运算的时候，<strong>还没有来得及修改hp的值</strong>，<strong>减少线程</strong>来了 \4. 减少线程得到的hp的值也是10000 \5. 减少线程进行减少运算 \6. 增加线程运算结束，得到值10001，并把这个值赋予hp \7. 减少线程也运算结束，得到值9999，并把这个值赋予hp hp，最后的值就是9999 虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999 这个时候的值9999是一个错误的值，在业务上又叫做<strong>脏数据</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112202706177.png" alt="image-20220112202706177"></p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>总体解决思路是： 在增加线程访问hp期间，其他线程不可以访问hp \1. 增加线程获取到hp的值，并进行运算 \2. 在运算期间，减少线程试图来获取hp的值，但是<strong>不被允许</strong> \3. 增加线程运算结束，并成功修改hp的值为10001 \4. 减少线程，在增加线程做完后，才能访问hp的值，即10001 \5. 减少线程运算，并得到新的值10000</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112202918357.png" alt="image-20220112202918357"></p>
<h3 id="synchronized-同步对象概念"><a href="#synchronized-同步对象概念" class="headerlink" title="synchronized 同步对象概念"></a>synchronized 同步对象概念</h3><p>解决上述问题之前，先理解 <strong>synchronized</strong>关键字的意义 如下代码：</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span> <span class="variable">someObject</span> <span class="operator">=</span> <span class="variable">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">synchronized</span> (<span class="variable">someObject</span>)&#123;</span><br><span class="line">  <span class="comment">//此处的代码只有占有了someObject后才可以执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized表示当前线程，独占 对象 someObject</strong> 当前线程<strong>独占</strong> 了对象someObject，如果有<em>*其他线程*<em><strong>试图占有对象</strong>someObject，</em>*就会等待</em>*，直到当前线程释放对someObject的占用。 someObject 又叫同步对象，所有的对象，都可以作为同步对象 为了达到同步的效果，必须使用同一个同步对象</p>
<p><strong>释放同步对象</strong>的方式： synchronized 块自然结束，或者有异常抛出</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112203017924.png" alt="image-20220112203017924"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestThread &#123;</span><br><span class="line">    <span class="built_in">public</span> static String now() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span> SimpleDateFormat(&quot;HH:mm:ss&quot;).format(<span class="built_in">new</span> <span class="type">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        final <span class="keyword">Object</span> someObject = <span class="built_in">new</span> <span class="keyword">Object</span>();</span><br><span class="line">        Thread t1 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println(now() + &quot; t1 线程已经运行&quot;);</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println(now() + this.getName() + &quot; 试图占有对象：someObject&quot;);</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(now() + this.getName() + &quot; 占有对象：someObject&quot;);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println(now() + this.getName() + &quot; 释放对象：someObject&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println(now() + &quot; t1 线程结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.<span class="keyword">start</span>();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="built_in">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println( now()+&quot; t2 线程已经运行&quot;);</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println( now()+this.getName()+ &quot; 试图占有对象：someObject&quot;);</span><br><span class="line">                    synchronized (someObject) &#123;</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println( now()+this.getName()+ &quot; 占有对象：someObject&quot;);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        <span class="keyword">System</span>.<span class="keyword">out</span>.println( now()+this.getName()+ &quot; 释放对象：someObject&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">System</span>.<span class="keyword">out</span>.println(now()+&quot; t2 线程结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // TODO Auto-<span class="keyword">generated</span> catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot; t2&quot;);</span><br><span class="line">        t2.<span class="keyword">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用synchronized-解决同步问题"><a href="#使用synchronized-解决同步问题" class="headerlink" title="使用synchronized 解决同步问题"></a>使用synchronized 解决同步问题</h3><p>所有需要修改hp的地方，有要<strong>建立在占有someObject的基础上</strong>。 而对象 someObject在同一时间，只能被一个线程占有。 间接地，<strong>导致同一时间，hp只能被一个线程修改。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">someObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero2</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero2</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//任何线程要修改hp的值，必须先占用someObject</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//任何线程要修改hp的值，必须先占用someObject</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">                        gareen.hurt();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用hero对象作为同步对象"><a href="#使用hero对象作为同步对象" class="headerlink" title="使用hero对象作为同步对象"></a>使用hero对象作为同步对象</h3><p>既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个hero对象，<strong>索性就使用gareen来作为同步对象</strong> 进一步的，对于Hero的hurt方法，加上： synchronized (this) { } 表示当前对象为同步对象，即也是gareen为同步对象</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        final Hero2 gareen = <span class="keyword">new</span> Hero2();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">10000</span>;</span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    synchronized (gareen) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    <span class="comment">//在方法hurt中有synchronized(this)</span></span><br><span class="line">                    gareen.hurt();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span>()</span> &#123;</span><br><span class="line">        hp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hurt</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            hp -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackHero</span>(<span class="params">Hero2 h</span>)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.<span class="keyword">out</span>.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isDead</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在方法前，加上修饰符synchronized"><a href="#在方法前，加上修饰符synchronized" class="headerlink" title="在方法前，加上修饰符synchronized"></a>在方法前，加上修饰符synchronized</h3><p>在recover前，直接加上synchronized ，其所对应的同步对象，就是this 和hurt方法达到的效果是一样 外部线程访问gareen的方法，就不需要额外使用synchronized 了</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="comment">//直接在方法前加上修饰符synchronized</span></span><br><span class="line">    <span class="comment">//其所对应的同步对象，就是this</span></span><br><span class="line">    <span class="comment">//和hurt方法达到的效果一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">recover</span>()</span> &#123;</span><br><span class="line">        hp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hurt</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            hp -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackHero</span>(<span class="params">Hero2 h</span>)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.<span class="keyword">out</span>.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isDead</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        final Hero2 gareen = <span class="keyword">new</span> Hero2();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">10000</span>;</span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    <span class="comment">//在方法hurt中有synchronized(this)</span></span><br><span class="line">                    gareen.hurt();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h3><p>如果一个类，其<strong>方法都是有synchronized修饰的</strong>，那么该类就叫做<strong>线程安全的类</strong></p>
<p>同一时间，只有一个线程能够进入 <strong>这种类的一个实例</strong> 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p>
<p>比如StringBuffer和StringBuilder的区别 StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类 而StringBuilder就不是线程安全的类</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112211733979.png" alt="image-20220112211733979"></p>
<h2 id="线程安全的类-1"><a href="#线程安全的类-1" class="headerlink" title="线程安全的类"></a>线程安全的类</h2><p>常见的线程安全相关的面试题</p>
<h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式 <strong>区别1：</strong> HashMap可以存放 null Hashtable不能存放null <strong>区别2：</strong> HashMap不是<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全的类</a> Hashtable是线程安全的类</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112211859723.png" alt="image-20220112211859723"></p>
<h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>StringBuffer 是线程安全的 StringBuilder 是非线程安全的</p>
<p>所以当进行大量字符串拼接操作的时候，如果是单线程就用StringBuilder会更快些，如果是多线程，就需要用StringBuffer 保证数据的安全性</p>
<p><strong>非线程安全的</strong>为什么会比<strong>线程安全的</strong> 快？ 因为不需要同步嘛，省略了些时间</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112211927366.png" alt="image-20220112211927366"></p>
<h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><p>ArrayList类的声明：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayList&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractList&lt;E&gt;</span></span></span><br><span class="line">	implements <span class="type">List</span>&lt;<span class="type">E</span>&gt;, <span class="type">RandomAccess</span>, <span class="type">Cloneable</span>, java.io.<span class="type">Serializable</span></span><br></pre></td></tr></table></figure>

<p>Vector类的声明：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Vector&lt;E&gt;</span>    <span class="keyword">extends</span> <span class="title">AbstractList&lt;E&gt;</span></span></span><br><span class="line">    implements <span class="type">List</span>&lt;<span class="type">E</span>&gt;, <span class="type">RandomAccess</span>, <span class="type">Cloneable</span>, java.io.<span class="type">Serializable</span></span><br></pre></td></tr></table></figure>

<p>一模一样的~ 他们的区别也在于，Vector是线程安全的类，而ArrayList是非线程安全的。</p>
<h3 id="把非线程安全的集合转换为线程安全"><a href="#把非线程安全的集合转换为线程安全" class="headerlink" title="把非线程安全的集合转换为线程安全"></a>把非线程安全的集合转换为线程安全</h3><p>ArrayList是非线程安全的，换句话说，多个线程可以同时进入<strong>一个ArrayList对象</strong>的add方法</p>
<p>借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。</p>
<p>与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过<a href="https://how2j.cn/k/collection/collection-collections/369.html">工具类Collections</a>转换为线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="演示死锁"><a href="#演示死锁" class="headerlink" title="演示死锁"></a>演示死锁</h3><p>\1. 线程1 首先占有对象1，接着试图占有对象2 \2. 线程2 首先占有对象2，接着试图占有对象1 \3. 线程1 等待线程2释放对象2 \4. 与此同时，线程2等待线程1释放对象1 就会。。。一直等待下去，直到天荒地老，海枯石烂，山无棱 ，天地合。。。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112212308191.png" alt="image-20220112212308191"></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestThread &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">final</span> Hero2 ahri = <span class="keyword">new</span> Hero2();</span><br><span class="line">        ahri.name = <span class="string">&quot;九尾妖狐&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> Hero2 annie = <span class="keyword">new</span> Hero2();</span><br><span class="line">        annie.name = <span class="string">&quot;安妮&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="comment">//占有九尾妖狐</span></span><br><span class="line">                <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">&quot;t1 已占有九尾妖狐&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有安妮</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">&quot;t1 试图占有安妮&quot;</span>);</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">&quot;t1 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                        System.out.<span class="keyword">println</span>(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="comment">//占有安妮</span></span><br><span class="line">                <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">&quot;t2 已占有安妮&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">&quot;t2 试图占有九尾妖狐&quot;</span>);</span><br><span class="line">                    System.out.<span class="keyword">println</span>(<span class="string">&quot;t2 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                        System.out.<span class="keyword">println</span>(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>线程之间有<strong>交互通知</strong>的需求，考虑如下情况： 有两个线程，处理同一个英雄。 一个加血，一个减血。</p>
<p>减血的线程，发现血量&#x3D;1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血</p>
<h3 id="不好的解决方式"><a href="#不好的解决方式" class="headerlink" title="不好的解决方式"></a>不好的解决方式</h3><p>故意设计减血线程频率更高，盖伦的血量迟早会到达1 减血线程中<strong>使用while循环判断是否是1</strong>，如果是1就不停的循环,直到加血线程回复了血量 这是不好的解决方式，因为会大量占用CPU,拖慢性能</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">recover</span>()</span> &#123;</span><br><span class="line">        hp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">hurt</span>()</span> &#123;</span><br><span class="line">        hp -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackHero</span>(<span class="params">Hero2 h</span>)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.<span class="keyword">out</span>.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isDead</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        final Hero2 gareen = <span class="keyword">new</span> Hero2();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">              <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                  <span class="comment">//因为减血更快，所以盖伦的血量迟早会到达1</span></span><br><span class="line">                  <span class="comment">//使用while循环判断是否是1，如果是1就不停的循环</span></span><br><span class="line">                  <span class="comment">//直到加血线程回复了血量</span></span><br><span class="line">                  <span class="keyword">while</span> (gareen.hp == <span class="number">1</span>) &#123;</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  gareen.hurt();</span><br><span class="line">                  System.<span class="keyword">out</span>.printf(<span class="string">&quot;t1 为%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>,gareen.name,gareen.name,gareen.hp);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line">                    System.<span class="keyword">out</span>.printf(<span class="string">&quot;t2 为%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>,gareen.name,gareen.name,gareen.hp);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用wait和notify进行线程交互"><a href="#使用wait和notify进行线程交互" class="headerlink" title="使用wait和notify进行线程交互"></a>使用wait和notify进行线程交互</h3><p>在Hero类中：hurt()减血方法：当hp&#x3D;1的时候，执行this.wait(). this.wait()<strong>表示 让占有this的线程等待，并临时释放占有</strong> 进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 <strong>这样加血线程，就有机会进入recover()加血方法了</strong>。</p>
<p>recover() 加血方法：增加了血量，执行this.notify(); this.notify() 表示通知那些<strong>等待在this的线程</strong>，可以苏醒过来了。 等待在this的线程，恰恰就是减血线程。 一旦recover()结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112213538215.png" alt="image-20220112213538215"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">recover</span>()</span> &#123;</span><br><span class="line">        hp += <span class="number">1</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">        <span class="comment">// 通知那些等待在this对象上的线程，可以醒过来了，等待着的减血线程，苏醒过来</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">hurt</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让占有this的减血线程，暂时释放对this的占有，并等待</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hp -= <span class="number">1</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.printf(<span class="string">&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackHero</span>(<span class="params">Hero2 h</span>)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.<span class="keyword">out</span>.format(<span class="string">&quot;%s 正在攻击 %s, %s 的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.isDead()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(h.name + <span class="string">&quot; 死了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isDead</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        final Hero2 gareen = <span class="keyword">new</span> Hero2();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">              <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                  <span class="comment">//无需循环判断</span></span><br><span class="line">                  <span class="comment">/*while (gareen.hp == 1) &#123;</span></span><br><span class="line"><span class="comment">                      continue;</span></span><br><span class="line"><span class="comment">                  &#125;*/</span></span><br><span class="line"></span><br><span class="line">                  gareen.hurt();</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于wait、notify和notifyAll"><a href="#关于wait、notify和notifyAll" class="headerlink" title="关于wait、notify和notifyAll"></a>关于wait、notify和notifyAll</h3><p>留意wait()和notify() 这两个方法是什么对象上的？</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">void</span> <span class="title">hurt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">wait</span>();</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">void</span> <span class="title">recover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   。。。</span><br><span class="line">   <span class="keyword">this</span>.<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要强调的是，wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p>
<p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p>
<p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p>
<p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>每一个线程的启动和结束都是比较消耗时间和占用资源的。</p>
<p>如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。</p>
<p>为了解决这个问题，引入线程池这种设计思想。</p>
<p>线程池的模式很像<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模式</a>，消费的对象是一个一个的能够运行的<strong>任务</strong></p>
<h3 id="线程池设计思路"><a href="#线程池设计思路" class="headerlink" title="线程池设计思路"></a>线程池设计思路</h3><p>线程池的思路和<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模型</a>是很接近的。 \1. 准备一个任务容器 \2. 一次性启动10个 消费者线程 \3. 刚开始任务容器是空的，所以线程都<strong>wait</strong>在上面。 \4. 直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step796">唤醒notify</a> \5. 这个消费者线程取出“任务”，并且<strong>执行这个任务</strong>，执行完毕后，继续等待下一次任务的到来。 \6. 如果短时间内，有较多的任务加入，那么就会有多个线程被<strong>唤醒</strong>，去执行这些任务。</p>
<p>在整个过程中，都不需要创建新的线程，而是<strong>循环使用这些已经存在的线程</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112214357660.png" alt="image-20220112214357660"></p>
<h3 id="开发一个自定义线程池"><a href="#开发一个自定义线程池" class="headerlink" title="开发一个自定义线程池"></a>开发一个自定义线程池</h3><p>这是一个自定义的线程池，虽然不够完善和健壮，但是已经足以说明线程池的工作原理</p>
<p>缓慢的给这个线程池添加任务，会看到有多条线程来执行这些任务。 线程7执行完毕任务后，<strong>又回到池子里</strong>，下一次任务来的时候，线程7又来执行新的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="type">int</span> threadPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务容器</span></span><br><span class="line">    LinkedList&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图消费任务的线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPoolSize = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 启动10个任务消费者线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadPoolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TaskConsumeThread</span>(<span class="string">&quot;任务消费者线程 &quot;</span> + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            tasks.add(r);</span><br><span class="line">            <span class="comment">// 唤醒等待的任务消费者线程</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TaskConsumeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TaskConsumeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;启动： &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (tasks.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            tasks.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = tasks.removeLast();</span><br><span class="line">                    <span class="comment">// 允许添加任务的线程可以继续添加任务</span></span><br><span class="line">                    tasks.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; 获取到任务，并执行&quot;</span>);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">                    <span class="comment">//任务可能是打印一句话</span></span><br><span class="line">                    <span class="comment">//可能是访问文件</span></span><br><span class="line">                    <span class="comment">//可能是做排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            pool.add(task);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试线程池"><a href="#测试线程池" class="headerlink" title="测试线程池"></a>测试线程池</h3><p>创造一个情景，每个任务执行的时间都是1秒 刚开始是间隔1秒钟向线程池中添加任务</p>
<p>然后间隔时间越来越短，执行任务的线程还没有来得及结束，新的任务又来了。 就会观察到线程池里的其他线程被唤醒来执行这些任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sleep</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            pool.add(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;执行任务&quot;);</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleep);</span><br><span class="line">                sleep = sleep &gt; <span class="number">100</span> ? sleep-<span class="number">100</span> : sleep;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用java自带线程池"><a href="#使用java自带线程池" class="headerlink" title="使用java自带线程池"></a>使用java自带线程池</h3><p>java提供自带的线程池，而不需要自己去开发一个自定义线程池了。</p>
<p>线程池类<strong>ThreadPoolExecutor</strong>在包<strong>java.util.concurrent</strong>下</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool= <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p><strong>第一个</strong>参数10 表示这个线程池<strong>初始化了10个</strong>线程在里面工作 <strong>第二个</strong>参数15 表示如果10个线程不够用了，就会自动增加到<strong>最多15个线程</strong> <strong>第三个</strong>参数60 结合第四个参数TimeUnit.SECONDS，表示经过<strong>60秒</strong>，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个 <strong>第四个</strong>参数TimeUnit.SECONDS 如上 <strong>第五个</strong>参数 new LinkedBlockingQueue() 用来放任务的集合</p>
<p><strong>execute</strong>方法用于添加新的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;Runnable&gt;());</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock对象"><a href="#Lock对象" class="headerlink" title="Lock对象"></a>Lock对象</h2><h3 id="回忆-synchronized-同步的方式"><a href="#回忆-synchronized-同步的方式" class="headerlink" title="回忆 synchronized 同步的方式"></a>回忆 synchronized 同步的方式</h3><p>首先回忆一下 <a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step789">synchronized 同步对象</a>的方式</p>
<p>当一个线程占用 synchronized 同步对象，其他线程就不能占用了，直到释放这个同步对象为止</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220112225748278.png" alt="image-20220112225748278"></p>
<h3 id="使用Lock对象实现同步效果"><a href="#使用Lock对象实现同步效果" class="headerlink" title="使用Lock对象实现同步效果"></a>使用Lock对象实现同步效果</h3><p>Lock是一个接口，为了使用一个Lock对象，需要用到</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>与 <strong>synchronized (someObject)</strong> 类似的，<strong>lock()<strong>方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。 与 <strong>synchronized</strong> 不同的是，一旦synchronized 块结束，就会自动释放对</strong>someObject</strong>的占用。 lock却必须调用<strong>unlock</strong>方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.<span class="keyword">Lock</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestThread &#123;</span><br><span class="line">    <span class="built_in">public</span> static String now() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span> SimpleDateFormat(&quot;HH:mm:ss&quot;).format(<span class="built_in">new</span> <span class="type">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> log(String msg) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.printf(&quot;%s %s %s %n&quot;, now(), Thread.currentThread().getName(), msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                    </span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    <span class="keyword">lock</span>.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.<span class="keyword">start</span>();</span><br><span class="line">        try &#123;</span><br><span class="line">            //先让t1飞<span class="number">2</span>秒</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line"></span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    <span class="keyword">lock</span>.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.<span class="keyword">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trylock方法"><a href="#trylock方法" class="headerlink" title="trylock方法"></a>trylock方法</h3><p>synchronized 是<strong>不占用到手不罢休</strong>的，会一直试图占用下去。 与 synchronized 的<strong>钻牛角尖</strong>不一样，Lock接口还提供了一个trylock方法。 trylock会在指定时间范围内<strong>试图占用</strong>，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~</p>
<p>注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.<span class="keyword">Lock</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestThread &#123;</span><br><span class="line">    <span class="built_in">public</span> static String now() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span> SimpleDateFormat(&quot;HH:mm:ss&quot;).format(<span class="built_in">new</span> <span class="type">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> log(String msg) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.printf(&quot;%s %s %s %n&quot;, now(), Thread.currentThread().getName(), msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                <span class="type">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"></span><br><span class="line">                    locked = <span class="keyword">lock</span>.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                        log(&quot;占有对象：lock&quot;);</span><br><span class="line">                        log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                        log(&quot;释放对象：lock&quot;);</span><br><span class="line">                        <span class="keyword">lock</span>.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.<span class="keyword">start</span>();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //先让t1飞<span class="number">2</span>秒</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                <span class="type">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"></span><br><span class="line">                    locked = <span class="keyword">lock</span>.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                        log(&quot;占有对象：lock&quot;);</span><br><span class="line">                        log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                        log(&quot;释放对象：lock&quot;);</span><br><span class="line">                        <span class="keyword">lock</span>.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.<span class="keyword">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h3><p>使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法</p>
<p>Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：<strong>await</strong>, <strong>signal</strong>,<strong>signalAll</strong> 方法</p>
<p><strong>注意</strong>： 不是Condition对象的wait,nofity,notifyAll方法,是await,signal,signalAll</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.<span class="keyword">Lock</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestThread &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static String now() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span> SimpleDateFormat(&quot;HH:mm:ss&quot;).format(<span class="built_in">new</span> <span class="type">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> log(String msg) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.printf(&quot;%s %s %s %n&quot;, now(), Thread.currentThread().getName(), msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line"></span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                    log(&quot;临时释放对象 lock， 并等待&quot;);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log(&quot;重新占有对象 lock，并进行5秒的业务操作&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    <span class="keyword">lock</span>.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.<span class="keyword">start</span>();</span><br><span class="line">        try &#123;</span><br><span class="line">            //先让t1飞<span class="number">2</span>秒</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 = <span class="built_in">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log(&quot;线程启动&quot;);</span><br><span class="line">                    log(&quot;试图占有对象：lock&quot;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line"></span><br><span class="line">                    log(&quot;占有对象：lock&quot;);</span><br><span class="line">                    log(&quot;进行5秒的业务操作&quot;);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(&quot;唤醒等待中的线程&quot;);</span><br><span class="line">                    condition.signal();</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    log(&quot;释放对象：lock&quot;);</span><br><span class="line">                    <span class="keyword">lock</span>.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;线程结束&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.<span class="keyword">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结Lock和synchronized的区别"><a href="#总结Lock和synchronized的区别" class="headerlink" title="总结Lock和synchronized的区别"></a>总结Lock和synchronized的区别</h3><p>\1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p>
<p>\2. Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p>
<p>\3. synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p>
<h2 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h2><h3 id="原子性操作概念"><a href="#原子性操作概念" class="headerlink" title="原子性操作概念"></a>原子性操作概念</h3><p>所谓的<strong>原子性操作</strong>即不可中断的操作，比如赋值操作</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int i <span class="operator">=</span> <span class="number">5</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong>原子性操作本身是线程安全的</strong> 但是 i++ 这个行为，事实上是有3个原子性操作组成的。 步骤 1. 取 i 的值 步骤 2. i + 1 步骤 3. 把新的值赋予i 这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作。就<strong>不是线程安全</strong>的。 换句话说，一个线程在步骤1 取i 的值结束后，还没有来得及进行步骤2，另一个线程也可以取 i的值了。 这也是<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step787">分析同步问题产生的原因</a> 中的原理。 i++ ，i–， i &#x3D; i+1 这些都是非原子性操作。 只有int i &#x3D; 1,这个赋值操作是原子性的。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>JDK6 以后，新增加了一个包<strong>java.util.concurrent.atomic</strong>，里面有各种原子类，比如<strong>AtomicInteger</strong>。 而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法 <strong>incrementAndGet</strong> 是线程安全的，同一个时间，只有一个线程可以调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> atomicInteger.decrementAndGet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> atomicInteger.incrementAndGet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> atomicInteger.addAndGet(<span class="number">3</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步测试"><a href="#同步测试" class="headerlink" title="同步测试"></a>同步测试</h3><p>分别使用基本变量的非原子性的**++<strong>运算符和 原子性的</strong>AtomicInteger对象的 incrementAndGet** 来进行多线程测试。 测试结果如图所示</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package multiplethread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">atomic</span>.<span class="property">AtomicInteger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> int value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">AtomicInteger</span> atomicValue = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        int <span class="built_in">number</span> = <span class="number">100000</span>;</span><br><span class="line">        <span class="title class_">Thread</span>[] ts1 = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="built_in">number</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Thread</span> t = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">              <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">                  value++;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.<span class="title function_">start</span>();</span><br><span class="line">            ts1[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待这些线程全部结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Thread</span> t : ts1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="title function_">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;</span><br><span class="line">                e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">printf</span>(<span class="string">&quot;%d个线程进行value++后，value的值变成:%d%n&quot;</span>, <span class="built_in">number</span>,value);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Thread</span>[] ts2 = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="built_in">number</span>];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="built_in">number</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Thread</span> t =<span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    atomicValue.<span class="title function_">incrementAndGet</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.<span class="title function_">start</span>();</span><br><span class="line">            ts2[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待这些线程全部结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Thread</span> t : ts2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="title function_">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;</span><br><span class="line">                e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">printf</span>(<span class="string">&quot;%d个线程进行atomicValue.incrementAndGet();后，atomicValue的值变成:%d%n&quot;</span>, <span class="built_in">number</span>,atomicValue.<span class="title function_">intValue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">100000</span>个线程进行value++后，value的值变成:<span class="number">99996</span></span><br><span class="line"><span class="number">100000</span>个线程进行atomicValue.<span class="title function_">incrementAndGet</span>();后，atomicValue的值变成:<span class="number">100000</span> </span><br></pre></td></tr></table></figure>

<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="Hello-JDBC"><a href="#Hello-JDBC" class="headerlink" title="Hello JDBC"></a>Hello JDBC</h2><h3 id="为项目导入mysql-jdbc的jar包"><a href="#为项目导入mysql-jdbc的jar包" class="headerlink" title="为项目导入mysql-jdbc的jar包"></a>为项目导入mysql-jdbc的jar包</h3><h3 id="初始化驱动"><a href="#初始化驱动" class="headerlink" title="初始化驱动"></a>初始化驱动</h3><p>通过<strong>Class.forName</strong>(“com.mysql.jdbc.Driver”); 初始化驱动类<strong>com.mysql.jdbc.Driver</strong> 就在 mysql-connector-java-5.0.8-bin.jar中 如果忘记了<a href="https://how2j.cn/k/jdbc/jdbc-statement/387.html#step856">第一个步骤的导包</a>，就会抛出ClassNotFoundException</p>
<p><strong>Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestJDBC &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//初始化驱动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//驱动类com.mysql.jdbc.Driver</span></span><br><span class="line">            <span class="comment">//就在 mysql-connector-java-5.0.8-bin.jar中</span></span><br><span class="line">            <span class="comment">//如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException</span></span><br><span class="line">            <span class="keyword">Class</span>.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">&quot;数据库驱动加载成功 ！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立与数据库的连接"><a href="#建立与数据库的连接" class="headerlink" title="建立与数据库的连接"></a>建立与数据库的连接</h3><p>建立与数据库的Connection连接 这里需要提供： 数据库所处于的ip:127.0.0.1 (本机) 数据库的端口号： 3306 （mysql专用端口号） 数据库名称 how2java 编码方式 UTF-8 账号 root 密码 admin</p>
<p>注： 这一步要成功执行，必须建立在mysql中有数据库how2java的基础上，如果没有，点击<a href="https://how2j.cn/k/mysql/mysql-createdatabase/379.html">创建数据库</a>查看如何进行数据库的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立与数据库的Connection连接</span></span><br><span class="line">            <span class="comment">// 这里需要提供：</span></span><br><span class="line">            <span class="comment">// 数据库所处于的ip:127.0.0.1 (本机)</span></span><br><span class="line">            <span class="comment">// 数据库的端口号： 3306 （mysql专用端口号）</span></span><br><span class="line">            <span class="comment">// 数据库名称 how2java</span></span><br><span class="line">            <span class="comment">// 编码方式 UTF-8</span></span><br><span class="line">            <span class="comment">// 账号 root</span></span><br><span class="line">            <span class="comment">// 密码 admin</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功，获取连接对象： &quot;</span> + c);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Statement"><a href="#创建Statement" class="headerlink" title="创建Statement"></a>创建Statement</h3><p>Statement是用于执行SQL语句的，比如增加，删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            System.out.println(<span class="string">&quot;获取 Statement对象： &quot;</span> + s);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h3><p>s.execute执行sql语句 执行成功后，用mysql-front进行查看，明确插入成功</p>
<p>执行SQL语句之前要确保数据库how2java中有表hero的存在，如果没有，需要事先<a href="https://how2j.cn/k/mysql/mysql-createtable/380.html">创建表</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备sql语句</span></span><br><span class="line">            <span class="comment">// 注意： 字符串要用单引号&#x27;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into hero values(null, &quot;</span>+<span class="string">&quot;&#x27;提莫&#x27;&quot;</span>+<span class="string">&quot;,&quot;</span>+<span class="number">313.0f</span>+<span class="string">&quot;,&quot;</span>+<span class="number">50</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;执行插入语句成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>数据库的连接是有限资源，相关操作结束后，养成关闭数据库的好习惯 先关闭Statement 后关闭Connection</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            s = c.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备sql语句</span></span><br><span class="line">            <span class="comment">// 注意： 字符串要用单引号&#x27;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into hero values(null, &quot;</span>+<span class="string">&quot;&#x27;提莫&#x27;&quot;</span>+<span class="string">&quot;,&quot;</span>+<span class="number">313.0f</span>+<span class="string">&quot;,&quot;</span>+<span class="number">50</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;执行插入语句成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯</span></span><br><span class="line">            <span class="comment">// 先关闭Statement</span></span><br><span class="line">            <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后关闭Connection</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用try-with-resource的方式自动关闭连接"><a href="#使用try-with-resource的方式自动关闭连接" class="headerlink" title="使用try-with-resource的方式自动关闭连接"></a>使用try-with-resource的方式自动关闭连接</h3><p>如果觉得上一步的关闭连接的方式很麻烦，可以参考<a href="https://how2j.cn/k/io/io-closestream/682.html#step2396">关闭流</a> 的方式，使用<strong>try-with-resource</strong>的方式自动关闭连接，因为Connection和Statement都实现了AutoCloseable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into hero values(null, &quot;</span>+<span class="string">&quot;&#x27;提莫&#x27;&quot;</span>+<span class="string">&quot;,&quot;</span>+<span class="number">313.0f</span>+<span class="string">&quot;,&quot;</span>+<span class="number">50</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;执行插入语句成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增、删、改"><a href="#增、删、改" class="headerlink" title="增、删、改"></a>增、删、改</h2><p>CRUD是最常见的数据库操作，即增删改查 <strong>C</strong> 增加(Create) <strong>R</strong> 读取查询(Retrieve) <strong>U</strong> 更新(Update) <strong>D</strong> 删除(Delete)</p>
<p>在JDBC中增加，删除，修改的操作都很类似，只是传递不同的SQL语句就行了。</p>
<p>查询因为要返回数据，所以和上面的不一样，将在<a href="https://how2j.cn/k/jdbc/jdbc-resultset/390.html">查询</a>章节讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into hero values(null, &quot;</span>+<span class="string">&quot;&#x27;提莫&#x27;&quot;</span>+<span class="string">&quot;,&quot;</span>+<span class="number">313.0f</span>+<span class="string">&quot;,&quot;</span>+<span class="number">50</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;执行插入语句成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>删除和增加很类似，只不过是执行的SQL语句不一样罢了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from hero where id = 5&quot;</span>;</span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改也一样，执行另一条SQL语句就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update hero set name = &#x27;name 5&#x27; where id = 3&quot;</span>;</span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>执行查询SQL语句</p>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>executeQuery 执行SQL查询语句</p>
<p><strong>注意：</strong> 在取第二列的数据的时候，用的是rs.get(2) ，而不是get(1). 这个是整个Java自带的api里<strong>唯二</strong>的地方，使用<strong>基1</strong>的，即2就代表第二个。</p>
<p>另一个地方是在<a href="https://how2j.cn/k/jdbc/jdbc-preparedstatement/388.html">PreparedStatement</a>这里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询语句，并把结果集返回给ResultSet</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);<span class="comment">// 可以使用字段名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);<span class="comment">// 也可以使用字段的顺序</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">hp</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t%s\t%f\t%d%n&quot;</span>, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet</span></span><br><span class="line">            <span class="comment">// rs.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">1</span>	提莫	<span class="number">313.000000</span>	<span class="number">50</span></span><br><span class="line">    <span class="number">3</span>	name <span class="number">5</span>	<span class="number">313.000000</span>	<span class="number">50</span></span><br><span class="line">    <span class="number">4</span>	提莫	<span class="number">313.000000</span>	<span class="number">50</span></span><br><span class="line">    <span class="number">6</span>	提莫莫	<span class="number">313.000000</span>	<span class="number">50</span></span><br><span class="line">    <span class="number">7</span>	提莫莫	<span class="number">313.000000</span>	<span class="number">50</span></span><br><span class="line">    <span class="number">8</span>	提莫莫	<span class="number">313.000000</span>	<span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL语句判断账号密码是否正确"><a href="#SQL语句判断账号密码是否正确" class="headerlink" title="SQL语句判断账号密码是否正确"></a>SQL语句判断账号密码是否正确</h3><p>\1. 创建一个用户表，有字段name,password \2. 插入一条数据</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">&#x27;dashen&#x27;</span>,<span class="string">&#x27;thisispassword&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>\3. SQL语句判断账号密码是否正确</p>
<p>判断账号密码的<strong>正确方式</strong>是根据账号和密码到表中去找数据，如果有数据，就表明密码正确了，如果没数据，就表明密码错误。</p>
<p><strong>不恰当的方式</strong> 是把uers表的数据全部查到内存中，挨个进行比较。 如果users表里有100万条数据呢？ 内存都不够用的。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) AUTO_INCREMENT,</span><br><span class="line">  <span class="type">name</span> <span class="type">varchar</span>(<span class="number">30</span>) ,</span><br><span class="line">  <span class="keyword">password</span> <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">) ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;dashen&#x27;</span>,<span class="string">&#x27;thisispassword&#x27;</span>);</span><br><span class="line">package jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="keyword">sql</span>.*;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestJDBC &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">Class</span>.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try (</span><br><span class="line">            <span class="keyword">Connection</span> c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Statement</span> s = c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            String <span class="type">name</span> = &quot;dashen&quot;;</span><br><span class="line">            //正确的密码是：thisispassword</span><br><span class="line">            String <span class="keyword">password</span> = &quot;thisispassword1&quot;;</span><br><span class="line"></span><br><span class="line">            String <span class="keyword">sql</span> = &quot;select * from user where name = &#x27;&quot; + <span class="type">name</span> +&quot;&#x27; and password = &#x27;&quot; + <span class="keyword">password</span> +&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">            // 执行查询语句，并把结果集返回给ResultSet</span><br><span class="line">            ResultSet rs = s.executeQuery(<span class="keyword">sql</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rs.next())</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;账号密码正确&quot;);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;账号密码错误&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取总数"><a href="#获取总数" class="headerlink" title="获取总数"></a>获取总数</h3><p>执行的sql语句为</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> hero</span><br></pre></td></tr></table></figure>

<p>然后通过ResultSet获取出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;dashen&quot;</span>;</span><br><span class="line">            <span class="comment">//正确的密码是：thisispassword</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;thisispassword1&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from hero&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                total = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;表Hero中总共有:&quot;</span> + total +<span class="string">&quot; 条数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预编译Statement"><a href="#预编译Statement" class="headerlink" title="预编译Statement"></a>预编译Statement</h2><h3 id="使用PreparedStatement"><a href="#使用PreparedStatement" class="headerlink" title="使用PreparedStatement"></a>使用PreparedStatement</h3><p>和 Statement一样，PreparedStatement也是用来执行sql语句的 与创建Statement不同的是，需要根据sql语句创建PreparedStatement 除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接</p>
<p>注： 这是JAVA里唯二的基1的地方，另一个是<a href="https://how2j.cn/k/jdbc/jdbc-resultset/390.html#step866">查询语句</a>中的ResultSet也是基1的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数</span></span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            ps.execute();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatement的优点1-参数设置"><a href="#PreparedStatement的优点1-参数设置" class="headerlink" title="PreparedStatement的优点1-参数设置"></a>PreparedStatement的优点1-参数设置</h3><p><strong>Statement</strong> 需要进行字符串拼接，可读性和维护性比较差</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">String sql = &quot;<span class="keyword">insert</span> <span class="keyword">into</span> hero <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">&quot;+&quot;</span><span class="string">&#x27;提莫&#x27;</span><span class="string">&quot;+&quot;</span>,<span class="string">&quot;+313.0f+&quot;</span>,<span class="string">&quot;+50+&quot;</span>)<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>

<p><strong>PreparedStatement</strong> 使用参数设置，可读性好，不易犯错</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">String sql = &quot;<span class="keyword">insert</span> <span class="keyword">into</span> hero <span class="keyword">values</span>(<span class="literal">null</span>,?,?,?)<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatement的优点2-性能表现"><a href="#PreparedStatement的优点2-性能表现" class="headerlink" title="PreparedStatement的优点2-性能表现"></a>PreparedStatement的优点2-性能表现</h3><p>PreparedStatement有预编译机制，性能比Statement更快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">             <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// Statement执行10次，需要10次把SQL语句传输到数据库端</span></span><br><span class="line">            <span class="comment">// 数据库要对每一次来的SQL语句进行编译处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,&quot;</span> + <span class="string">&quot;&#x27;提莫&#x27;&quot;</span> + <span class="string">&quot;,&quot;</span></span><br><span class="line">                        + <span class="number">313.0f</span> + <span class="string">&quot;,&quot;</span> + <span class="number">50</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                s.execute(sql0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PreparedStatement 执行10次，只需要1次把SQL语句传输到数据库端</span></span><br><span class="line">            <span class="comment">// 数据库对带?的SQL进行预编译</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次执行，只需要传输参数到数据库端</span></span><br><span class="line">            <span class="comment">// 1. 网络传输量比Statement更小</span></span><br><span class="line">            <span class="comment">// 2. 数据库不需要再进行编译，响应更快</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ps.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">                ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">                ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">                ps.execute();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatement的优点3-防止SQL注入式攻击"><a href="#PreparedStatement的优点3-防止SQL注入式攻击" class="headerlink" title="PreparedStatement的优点3-防止SQL注入式攻击"></a>PreparedStatement的优点3-防止SQL注入式攻击</h3><p>假设name是用户提交来的数据</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">String name <span class="operator">=</span> <span class="string">&quot;&#x27;盖伦&#x27; OR 1=1&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>使用Statement就需要进行字符串拼接 拼接出来的语句是：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hero <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;盖伦&#x27;</span> <span class="keyword">OR</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>因为有OR 1&#x3D;1，这是恒成立的 那么就会把所有的英雄都查出来，而不只是盖伦 如果Hero表里的数据是海量的，比如几百万条，<strong>把这个表里的数据全部查出来</strong> 会让数据库负载变高，CPU100%，内存消耗光，<strong>响应变得极其缓慢</strong></p>
<p>而PreparedStatement使用的是<strong>参数设置</strong>，就不会有这个问题</p>
<h2 id="execute与executeUpdate的区别"><a href="#execute与executeUpdate的区别" class="headerlink" title="execute与executeUpdate的区别"></a>execute与executeUpdate的区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p><strong>execute</strong>与<strong>executeUpdate</strong>的相同点：都可以执行增加，删除，修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">String</span> <span class="variable">sqlInsert</span> <span class="operator">=</span> <span class="string">&quot;insert into Hero values (null,&#x27;盖伦&#x27;,616,100)&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sqlDelete</span> <span class="operator">=</span> <span class="string">&quot;delete from Hero where id = 100&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sqlUpdate</span> <span class="operator">=</span> <span class="string">&quot;update Hero set hp = 300 where id = 100&quot;</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 相同点：都可以执行增加，删除，修改</span></span><br><span class="line"> </span><br><span class="line">            s.execute(sqlInsert);</span><br><span class="line">            s.execute(sqlDelete);</span><br><span class="line">            s.execute(sqlUpdate);</span><br><span class="line">            s.executeUpdate(sqlInsert);</span><br><span class="line">            s.executeUpdate(sqlDelete);</span><br><span class="line">            s.executeUpdate(sqlUpdate);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p><strong>不同1：</strong> execute<strong>可以执行查询语句</strong> 然后通过getResultSet，把结果集取出来 executeUpdate<strong>不能执行查询语句</strong> <strong>不同2:</strong> execute<strong>返回boolean类型</strong>，true表示执行的是查询语句，false表示执行的是insert,delete,update等等 executeUpdate<strong>返回的是int</strong>，表示有多少条数据受到了影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">             <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不同1：execute可以执行查询语句</span></span><br><span class="line">            <span class="comment">// 然后通过getResultSet，把结果集取出来</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sqlSelect</span> <span class="operator">=</span> <span class="string">&quot;select * from hero&quot;</span>;</span><br><span class="line"></span><br><span class="line">            s.execute(sqlSelect);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.getResultSet();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// executeUpdate不能执行查询语句</span></span><br><span class="line">            <span class="comment">// s.executeUpdate(sqlSelect);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不同2:</span></span><br><span class="line">            <span class="comment">// execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> s.execute(sqlSelect);</span><br><span class="line">            System.out.println(isSelect);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// executeUpdate返回的是int，表示有多少条数据受到了影响</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sqlUpdate</span> <span class="operator">=</span> <span class="string">&quot;update Hero set hp = 300 where id &lt; 100&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> s.executeUpdate(sqlUpdate);</span><br><span class="line">            System.out.println(number);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><h3 id="获取自增长id"><a href="#获取自增长id" class="headerlink" title="获取自增长id"></a>获取自增长id</h3><p>在Statement通过execute或者executeUpdate执行完插入语句后，MySQL会为新插入的数据分配一个自增长id，(前提是这个表的id设置为了自增长,在Mysql创建表的时候，AUTO_INCREMENT就表示自增长)</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hero (</span><br><span class="line">  id <span class="meta">int</span>(11) AUTO_INCREMENT,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是无论是execute还是executeUpdate都不会返回这个自增长id是多少。需要通过<strong>Statement</strong>的<strong>getGeneratedKeys</strong>获取该id <strong>注：</strong> 第20行的代码，后面加了个<strong>Statement.RETURN_GENERATED_KEYS</strong>参数，以确保会返回自增长ID。 通常情况下不需要加这个，有的时候需要加，所以先加上，保险一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, <span class="number">616</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行插入语句</span></span><br><span class="line">            ps.execute();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span></span><br><span class="line">            <span class="comment">// JDBC通过getGeneratedKeys获取该id</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                System.out.println(id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取表的元数据"><a href="#获取表的元数据" class="headerlink" title="获取表的元数据"></a>获取表的元数据</h3><p>元数据概念： 和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DatabaseMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看数据库层面的元数据</span></span><br><span class="line">            <span class="comment">// 即数据库服务器版本，驱动版本，都有哪些数据库等等</span></span><br><span class="line"></span><br><span class="line">            <span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> c.getMetaData();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取数据库服务器产品名称</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库产品名称:\t&quot;</span>+dbmd.getDatabaseProductName());</span><br><span class="line">            <span class="comment">// 获取数据库服务器产品版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库产品版本:\t&quot;</span>+dbmd.getDatabaseProductVersion());</span><br><span class="line">            <span class="comment">// 获取数据库服务器用作类别和表名之间的分隔符 如test.user</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库和表分隔符:\t&quot;</span>+dbmd.getCatalogSeparator());</span><br><span class="line">            <span class="comment">// 获取驱动版本</span></span><br><span class="line">            System.out.println(<span class="string">&quot;驱动版本:\t&quot;</span>+dbmd.getDriverVersion());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;可用的数据库列表：&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取数据库名称</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getCatalogs();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库名称:\t&quot;</span>+rs.getString(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="不使用事务的情况"><a href="#不使用事务的情况" class="headerlink" title="不使用事务的情况"></a>不使用事务的情况</h3><p><strong>没有事务的前提下</strong> 假设业务操作是：加血，减血各做一次 结束后，英雄的血量不变 而减血的SQL 不小心写错写成了 updat<strong>a</strong>(而非update) 那么最后结果是血量增加了，而非期望的不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//没有事务的前提下</span></span><br><span class="line">            <span class="comment">//假设业务操作时，加血，减血各做一次</span></span><br><span class="line">            <span class="comment">//结束后，英雄的血量不变</span></span><br><span class="line">              </span><br><span class="line">            <span class="comment">//加血的SQL</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update hero set hp = hp +1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">              </span><br><span class="line">            <span class="comment">//减血的SQL</span></span><br><span class="line">            <span class="comment">//不小心写错写成了 updata(而非update)</span></span><br><span class="line">              </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;updata hero set hp = hp -1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>在事务中的多个操作，<strong>要么都成功，要么都失败</strong> 通过 c.setAutoCommit(false);<strong>关闭自动提交</strong> 使用 c.commit();进行<strong>手动提交</strong> 在22行-35行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败 所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句<strong>都没有被提交</strong>。 除非两条SQL语句都是正确的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 有事务的前提下</span></span><br><span class="line">            <span class="comment">// 在事务中的多个操作，要么都成功，要么都失败</span></span><br><span class="line">  </span><br><span class="line">            c.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 加血的SQL</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update hero set hp = hp +1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 减血的SQL</span></span><br><span class="line">            <span class="comment">// 不小心写错写成了 updata(而非update)</span></span><br><span class="line">  </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;updata hero set hp = hp -1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 手动提交</span></span><br><span class="line">            c.commit();</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MYSQL-表的类型必须是INNODB才支持事务"><a href="#MYSQL-表的类型必须是INNODB才支持事务" class="headerlink" title="MYSQL 表的类型必须是INNODB才支持事务"></a>MYSQL 表的类型必须是INNODB才支持事务</h3><p>在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所以需要把表的类型设置为INNODB,否则无法观察到事务.</p>
<p>修改表的类型为INNODB的SQL：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">alter table hero ENGINE  <span class="operator">=</span> innodb<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>查看表的类型的SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> how2java; </span><br></pre></td></tr></table></figure>

<p>不过有个前提，就是当前的MYSQL服务器本身要支持INNODB,如果不支持，请看 <a href="https://how2j.cn/k/mysql/mysql-innodb/1064.html">开启MYSQL INNODB的办法</a></p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM&#x3D;Object Relationship Database Mapping</p>
<p>对象和关系数据库的映射</p>
<p>简单说，<strong>一个对象</strong>，对应数据库里的<strong>一条记录</strong></p>
<h3 id="根据id返回一个Hero对象"><a href="#根据id返回一个Hero对象" class="headerlink" title="根据id返回一个Hero对象"></a>根据id返回一个Hero对象</h3><p>提供方法get(int id) 返回一个Hero3对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hero3 <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">Hero3</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero where id = &quot;</span> + id;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为id是唯一的，ResultSet最多只能有一条记录</span></span><br><span class="line">            <span class="comment">// 所以使用if代替while</span></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                hero3 = <span class="keyword">new</span> <span class="title class_">Hero3</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">                <span class="type">float</span> <span class="variable">hp</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">                hero3.name = name;</span><br><span class="line">                hero3.hp = hp;</span><br><span class="line">                hero3.damage = damage;</span><br><span class="line">                hero3.id = id;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hero3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero3</span> <span class="variable">h</span> <span class="operator">=</span> get(<span class="number">22</span>);</span><br><span class="line">        System.out.println(h.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><p>DAO&#x3D;<strong>D</strong>ata<strong>A</strong>ccess <strong>O</strong>bject</p>
<p>数据访问对象</p>
<p>实际上就是运用了<a href="https://how2j.cn/k/jdbc/jdbc-orm/391.html#step2641">练习-ORM</a>中的思路，把数据库相关的操作都封装在这个类里面，其他地方看不到JDBC的代码</p>
<h3 id="DAO接口"><a href="#DAO接口" class="headerlink" title="DAO接口"></a>DAO接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DAO</span> &#123;</span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Hero3 hero)</span>;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Hero3 hero)</span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="keyword">public</span> Hero3 <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hero3&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hero3&gt; <span class="title function_">list</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HeroDAO"><a href="#HeroDAO" class="headerlink" title="HeroDAO"></a>HeroDAO</h3><p>设计类HeroDAO，实现接口<a href="https://how2j.cn/k/jdbc/jdbc-dao/392.html#step874">DAO</a></p>
<p>这个HeroDAO和<a href="https://how2j.cn/k/jdbc/jdbc-orm/391.html#step2642">答案-ORM</a>很接近，做了几个改进： \1. 把驱动的初始化放在了构造方法HeroDAO里：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroDAO</span>()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为驱动初始化只需要执行一次，所以放在这里更合适，其他方法里也不需要写了，代码更简洁</p>
<p>\2. 提供了一个getConnection方法返回连接 所有的数据库操作都需要事先拿到一个数据库连接Connection，以前的做法每个方法里都会写一个，如果要改动密码，那么每个地方都需要修改。 通过这种方式，只需要修改这一个地方就可以了。 代码变得更容易维护，而且也更加简洁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DAO</span> &#123;</span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Hero3 hero)</span>;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Hero3 hero)</span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="keyword">public</span> Hero3 <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hero3&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hero3&gt; <span class="title function_">list</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> count)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeroDAO</span> <span class="keyword">implements</span> <span class="title class_">DAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroDAO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection();</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from hero&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                total = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;total:&quot;</span> + total);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Hero3 hero)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection();</span><br><span class="line">                <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            ps.setString(<span class="number">1</span>, hero.name);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, hero.hp);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, hero.damage);</span><br><span class="line"></span><br><span class="line">            ps.execute();</span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                hero.id = id;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Hero3 hero)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update hero set name= ?, hp = ? , damage = ? where id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection(); <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);) &#123;</span><br><span class="line"></span><br><span class="line">            ps.setString(<span class="number">1</span>, hero.name);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, hero.hp);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, hero.damage);</span><br><span class="line">            ps.setInt(<span class="number">4</span>, hero.id);</span><br><span class="line"></span><br><span class="line">            ps.execute();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection(); <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from hero where id = &quot;</span> + id;</span><br><span class="line"></span><br><span class="line">            s.execute(sql);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Hero3 <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">Hero3</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection(); <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero where id = &quot;</span> + id;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                hero = <span class="keyword">new</span> <span class="title class_">Hero3</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">                <span class="type">float</span> <span class="variable">hp</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">                hero.name = name;</span><br><span class="line">                hero.hp = hp;</span><br><span class="line">                hero.damage = damage;</span><br><span class="line">                hero.id = id;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hero3&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list(<span class="number">0</span>, Short.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hero3&gt; <span class="title function_">list</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        List&lt;Hero3&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero3&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero order by id desc limit ?,? &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection(); <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);) &#123;</span><br><span class="line"></span><br><span class="line">            ps.setInt(<span class="number">1</span>, start);</span><br><span class="line">            ps.setInt(<span class="number">2</span>, count);</span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">Hero3</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero3</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">                <span class="type">float</span> <span class="variable">hp</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">                hero.id = id;</span><br><span class="line">                hero.name = name;</span><br><span class="line">                hero.hp = hp;</span><br><span class="line">                hero.damage = damage;</span><br><span class="line">                heros.add(hero);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据库线程池"><a href="#数据库线程池" class="headerlink" title="数据库线程池"></a>数据库线程池</h2><p>与<a href="https://how2j.cn/k/thread/thread-threadpool/357.html">线程池</a>类似的，数据库也有一个数据库连接池。 不过他们的实现思路是不一样的。 本章节讲解了自定义数据库连接池类：ConnectionPool，虽然不是很完善和健壮，但是足以帮助大家理解ConnectionPool的基本原理。</p>
<h3 id="数据库连接池原理-传统方式"><a href="#数据库连接池原理-传统方式" class="headerlink" title="数据库连接池原理-传统方式"></a>数据库连接池原理-传统方式</h3><p>当有多个线程，每个线程都需要连接数据库执行SQL语句的话，那么每个线程都会创建一个连接，并且在使用完毕后，关闭连接。</p>
<p>创建连接和关闭连接的过程也是比较消耗时间的，当多线程并发的时候，系统就会变得很卡顿。</p>
<p>同时，一个数据库同时支持的连接总数也是有限的，如果多线程并发量很大，那么数据库连接的总数就会被消耗光，后续线程发起的数据库连接就会失败。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220113155614547.png" alt="image-20220113155614547"></p>
<h3 id="数据库连接池原理-使用池"><a href="#数据库连接池原理-使用池" class="headerlink" title="数据库连接池原理-使用池"></a>数据库连接池原理-使用池</h3><p>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。 如果有任何线程需要使用连接，那么就从连接池里面<strong>借用</strong>，<strong>而不是自己重新创建</strong>. 使用完毕后，又把这个连接<strong>归还</strong>给连接池供下一次或者其他线程使用。 倘若发生多线程并发情况，连接池里的连接被<strong>借用光</strong>了，那么其他线程就会临时等待，直到有连接被<strong>归还</strong>回来，再继续使用。 整个过程，这些连接都<strong>不会被关闭</strong>，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220113155704901.png" alt="image-20220113155704901"></p>
<h3 id="ConnectionPool构造方法和初始化"><a href="#ConnectionPool构造方法和初始化" class="headerlink" title="ConnectionPool构造方法和初始化"></a>ConnectionPool构造方法和初始化</h3><p>\1. ConnectionPool() 构造方法约定了这个连接池一共有多少连接</p>
<p>\2. 在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用</p>
<p>\3. getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去</p>
<p>\4. returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了。</p>
<p>注：连接池设计用到了多线程的wait和notifyAll，这些内容可以在<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html">多线程交互</a>章节查阅学习。</p>
<p>代码比较复制代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line">    List&lt;Connection&gt; cs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是&quot;活&quot;的，不要被自动关闭了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">                cs.add(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> cs.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">returnConnection</span><span class="params">(Connection c)</span> &#123;</span><br><span class="line">        cs.add(c);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>首先初始化一个有3条连接的数据库连接池 然后创建100个线程，每个线程都会从连接池中<strong>借用连接</strong>，并且在借用之后，归还连接。 拿到连接之后，执行一个耗时1秒的SQL语句。</p>
<p>运行程序，就可以观察到如图所示的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionPool</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WorkingThread</span>(<span class="string">&quot;working thread&quot;</span> + i, cp).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionPool cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkingThread</span><span class="params">(String name, ConnectionPool cp)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.cp = cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> cp.getConnection();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName()+ <span class="string">&quot;:\t 获取了一根连接，并开始工作&quot;</span>  );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> c.createStatement())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模拟时耗１秒的数据库SQL语句</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            st.execute(<span class="string">&quot;select * from hero&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cp.returnConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="IP地址-端口"><a href="#IP地址-端口" class="headerlink" title="IP地址 端口"></a>IP地址 端口</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在网络中每台计算机都必须有一个的IP地址； 32位，4个字节，常用点分十进制的格式表示，例如：192.168.1.100 127.0.0.1 是固定ip地址，代表当前计算机，相当于面向对象里的 “<strong>this</strong>“</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220113000806547.png" alt="image-20220113000806547"></p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>两台计算机进行连接，总有一台服务器，一台客户端。 服务器和客户端之间的通信通过端口进行。如图：</p>
<p>ip地址是 192.168.1.100的服务器通过端口 8080 与ip地址是192.168.1.189的客户端 的1087端口通信</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220113000900004.png" alt="image-20220113000900004"></p>
<h3 id="获取本机IP地址"><a href="#获取本机IP地址" class="headerlink" title="获取本机IP地址"></a>获取本机IP地址</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSocket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> host.getHostAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;本机ip地址：&quot;</span> + ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>使用ping判断一个地址是否能够到达 ping不是java的api，是windows中的一个小工具，用于判断一个地址的响应时间</p>
<p>如图 ping 192.168.2.106 可以返回这个地址的响应时间 time&lt;1ms表示很快，局域网一般就是这个响应时间</p>
<p>ping 192.168.2.206 返回Request timed out表示时间较久都没有响应返回，基本判断这个地址不可用</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220113001616191.png" alt="image-20220113001616191"></p>
<h3 id="使用java-执行ping命令"><a href="#使用java-执行ping命令" class="headerlink" title="使用java 执行ping命令"></a>使用java 执行ping命令</h3><p>借助 Runtime.getRuntime().exec() 可以运行一个windows的exe程序 如图，使用java运行 <strong>ping 192.168.2.106</strong>，返回这样的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + <span class="string">&quot;192.168.2.106&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream(), <span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.length() != <span class="number">0</span>)</span><br><span class="line">                sb.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;本次指令返回的消息是：&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    本次指令返回的消息是：</span><br><span class="line">    正在 Ping <span class="number">192.168</span><span class="number">.2</span><span class="number">.106</span> 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">    请求超时。</span><br><span class="line">    请求超时。</span><br><span class="line">    请求超时。</span><br><span class="line">    请求超时。</span><br><span class="line">    <span class="number">192.168</span><span class="number">.2</span><span class="number">.106</span> 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">4</span>，已接收 = <span class="number">0</span>，丢失 = <span class="number">4</span> (<span class="number">100</span>% 丢失)，</span><br></pre></td></tr></table></figure>

<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>使用 Socket(套接字)进行不同的程序之间的通信</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>\1. 服务端开启8888端口，并监听着，时刻等待着客户端的连接请求 \2. 客户端知道服务端的ip地址和监听端口号，发出请求到服务端 客户端的端口地址是系统分配的，通常都会大于1024 一旦建立了连接，服务端会得到一个新的Socket对象，该对象负责与客户端进行通信。 <strong>注意：</strong> 在开发调试的过程中，如果修改过了服务器Server代码，要关闭启动的Server,否则新的Server不能启动，因为8888端口被占用了</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220113130018743.png" alt="image-20220113130018743"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端打开端口8888</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在8888端口上监听，看是否有连接请求过来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有连接过来&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="收发数字"><a href="#收发数字" class="headerlink" title="收发数字"></a>收发数字</h3><p>一旦建立了连接，服务端和客户端就可以通过Socket进行通信了 \1. 客户端打开输出流，并发送数字 110 \2. 服务端打开输入流，接受数字 110，并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端打开端口8888</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在8888端口上监听，看是否有连接请求过来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打开输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">msg</span> <span class="operator">=</span> is.read();</span><br><span class="line">            <span class="comment">//打印出来</span></span><br><span class="line">            System.out.println(msg);</span><br><span class="line">            is.close();</span><br><span class="line"></span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数字110到服务端</span></span><br><span class="line">            os.write(<span class="number">110</span>);</span><br><span class="line">            os.close();</span><br><span class="line"></span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="收发字符串"><a href="#收发字符串" class="headerlink" title="收发字符串"></a>收发字符串</h3><p>直接使用字节流收发字符串比较麻烦，使用<a href="https://how2j.cn/k/io/io-datastream/350.html#step771">数据流</a>对字节流进行封装，这样收发字符串就容易了 \1. 把输出流封装在DataOutputStream中 使用writeUTF发送字符串 “Legendary!” \2. 把输入流封装在DataInputStream 使用readUTF读取字符串,并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端打开端口8888</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在8888端口上监听，看是否有连接请求过来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打开输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把输入流封装在DataInputStream</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="comment">//使用readUTF读取字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            <span class="comment">//打印</span></span><br><span class="line">            System.out.println(msg);</span><br><span class="line"></span><br><span class="line">            dis.close();</span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把输出流封装在DataOutputStream中</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//使用writeUTF发送字符串</span></span><br><span class="line">            dos.writeUTF(<span class="string">&quot;Legendary!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            dos.close();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Scanner"><a href="#使用Scanner" class="headerlink" title="使用Scanner"></a>使用Scanner</h3><p>在上个步骤中，每次要发不同的数据都需要修改代码 可以使用<a href="https://how2j.cn/k/io/io-system-in/352.html#step774">Scanner</a>读取控制台的输入，并发送到服务端，这样每次都可以发送不同的数据了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把输出流封装在DataOutputStream中</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用Scanner读取控制台的输入，并发送到服务端</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用writeUTF发送字符串</span></span><br><span class="line">            dos.writeUTF(str);</span><br><span class="line"></span><br><span class="line">            dos.close();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端和客户端互聊"><a href="#服务端和客户端互聊" class="headerlink" title="服务端和客户端互聊"></a>服务端和客户端互聊</h3><p>前面部分的学习效果是服务端接受数据，客户端发送数据。</p>
<p>做相应的改动，使得服务端也能发送数据，客户端也能接受数据，并且可以一直持续下去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端打开端口8888</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在8888端口上监听，看是否有连接请求过来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端信息&quot;</span>+msg);</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                dos.writeUTF(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                dos.writeUTF(str);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(<span class="string">&quot;收到服务端信息&quot;</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程聊天"><a href="#多线程聊天" class="headerlink" title="多线程聊天"></a>多线程聊天</h2><p>如果使用单线程开发Socket应用，那么同一时间，要么收消息，要么发消息，不能同时进行。</p>
<p>为了实现<strong>同时收发消息</strong>，就需要用到多线程</p>
<p>在<a href="https://how2j.cn/k/socket/socket-socket/400.html#step2737">练习-服务端和客户端互聊</a> 中，只能一人说一句，说了之后，必须等待另一个人的回复，才能说下一句。</p>
<p>这是因为接受和发送都在主线程中，不能同时进行。 为了实现同时收发消息，基本设计思路是把收发分别放在不同的线程中进行</p>
<p>\1. SendThread 发送消息线程 \2. RecieveThread 接受消息线程 \3. Server一旦接受到连接，就启动收发两个线程 \4. Client 一旦建立了连接，就启动收发两个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SendThread</span><span class="params">(Socket s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                dos.writeUTF(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecieveThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecieveThread</span><span class="params">(Socket s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动发送消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SendThread</span>(s).start();</span><br><span class="line">            <span class="comment">//启动接受消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RecieveThread</span>(s).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动发送消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SendThread</span>(s).start();</span><br><span class="line">            <span class="comment">// 启动接受消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RecieveThread</span>(s).start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
