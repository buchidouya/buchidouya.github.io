<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot红包小程序</title>
    <url>/2022/04/08/Spring-Boot%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="DOS操作"><a href="#DOS操作" class="headerlink" title="DOS操作"></a>DOS操作</h1><p>打包：mvn clean package</p>
<p>启动：java -jar target&#x2F;luckymoney-0.0.1-SNAPSHOT.jar</p>
<p>启动：java -jar target&#x2F;luckymoney-0.0.1-SNAPSHOT.jar</p>
<p>启动prod配置：java -jar -Dspring.profiles.active&#x3D;prod target&#x2F;luckymoney-0.0.1-SNAPSHOT.jar</p>
<span id="more"></span>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><strong>软件版本：java1.8，maven3.5.4，mysql5.7.25</strong></p>
<p>单个配置@Value</p>
<p>配置很多，并且配置之间有联系，则把配置放到类里面去，然后使用@Component</p>
<p>将类连接yml配置@ConfigurationProperties</p>
<h1 id="Controller的使用"><a href="#Controller的使用" class="headerlink" title="Controller的使用"></a>Controller的使用</h1><p>@Controller：处理http请求</p>
<p>@RestController：Spring4之后新加的注解，原来返回json需要@ResponseBody配合@Controller</p>
<p>@RequestMapping：配置url映射（旧版注解，新版可以使用@GetMapping）</p>
<p>@Controller + @ResponseBody &#x3D; @RestController</p>
<p>@GetMapping：只支持GET请求访问</p>
<p>@PostMapping：只支持POST请求访问</p>
<p>@RequestMapping：GET、POST都支持（最好指定POST或者GET，最好不要用@RequestMapping）</p>
<p>@PathVariable：获取url中的数据</p>
<p>@RequestParam：获取请求参数的值</p>
<h1 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h1><h2 id="LuckymoneyApplication"><a href="#LuckymoneyApplication" class="headerlink" title="LuckymoneyApplication"></a>LuckymoneyApplication</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckymoneyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LuckymoneyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="练习配置"><a href="#练习配置" class="headerlink" title="练习配置"></a>练习配置</h1><h2 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LimitConfig limitConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/say&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;)</span> Integer myId)</span> &#123;</span><br><span class="line"><span class="comment">//		return &quot;说明：&quot; + limitConfig.getDescription();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span> + myId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LimitConfig"><a href="#LimitConfig" class="headerlink" title="LimitConfig"></a>LimitConfig</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;limit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal minMoney;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal maxMoney;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getMinMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinMoney</span><span class="params">(BigDecimal minMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minMoney = minMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getMaxMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxMoney</span><span class="params">(BigDecimal maxMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxMoney = maxMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDescription</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h1><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<h2 id="application-dev-yml"><a href="#application-dev-yml" class="headerlink" title="application-dev.yml"></a>application-dev.yml</h2><p><strong>注意：在<code>url</code>结尾一定要加<code>&amp;serverTimezone=Asia/Shanghai</code>，不然Spring Boot连接数据库的时候会报错</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/luckymoney</span></span><br><span class="line"></span><br><span class="line"><span class="attr">limit:</span></span><br><span class="line">  <span class="attr">minMoney:</span> <span class="number">0.01</span></span><br><span class="line">  <span class="attr">maxMoney:</span> <span class="number">9999</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">最少要发$&#123;limit.minMoney&#125;元,</span> <span class="string">最多$&#123;limit.maxMoney&#125;元</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/luckymoney?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="application-prov-yml"><a href="#application-prov-yml" class="headerlink" title="application-prov.yml"></a>application-prov.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/luckymoney</span></span><br><span class="line"></span><br><span class="line"><span class="attr">limit:</span></span><br><span class="line">  <span class="attr">minMoney:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxMoney:</span> <span class="number">9999</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">最少要发$&#123;limit.minMoney&#125;元,</span> <span class="string">最多$&#123;limit.maxMoney&#125;元</span></span><br></pre></td></tr></table></figure>

<h1 id="红包类定义参数"><a href="#红包类定义参数" class="headerlink" title="红包类定义参数"></a>红包类定义参数</h1><h2 id="Luckymoney"><a href="#Luckymoney" class="headerlink" title="Luckymoney"></a>Luckymoney</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.DynamicUpdate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Luckymoney</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送方</span></span><br><span class="line">    <span class="keyword">private</span> String producer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收方</span></span><br><span class="line">    <span class="keyword">private</span> String consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Luckymoney</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(BigDecimal money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProducer</span><span class="params">(String producer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.producer = producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConsumer</span><span class="params">(String consumer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.consumer = consumer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dependency配置"><a href="#dependency配置" class="headerlink" title="dependency配置"></a>dependency配置</h1><h2 id="pom-xml配置"><a href="#pom-xml配置" class="headerlink" title="pom.xml配置"></a>pom.xml配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>luckymoney<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>luckymoney<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="RESTful-API设计"><a href="#RESTful-API设计" class="headerlink" title="RESTful API设计"></a>RESTful API设计</h1><p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220408172153989.png" alt="image-20220408172153989"></p>
<h2 id="LuckymoneyController"><a href="#LuckymoneyController" class="headerlink" title="LuckymoneyController"></a>LuckymoneyController</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckymoneyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LuckmoneyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LuckymoneyService service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取红包列表</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/luckymoneys&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Luckymoney&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 查询所有的列表</span></span><br><span class="line">        <span class="keyword">return</span> repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建红包(发红包)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/luckymoneys&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Luckymoney <span class="title function_">create</span><span class="params">(<span class="meta">@RequestParam(&quot;producer&quot;)</span> String producer,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span> &#123;</span><br><span class="line">        <span class="type">Luckymoney</span> <span class="variable">luckymoney</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Luckymoney</span>();</span><br><span class="line">        luckymoney.setProducer(producer);</span><br><span class="line">        luckymoney.setMoney(money);</span><br><span class="line">        <span class="keyword">return</span> repository.save(luckymoney);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过id查询红包</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/luckymoneys/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Luckymoney <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">// orElse(null) 查到了返回Luckymoney对象，查不到返回null</span></span><br><span class="line">        <span class="keyword">return</span> repository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新红包(领红包)</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/luckymoneys/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Luckymoney <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(&quot;consumer&quot;)</span> String consumer)</span> &#123;</span><br><span class="line">        Optional&lt;Luckymoney&gt; optional = repository.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">            <span class="type">Luckymoney</span> <span class="variable">luckymoney</span> <span class="operator">=</span> optional.get();</span><br><span class="line">            luckymoney.setConsumer(consumer);</span><br><span class="line">            <span class="keyword">return</span> repository.save(luckymoney);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/luckymoneys/two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        service.createTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LuckmoneyRepository"><a href="#LuckmoneyRepository" class="headerlink" title="LuckmoneyRepository"></a>LuckmoneyRepository</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LuckmoneyRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Luckymoney, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="LuckymoneyService"><a href="#LuckymoneyService" class="headerlink" title="LuckymoneyService"></a>LuckymoneyService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.luckymoney;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckymoneyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LuckmoneyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务 指数据库事务 数据库引擎要更换成InnoDB才支持事务</span></span><br><span class="line">    <span class="comment">// 可以用于 扣库存 &gt; 创建订单 的同时性</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Luckymoney</span> <span class="variable">luckymoney1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Luckymoney</span>();</span><br><span class="line">        luckymoney1.setProducer(<span class="string">&quot;大毛&quot;</span>);</span><br><span class="line">        luckymoney1.setMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;520&quot;</span>));</span><br><span class="line">        repository.save(luckymoney1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Luckymoney</span> <span class="variable">luckymoney2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Luckymoney</span>();</span><br><span class="line">        luckymoney2.setProducer(<span class="string">&quot;大毛&quot;</span>);</span><br><span class="line">        luckymoney2.setMoney(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1314&quot;</span>));</span><br><span class="line">        repository.save(luckymoney2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>红包程序</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现高性能缓存</title>
    <url>/2022/04/07/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="非线程安全的缓存"><a href="#非线程安全的缓存" class="headerlink" title="非线程安全的缓存"></a>非线程安全的缓存</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中找不到，那么需要现在来计算一下结果，并保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟实际的业务中的计算逻辑，采用sleep代替</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cache1</span> <span class="variable">cache1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始计算了&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="用synchronized保证并发安全"><a href="#用synchronized保证并发安全" class="headerlink" title="用synchronized保证并发安全"></a>用synchronized保证并发安全</h1><ul>
<li>性能差（用synchronized之后，线程变成串行的了，多个线程不能同时访问computer方法了，与缓存的使用性不符合）</li>
<li>代码复用性差</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用synchronized保证并发安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中找不到，那么需要现在来计算一下结果，并保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟实际的业务中的计算逻辑，采用sleep代替</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cache1</span> <span class="variable">cache1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始计算了&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给HashMap加final关键字"><a href="#给HashMap加final关键字" class="headerlink" title="给HashMap加final关键字"></a>给HashMap加final关键字</h2><ul>
<li>属性被声明为final后，该变量则只能被赋值一次。且一旦被赋值，final的变量就不能再被改变。</li>
<li>所以我们把它加上final关键字，增强安全性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的缓存形式：HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用synchronized保证并发安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中找不到，那么需要现在来计算一下结果，并保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟实际的业务中的计算逻辑，采用sleep代替</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cache1</span> <span class="variable">cache1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始计算了&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = cache1.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用装饰者模式将缓存与计算逻辑解耦"><a href="#用装饰者模式将缓存与计算逻辑解耦" class="headerlink" title="用装饰者模式将缓存与计算逻辑解耦"></a>用装饰者模式将缓存与计算逻辑解耦</h1><ul>
<li><p>有一个计算函数compute，用来代表耗时计算，每个计算器都要实现这个接口，这样就可以无侵入实现缓存功能</p>
</li>
<li><p>我们假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情</p>
</li>
<li><p>缺点：</p>
<ul>
<li>性能差，不能并行计算（还是synchronized的问题）</li>
<li>Cache3 当多个线程同时想计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差</li>
</ul>
</li>
</ul>
<h2 id="Computable接口"><a href="#Computable接口" class="headerlink" title="Computable接口"></a>Computable接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache.computable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个计算函数compute，用来代表耗时计算，每个计算器都要实现这个接口，这样就可以无侵入实现缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computable</span> &lt;A, V&gt;&#123;</span><br><span class="line">    V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算逻辑ExpensiveFunction"><a href="#计算逻辑ExpensiveFunction" class="headerlink" title="计算逻辑ExpensiveFunction"></a>计算逻辑ExpensiveFunction</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache.computable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存Cache2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用装饰者模式，给计算器自动添加缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache2</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache2</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache2&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache2</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        result = expensiveCompute.compute(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程并发查询"><a href="#多线程并发查询" class="headerlink" title="多线程并发查询"></a>多线程并发查询</h2><p><strong>缓存Cache3多线程并发查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用装饰者模式，给计算器自动添加缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache3</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache3</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache3&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache3</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：其实第二个线程根本没必要等待第三个线程执行完毕</span><br><span class="line">进入缓存机制</span><br><span class="line">进入缓存机制</span><br><span class="line">第一个线程：<span class="number">667</span></span><br><span class="line">进入缓存机制</span><br><span class="line">第三个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<h1 id="锁性能优化"><a href="#锁性能优化" class="headerlink" title="锁性能优化"></a>锁性能优化</h1><h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p><strong>Cache4减小锁的粒度，试图提高性能</strong></p>
<ul>
<li>缺点：虽然提高了并发效率，但是并不意味着就是线程安全的，还需要考虑到同时读写等情况<ul>
<li>线程仍然不够安全，虽然多个线程不能同时写了，但是如果在写的同时读，同样是线程不安全的</li>
</ul>
</li>
<li>但是，其实没必要自己实现线程安全的HashMap，也不应该加synchronized，因为我们自己实现的性能远不如现有的并发集合</li>
<li>我们来使用ConcurrentHashMap优化我们的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩小synchronized的粒度，提高性能，但是依然并发不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache4</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache4</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            <span class="comment">// 缩小synchronized保护的范围</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                cache.put(arg, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache4&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache4</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发集合ConcurrentHashMap"><a href="#并发集合ConcurrentHashMap" class="headerlink" title="并发集合ConcurrentHashMap"></a>并发集合ConcurrentHashMap</h2><p><strong>Cache5采用并发集合ConcurrentHashMap保证并发安全</strong></p>
<ul>
<li>缺点：在计算完成前，另一个要求计算相同值的请求到来，会导致计算两遍，这和缓存想避免多次计算的初衷恰恰相反，是不可接受的</li>
</ul>
<p><strong>示意图：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220407124801817.png" alt="image-20220407124801817"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用ConcurrentHashMap保证并发安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache5</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache5</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache5&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache5</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="演示ConcurrentHashMap的缺点"><a href="#演示ConcurrentHashMap的缺点" class="headerlink" title="演示ConcurrentHashMap的缺点"></a>演示ConcurrentHashMap的缺点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示ConcurrentHashMap的缺点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache6</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache6</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache6&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache6</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p>三个线程同时进入缓存机制，5秒后同时给出了缓存结果，其实第一个线程和第三个线程重复计算了，并没有用到缓存结果，而是自己重新算了一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入缓存机制</span><br><span class="line">进入缓存机制</span><br><span class="line">进入缓存机制</span><br><span class="line">第三个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">667</span></span><br><span class="line">第一个线程：<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h1 id="避免重复计算Future和Callable"><a href="#避免重复计算Future和Callable" class="headerlink" title="避免重复计算Future和Callable"></a>避免重复计算Future和Callable</h1><p><strong>利用Future避免重复计算</strong></p>
<ul>
<li>动机：现在不同的线程进来以后，确实可以同时计算，但是如果两个线程脚前脚后，也就是相差无几的进来请求同一个数据那么我们来看看会出现什么问题：重复计算</li>
<li>这个例子只有2个线程，并不可怕，但是如果是100个线程都请求同样的内容，却都需要重新计算，那么会造成巨大的浪费</li>
<li>后面的线程，如果能知道前面的线程正在计算，并且计算的内容和我自己要计算的内容一样，那么我只要等待你的计算结果写入缓存之后直接使用即可</li>
<li>缺点：如果有两个同时计算666的线程，同时调用cache.get()方法那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Future避免重复计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache7</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache7</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新建一个任务</span></span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">            f = ft;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先将ft放入缓存，然后再进行计算</span></span><br><span class="line">            cache.put(arg, ft);</span><br><span class="line">            System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">            ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get()不是立即返回的，而是在算完了结果以后才会返回；有结果之前get()会堵塞</span></span><br><span class="line">        <span class="comment">// 当ft.run();执行完毕之后， Future&lt;V&gt; f里面就有值了</span></span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache7&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache7</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第一个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<p>缺点：如果有两个同时计算666的线程，同时调用cache.get()方法那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第一个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<h2 id="原子操作putIfAbsent"><a href="#原子操作putIfAbsent" class="headerlink" title="原子操作putIfAbsent"></a>原子操作putIfAbsent</h2><p>利用putIfAbsent优化Future小概率的重复计算</p>
<ul>
<li>利用Future可以避免重复计算，但是如果有两个同时计算666的线程，同时调用cache.get()方法那么返回的结果都为null，后面还是会创建两个任务去计算相同的值</li>
</ul>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220407190524546.png" alt="image-20220407190524546"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache8</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache8</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新建一个任务</span></span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">            f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                f = ft;</span><br><span class="line">                System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                ft.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache8&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache8</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br><span class="line">第一个线程：<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h1 id="ExcecutionException"><a href="#ExcecutionException" class="headerlink" title="ExcecutionException"></a>ExcecutionException</h1><h2 id="MayFail"><a href="#MayFail" class="headerlink" title="MayFail"></a>MayFail</h2><p><strong>耗时计算的实现类，有概率计算失败</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache.computable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时计算的实现类，有概率计算失败</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MayFail</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">random</span> <span class="operator">=</span> Math.random();</span><br><span class="line">        <span class="keyword">if</span> (random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;读取文件出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正确的异常处理逻辑-各司其职"><a href="#正确的异常处理逻辑-各司其职" class="headerlink" title="正确的异常处理逻辑(各司其职)"></a>正确的异常处理逻辑(各司其职)</h2><ul>
<li>这3种异常之所以用不同的catch块捕获，是因为它们的处理逻辑是不同的<ul>
<li>CancellationException和InterruptedException是人为取消的，那么我们应该立即终止任务</li>
<li>但是如果是计算错误，且我们明确知道多试几次就可以得到答案，那么我们的逻辑应该是重试，尝试多次直到正确的结果出现</li>
<li>在这里，我们加上while（true）来保证计算出错不会影响我们的逻辑，然后如果是计算错误，就进入下一个循环，重新计算，直到计算成功；如果是人为取消，那么就抛出异常然后结束运行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache9</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache9</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache9&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache9</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：一直循环(为什么？因为缓存被污染了)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="缓存污染问题"><a href="#缓存污染问题" class="headerlink" title="缓存污染问题"></a>缓存污染问题</h1><p><strong>使用cache.remove(arg);清楚被污染的缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.ExpensiveFunction;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache9</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache9</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 每个异常抛出以后，缓存都被清理掉了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache9&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache9</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三个线程：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第一个线程：<span class="number">666</span></span><br><span class="line">第二个线程：<span class="number">666</span></span><br><span class="line">第三个线程：<span class="number">667</span></span><br></pre></td></tr></table></figure>

<h1 id="缓存过期功能"><a href="#缓存过期功能" class="headerlink" title="缓存过期功能"></a>缓存过期功能</h1><ul>
<li><p>为每个结果指定过期时间，并定期扫描过期的元素</p>
</li>
<li><p>出于安全性考虑，缓存需要设置有效期，到期自动失效否则如果缓存一直不失效，那么会带来缓存不一致等问题</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出于安全性考虑，缓存需要设置有效期，到期自动失效否则如果缓存一直不失效，那么会带来缓存不一致等问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache10</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache10</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 每个异常抛出以后，缓存都被清理掉了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg, <span class="type">long</span> expire)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            executor.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    expire(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compute(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">(A key)</span> &#123;</span><br><span class="line">        Future&lt;V&gt; future = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果任务时间到了，还没有完成的话，直接取消任务</span></span><br><span class="line">            <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Future任务被取消&quot;</span>);</span><br><span class="line">                future.cancel(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;过期时间到，缓存被清除&quot;</span>);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache10&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache10</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>, <span class="number">5000L</span>);<span class="comment">// 5秒后过期</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第四次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从FutureTask调用了计算函数</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第一次计算结果：<span class="number">666</span></span><br><span class="line">第二次计算结果：<span class="number">666</span></span><br><span class="line">第三次计算结果：<span class="number">667</span></span><br><span class="line">过期时间到，缓存被清除</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">计算错误，需要重试</span><br><span class="line">从FutureTask调用了计算函数</span><br><span class="line">第四次计算结果：<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h1 id="高并发访问时"><a href="#高并发访问时" class="headerlink" title="高并发访问时"></a>高并发访问时</h1><ul>
<li><p>如果同时过期，那么同时都拿不到缓存，导致打爆cpu和MySQL，造成缓存雪崩、缓存击穿等高并发下的缓存问题</p>
</li>
<li><p>缓存过期时间设置为随机</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simple_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.Computable;</span><br><span class="line"><span class="keyword">import</span> simple_cache.computable.MayFail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出于安全性考虑，缓存需要设置有效期，到期自动失效否则如果缓存一直不失效，那么会带来缓存不一致等问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache11</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="comment">// Future包装value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache11</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 由于ConcurrentHashMap的可见性，当前一个线程写入了cache.put(arg, ft);的时候，后面的缓存就会得到f不是null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个任务</span></span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    System.out.println(<span class="string">&quot;从FutureTask调用了计算函数&quot;</span>);</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 每个异常抛出以后，缓存都被清理掉了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;被取消了&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误，需要重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存过期时间设置为随机</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">computeRandomExpire</span><span class="params">(A arg)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">randomExpire</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> compute(arg, randomExpire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg, <span class="type">long</span> expire)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            executor.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    expire(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compute(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">(A key)</span> &#123;</span><br><span class="line">        Future&lt;V&gt; future = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果任务时间到了，还没有完成的话，直接取消任务</span></span><br><span class="line">            <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Future任务被取消&quot;</span>);</span><br><span class="line">                future.cancel(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;过期时间到，缓存被清除&quot;</span>);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cache11&lt;String, Integer&gt; expensiveCompute = <span class="keyword">new</span> <span class="title class_">Cache11</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MayFail</span>());</span><br><span class="line">        <span class="comment">// 第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>, <span class="number">5000L</span>);<span class="comment">// 5秒后过期</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;第一次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第二次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;667&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第三次计算结果：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> expensiveCompute.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第四次计算结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
        <tag>高性能缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer刷题记录</title>
    <url>/2022/03/27/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></p>
<p><strong>原地哈希做法：时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i &amp;&amp; nums[nums[i]] != nums[i]) <span class="built_in">swap</span>(nums[nums[i]], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i &amp;&amp; nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>哈希表做法：时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ++hash[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums[i]] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关于原地哈希算法：时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(1)</em></strong></p>
<p>原地哈希用来解决这样一种问题：需要一个使得数组尽量有序的方式，并且要求时间复杂度达到O(n)。</p>
<p>一个长度为n的数组，所有的数都不相同，且数据的范围为[1,n]，如何在O(n)的时间复杂度内完成排序。</p>
<p><strong>原地哈希原理:</strong></p>
<p>实际上，我们在做一般排序的时候，是基于数字具体值的大小来决定顺序的，也就是说，数字具体值决定了数字应该去的位置。长度为n个数组，所有的数均不相同，不妨我们就让num[i]去到索引为num[i]的位置。实际上，num[i]就应该去索引为num[i]的位置上。</p>
<p>上述思路每一个位置上的置换都可以至少让一个数成功归位，因此复杂度为O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地哈希</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">while</span> (nums[i] - <span class="number">1</span> != i)</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></p>
<p><strong>暴力做法：</strong></p>
<p><strong>时间复杂度：<em>O(n * log<sub>2<sub>n)</em></strong></p>
<p>将数据进行排序，预设答案为ans &#x3D; 1(ans为没有枚举到的答案的最小可能值)，开始遍历整个数组，如果发生了 ans &#x3D;&#x3D; num[i]，则ans++(因为这个数字出现了，我们要看下一个数字有没有出现)。如果发生了num[i] &gt; ans的情况，由ans自增的逻辑我们可以知道，在数据保持相邻不变或者递增1的情况下，ans &gt;&#x3D; num[i]是必定成立的，如果num[i]&gt;ans，则一定是发生了跳跃，此时ans必为答案。如果能够循环到数组结束，那么答案就是ans。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == ans) &#123;</span><br><span class="line">                ans++; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; ans) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>原地哈希做法：</strong></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        	<span class="comment">// nums[i] &gt; 0 （数值小于1的数，对答案没有任何贡献，所以可以直接忽略）</span></span><br><span class="line">        	<span class="comment">// nums[i] &lt;= len 一个长度为 len 的数组，他所能够形成的答案的最大值为 len + 1</span></span><br><span class="line">        	<span class="comment">// nums[nums[i]] != nums[i] （如果数组中有重复的数，他们可能会形成闭合的死循环，此处避免无限交换）</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i]]!=nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></p>
<p><strong>思路：</strong></p>
<p>从整个矩阵的右上角开始枚举，假设当前枚举的数是 x：<br>如果 x 等于 target，则说明我们找到了目标值，返回true；<br>如果 x 小于 target，则 x 左边的数一定都小于 target，我们可以直接排除当前一整行的数；<br>如果 x 大于 target，则 x 下边的数一定都大于 target，我们可以直接排序当前一整列的数。</p>
<p><strong>时间复杂度：<em>O(n + m)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target) j--;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">        &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> targe = <span class="number">20</span>;</span><br><span class="line">    <span class="type">bool</span> have = <span class="built_in">findNumberIn2DArray</span>(matrix, targe);</span><br><span class="line">    cout &lt;&lt; have &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) str += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> str += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) str += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> str += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">replaceSpace</span>(<span class="string">&quot;&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 循环构造链表</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环输出原链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    Solution solution;</span><br><span class="line">    ans = solution.<span class="built_in">reversePrint</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></p>
<p><strong>思路：</strong></p>
<ol>
<li>先利用前序遍历找根节点 k ：前序遍历的第一个数，就是根节点的值；</li>
<li>在中序遍历中找到根节点的位置 k，则 k 左边是左子树的中序遍历，右边是右子树的中序遍历；</li>
<li>假设左子树的中序遍历的长度是 l，则在前序遍历中，根节点后面的 l 个数，是左子树的前序遍历，剩下的数是右子树的前序遍历；</li>
<li>有了左右子树的前序遍历和中序遍历，我们可以先递归创建出左右子树，然后再创建根节点；</li>
</ol>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 采用哈希表几率中序遍历各个节点的位置，方便查询，因为哈希表查询是O(1)的</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="comment">// 定义全局变量，方便多函数使用</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorder, inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; _preorder, vector&lt;<span class="type">int</span>&gt;&amp; _inorder)</span> </span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">             hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs(前序遍历开头，结尾，中序遍历开头，结尾)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果左边大于右边了，说明到叶子节点了</span></span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 根节点就是前序遍历的第一个点</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pl]);</span><br><span class="line">        <span class="comment">// 根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="type">int</span> k = hash[preorder[pl]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归前序遍历和中序遍历得到左右子树的根节点</span></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(pl + <span class="number">1</span>, pl + k - il, il, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">dfs</span>(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h1><p><a href="https://www.acwing.com/activity/content/problem/content/214/">二叉树的下一个节点</a></p>
<p><strong>思路：</strong></p>
<ol>
<li>如果给的点有右儿子，那就是右子树最左边的那个点</li>
<li>如果给的点没有右儿子，那就看他有没有父节点，如果这个点有父节点，并且他是父节点的左儿子，那这个点的后继就是他的父节点</li>
<li>如果给的点没有右儿子，并且他是父节点的右儿子，那就要顺着父节点一直往上找，一直到这个点是父节点的左儿子，那后继就是这个父节点</li>
<li>如果根据3，找不到，就说明这个点没有后继</li>
</ol>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode *father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果给的点有右儿子，那就是右子树最左边的那个点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) &#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果给的点没有右儿子，那就看他有没有父节点，如果这个点有父节点，并且他是父节点的左儿子，那这个点的后继就是他的父节点</span></span><br><span class="line">        <span class="comment">// 如果给的点没有右儿子，并且他是父节点的右儿子，那就要顺着父节点一直往上找，一直到这个点是父节点的左儿子，那后继就是这个父节点</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;father &amp;&amp; p-&gt;father-&gt;right == p) &#123;</span><br><span class="line">            p = p-&gt;father;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;father &amp;&amp; p-&gt;father-&gt;left == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果还找不到，就说明这个点没有后继</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码（简化版）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode *father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">             p = p-&gt;right;</span><br><span class="line">             <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = stk.<span class="built_in">top</span>();</span><br><span class="line">            cache.<span class="built_in">push</span>(i);</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = cache.<span class="built_in">top</span>();</span><br><span class="line">        cache.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (cache.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = cache.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">            cache.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列</a></p>
<p><strong>思路：</strong></p>
<p>模拟一遍即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            c = a % <span class="number">1000000007</span> + b % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            c = a % <span class="number">1000000007</span> + b % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">fib</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶问题</a></p>
<p><strong>思路：dp思想</strong></p>
<p>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。</p>
<ol>
<li>当为 1 级台阶： 此情况共有 f(n−1) 种跳法；</li>
<li>当为 2 级台阶： 此情况共有 f(n−2) 种跳法。</li>
</ol>
<p>f(n) 为以上两种情况之和，即 f(n) &#x3D; f(n - 1) + f(n - 2) ，以上递推性质为斐波那契数列。本题可转化为求斐波那契数列第 n 项的值 。<br>青蛙跳台阶问题： f(0)&#x3D;1, f(1)&#x3D;1 , f(2)&#x3D;2；<br>斐波那契数列问题： f(0)&#x3D;0, f(1)&#x3D;1, f(2)&#x3D;1。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            c = a % <span class="number">1000000007</span> + b % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></p>
<p><strong>二分做法：<em>O(log<sub>2<sub>n)</em></strong></p>
<ol>
<li><p>去掉最后面的一段<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-39-20.png" alt="在这里插入图片描述"></p>
</li>
<li><p>如果是单调的，那么直接返回第一个数即可</p>
</li>
<li><p>通过二分查找排在最前面的比nums[0]小的数，就是最小值</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; numbers[n] == numbers[<span class="number">0</span>]) n--;</span><br><span class="line">        <span class="keyword">if</span> (numbers[n] &gt;= numbers[<span class="number">0</span>]) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt;= numbers[<span class="number">0</span>]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>暴力做法：时间复杂度：<em>O(n)</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minv = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            minv = <span class="built_in">min</span>(minv, numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径</a></p>
<p><strong>时间复杂度：<em>O(3<sup>n</sup>)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 其中的0是已经有0个字母合法，当合法字母数量与word字符数量相同时，就可以返回true了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, <span class="number">0</span>, i, j, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> u, <span class="type">int</span> i, <span class="type">int</span> j, string &amp;word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里一定要记得-1，因为u是从0开始的，笔者之前忘记-1了，调试过后才发现是这里错了</span></span><br><span class="line">        <span class="keyword">if</span> (u == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照上，右，下，左枚举</span></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将走过的路径保存下来，并且置为&#x27;*&#x27;，避免走回头路</span></span><br><span class="line">        <span class="type">char</span> t = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> a = i + dx[k], b = j + dy[k];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; board.<span class="built_in">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, u + <span class="number">1</span>, a, b, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 其中的0是已经有0个字母合法，当合法字母数量与word字符数量相同时，就可以返回true了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, <span class="number">0</span>, i, j, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> u, <span class="type">int</span> i, <span class="type">int</span> j, string &amp;word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里一定要记得-1，因为u是从0开始的，笔者之前忘记-1了，调试过后才发现是这里错了</span></span><br><span class="line">        <span class="keyword">if</span> (u == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照上，右，下，左枚举</span></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将走过的路径保存下来，并且置为&#x27;*&#x27;，避免走回头路</span></span><br><span class="line">        <span class="type">char</span> t = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> a = i + dx[k], b = j + dy[k];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; board.<span class="built_in">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, u + <span class="number">1</span>, a, b, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; board = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    string word = <span class="string">&quot;ABCCED&quot;</span>;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">exist</span>(board, word) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></p>
<p><strong>解法选择：</strong></p>
<p>此类问题可以用深度优先遍历和宽度优先遍历，但是当数据范围比较大的时候，可能会栈溢出，所以这里使用宽度优先遍历解答</p>
<p><strong>时间复杂度：O(n * m)</strong></p>
<p>bfs时间复杂度就是所有的格子遍历一遍，也就是n * m，根据数据范围可知，最多是2500个格子</p>
<p><strong>注意：剑指offer系列和LeetCode特色就是有一些特判的边界</strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算一个数的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个坐标的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_single_sum</span>(t.first) + <span class="built_in">get_single_sum</span>(t.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (!m || !n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义一个二维数组st，用来储存已经走过的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 用来存放遍历到的每一个坐标，所以用pair类型的队列</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先给队列里面放入初始位置的坐标</span></span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果对头元素没有走过，并且各个位之和也符合要求的话才能++，否则continue</span></span><br><span class="line">            <span class="keyword">if</span> (st[t.first][t.second] || <span class="built_in">get_sum</span>(t) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算一个数的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个坐标的各个位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_single_sum</span>(t.first) + <span class="built_in">get_single_sum</span>(t.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断一下边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (!m || !n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义一个二维数组st，用来储存已经走过的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 用来存放遍历到的每一个坐标，所以用pair类型的队列</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先给队列里面放入初始位置的坐标</span></span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果对头元素没有走过，并且各个位之和也符合要求的话才能++，否则continue</span></span><br><span class="line">            <span class="keyword">if</span> (st[t.first][t.second] || <span class="built_in">get_sum</span>(t) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">movingCount</span>(m, n, k) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剪绳子</a></p>
<p><strong>思路：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-40-28.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码（可以先看最后会不会余下4或者2）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码（也可以先把3减掉，看剩下的是多少）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">6</span>) res *= <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">5</span>) res *= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">4</span>) res *= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">6</span>) res *= <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">5</span>) res *= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">4</span>) res *= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">cuttingRope</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a>剪绳子 II</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>思路一：</strong></p>
<p>res用long long</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n -= <span class="number">3</span>, res %= <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>res仅用int，把res * 3可能溢出int，那就res 加3次，用加法代替乘法即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    	<span class="comment">// 加法代替乘法</span></span><br><span class="line">        <span class="type">int</span> temp = res;</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">        res %= <span class="number">1000000007</span>;</span><br><span class="line">        res += temp;</span><br><span class="line">        res %= <span class="number">1000000007</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></p>
<p><strong>思路：</strong></p>
<p>n &amp; 1 看最后一位是否是1，n &gt;&gt;&#x3D; 1 去掉最后一位</p>
<p><strong>时间复杂度：<em>O(log<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">uint32_t</span> n = <span class="number">-3</span>;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">hammingWeight</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></p>
<p><strong>思路：</strong></p>
<p>快速幂，将幂次变成二进制幂次即可</p>
<p><strong>时间复杂度：<em>O(log<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n2 = <span class="built_in">abs</span>((<span class="type">long</span> <span class="type">long</span>)n);</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2 &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">            n2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = x * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n2 = <span class="built_in">abs</span>((<span class="type">long</span> <span class="type">long</span>)n);</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2 &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">            n2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = x * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">myPow</span>(x, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">pow</span>(<span class="number">10</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h1><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>方法一：</strong></p>
<p>由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。我们可以换一种思路，将下一个节点的值复制到当前节点，然后将下一个节点删除即可。</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i是最后一个点，那就重新遍历，删除最后一个点</span></span><br><span class="line">        <span class="keyword">if</span> (!i-&gt;next) &#123;</span><br><span class="line">            i = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (; i-&gt;next &amp;&amp; i-&gt;next-&gt;next; i = i-&gt;next);</span><br><span class="line">            i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则将下一个节点的值复制到当前节点，然后将下一个节点删除即可</span></span><br><span class="line">        i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出链表规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i是最后一个点，那就重新遍历，删除最后一个点</span></span><br><span class="line">        <span class="keyword">if</span> (!i-&gt;next) &#123;</span><br><span class="line">            i = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (; i-&gt;next &amp;&amp; i-&gt;next-&gt;next; i = i-&gt;next);</span><br><span class="line">            i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则将下一个节点的值复制到当前节点，然后将下一个节点删除即可</span></span><br><span class="line">        i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是自己构造一个链表，用来测试样例</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入要删除的节点：&quot;</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    cin &gt;&gt; val;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点后的链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> head = solution.<span class="built_in">deleteNode</span>(dummy-&gt;next, val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>找到那个要删除的节点，把这个节点后面的节点的值全部前移，然后把最后一个点删掉</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!i-&gt;next) &#123;</span><br><span class="line">            i = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (; i-&gt;next-&gt;next; i = i-&gt;next);</span><br><span class="line">            i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i; i-&gt;next-&gt;next; i = i-&gt;next) &#123;</span><br><span class="line">            i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        i-&gt;val = i-&gt;next-&gt;val;</span><br><span class="line">        i-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<p>记录要删除的点是第几个点，然后再重新遍历一遍，把他删掉</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = head;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = dummy;</span><br><span class="line">        <span class="keyword">while</span> (res--) &#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="在O-1-时间删除链表结点"><a href="#在O-1-时间删除链表结点" class="headerlink" title="在O(1)时间删除链表结点"></a>在O(1)时间删除链表结点</h1><p><a href="https://www.acwing.com/problem/content/description/85/">在O(1)时间删除链表结点</a></p>
<p><strong>思路：</strong></p>
<p>由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。</p>
<p>我们可以换一种思路，将下一个节点的值复制到当前节点，然后将下一个节点删除即可。</p>
<p>只有常数次操作，所以时间复杂度是 O(1)O(1)。</p>
<p><strong>时间复杂度：<em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h1><p><a href="https://www.acwing.com/problem/content/27/">删除链表中重复的节点</a></p>
<p><strong>方法一：</strong></p>
<p>双指针算法：从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。</p>
<ol>
<li>p是上一个区间里面的最后一个节点</li>
<li>q是下一个区间里面的第一个节点<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-41-26.png" alt="在这里插入图片描述"></li>
<li>如果 <code>p-&gt;next-&gt;next != q</code> ， 如上图所示，那么就要删除这一整段，即 <code>p-&gt;next = q</code> ，如下图所示<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-41-49.png" alt="在这里插入图片描述"></li>
<li>如果下个区间里面只有 <code>p-&gt;next</code> 这一个元素，那么这个点满足要求，那么p移动到下个点也就是 <code>p-&gt;next</code> ，<code>if (p-&gt;next-&gt;next == q) p = p-&gt;next;</code>  ，如下两图所示<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-42-13.png" alt="在这里插入图片描述"></li>
</ol>
<p><strong>时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">// p是上一个区间里面的最后一个节点</span></span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// q是下一个区间里面的第一个节点</span></span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            <span class="comment">// q一直往后，直到移动到下下个区间的第一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;</span><br><span class="line">            <span class="comment">// 如果下个区间里面只有一个元素，那么这个点满足要求，那么p移动到下个点，这个点是这个区间唯一的点，所以也是这个区间最后的一个点</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;next == q) p = p-&gt;next;</span><br><span class="line">            <span class="comment">// 否则把下个区间整段删掉，p还是原区间最后一个节点</span></span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>用哈希表，扫描一次链表，把只出现一次的数存起来。然后再扫描链表，将只出现一次的数筛选出来接上。</p>
<p><strong>时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            hash[i-&gt;val]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i-&gt;val] == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = i;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除末尾重复的数</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next &amp;&amp; p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">// 如果所有数全部重复，则直接接上NULL</span></span><br><span class="line">        <span class="keyword">if</span> (s == k) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出链表规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            hash[i-&gt;val]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i-&gt;val] == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = i;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next &amp;&amp; p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == k) p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="comment">// 这里是自己构造一个链表，用来测试样例</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点后的链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> head = solution.<span class="built_in">deleteDuplication</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<p>利用有序哈希表存储出现的次数，将只出现一次的接在新的链表末尾。</p>
<p><strong>时间复杂度：<em>O(n)<em>，空间复杂度：</em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            hash[i-&gt;val]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.second == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(x.first);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串</a><br>很多情况需要排除，只能多做才能熟练</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k--;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, k + <span class="number">1</span>); <span class="comment">// 除去后空格</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++; <span class="comment">// 除去前空格</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) i++; <span class="comment">// 除去+, -</span></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 除去+, -, +., -., .</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dot = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                dot++;</span><br><span class="line">                <span class="keyword">if</span> (dot &gt; <span class="number">1</span> || e) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果有两个小数点，或者e后面有小数点，则false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                e++;</span><br><span class="line">                <span class="keyword">if</span> (!i || i + <span class="number">1</span> == s.<span class="built_in">size</span>() || e &gt; <span class="number">1</span> || (s[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; i == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1231e+</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k--;</span><br><span class="line">    s = s.<span class="built_in">substr</span>(<span class="number">0</span>, k + <span class="number">1</span>);  <span class="comment">// 除去后空格</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++; <span class="comment">// 除去前空格</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) i++; <span class="comment">// 除去+, -</span></span><br><span class="line">    s = s.<span class="built_in">substr</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 除去+, -, +., -., .</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dot = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dot++;</span><br><span class="line">            <span class="keyword">if</span> (dot &gt; <span class="number">1</span> || e) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果有两个小数点，或者e后面有小数点，则false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            e++;</span><br><span class="line">            <span class="keyword">if</span> (!i || i + <span class="number">1</span> == s.<span class="built_in">size</span>() || e &gt; <span class="number">1</span> || (s[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; i == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">2</span> == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1231e+</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isNumber</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p>警惕数组越界即可，即应该先判断 l &lt;&#x3D; r, r &gt;&#x3D; l</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] % <span class="number">2</span> == <span class="number">1</span>) l++;</span><br><span class="line">            <span class="keyword">while</span> (r &gt;= l &amp;&amp; nums[r] % <span class="number">2</span> == <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) <span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] % <span class="number">2</span> == <span class="number">1</span>) l++;</span><br><span class="line">            <span class="keyword">while</span> (r &gt;= l &amp;&amp; nums[r] % <span class="number">2</span> == <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) <span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; n = solution.<span class="built_in">exchange</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : n) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n + <span class="number">1</span> - k;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码(迭代法)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = pn) &#123;</span><br><span class="line">            pn = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出链表规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = pn) &#123;</span><br><span class="line">            pn = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是自己构造一个链表，用来测试样例</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = dummy-&gt;next; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> head = solution.<span class="built_in">reverseList</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码(递归法)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> tail = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a></p>
<p><strong>思路：</strong></p>
<p>类似归并排序的算法</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l1p = l1, l2p = l2;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1p &amp;&amp; l2p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1p-&gt;val &lt;= l2p-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1p;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1p = l1p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2p;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2p = l2p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1p) &#123;</span><br><span class="line">            cur-&gt;next = l1p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            l1p = l1p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2p) &#123;</span><br><span class="line">            cur-&gt;next = l2p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            l2p = l2p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></p>
<p><strong>时间复杂度：<em>O(nm)</em></strong></p>
<p>最坏情况下，我们对于树A中的每个节点都要递归判断一遍，每次判断在最坏情况下需要遍历完树B中的所有节点。<br>所以时间复杂度是 O(nm)，其中 n 是树A中的节点数， m 是树B中的节点数。</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPart</span>(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPart</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A &amp;&amp; A-&gt;val == B-&gt;val) <span class="keyword">return</span> <span class="built_in">isPart</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">isPart</span>(A-&gt;right, B-&gt;right); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></p>
<p><strong>思路：</strong></p>
<p>我们可以发现镜像后的树就是将原树的所有节点的左右儿子互换！<br>所以我们递归遍历原树的所有节点，将每个节点的左右儿子互换即可。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* p;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root;</span><br><span class="line">        p = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = p;</span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; r || l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;val == r-&gt;val) <span class="keyword">return</span> <span class="built_in">dfs</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> di[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dj[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; k &lt; n * m; k++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> a = i + di[r], b = j + dj[r];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; m &amp;&amp; f[a][b] == <span class="number">0</span>) &#123;</span><br><span class="line">                i = a, j = b;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = (r + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                i = i + di[r], j = j + dj[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈</a></p>
<p><strong>思路：</strong></p>
<p><strong>单调栈：</strong><br>我们除了维护基本的栈结构之外，还需要维护一个单调栈，来实现返回最小值的操作。<br>下面介绍如何维护单调栈：</p>
<ul>
<li>当我们向栈中压入一个数时，如果该数 ≤ 单调栈的栈顶元素，则将该数同时压入单调栈中；否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。</li>
<li>当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。</li>
<li>单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数。</li>
</ul>
<p><strong>时间复杂度：<em>O(1)</em></strong></p>
<p>四种操作都只有常数次入栈出栈操作，所以时间复杂度都是O(1)</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; res, cache;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push</span>(x);</span><br><span class="line">            cache.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">top</span>() &gt;= x) cache.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">top</span>() == cache.<span class="built_in">top</span>()) cache.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列</a></p>
<p><strong>思路：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-43-21.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushed.<span class="built_in">empty</span>() &amp;&amp; pushed.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pushed.<span class="built_in">size</span>() != popped.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : pushed) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushed.<span class="built_in">empty</span>() &amp;&amp; pushed.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pushed.<span class="built_in">size</span>() != popped.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : pushed) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pushed = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; popped = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">validateStackSequences</span>(pushed, popped) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a>从上到下打印二叉树 II</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (level.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">                level.<span class="built_in">clear</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="从上到下打印二叉树-III"><a href="#从上到下打印二叉树-III" class="headerlink" title="从上到下打印二叉树 III"></a>从上到下打印二叉树 III</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/">从上到下打印二叉树 III</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">        <span class="comment">// 奇数行为false</span></span><br><span class="line">        <span class="type">bool</span> z = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (level.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偶数行翻转level</span></span><br><span class="line">                <span class="keyword">if</span> (z) <span class="built_in">reverse</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>());</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">                level.<span class="built_in">clear</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偶数行为true</span></span><br><span class="line">                z = !z;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列</a></p>
<p><strong>思路：</strong></p>
<p><strong>合法样例:</strong><br>后序遍历二叉树，10为根节点，左子树的所有节点都比根节点小，右子树的所有点都比根节点大<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-43-48.png" alt="在这里插入图片描述"><br>递归左右子树<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-44-04.png" alt="在这里插入图片描述"><br><strong>不合法样例</strong><br>无法分成比10小和比10大的左右两边<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-44-17.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        pos = postorder;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, pos.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> root = pos[r];</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; r &amp;&amp; pos[k] &lt;= root; k++);</span><br><span class="line">        <span class="type">int</span> tempR = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[k] &gt; root) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(l, tempR) &amp;&amp; <span class="built_in">dfs</span>(tempR + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></p>
<p><strong>思路：</strong></p>
<p>直接DFS走一遍即可</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> tar;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        tar = target;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, u, res);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* &amp;root, <span class="type">int</span> u, vector&lt;<span class="type">int</span>&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        u += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (u == tar &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, u, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, u, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></p>
<p><strong>方法一：</strong></p>
<p>哈希表存储原链表节点和新链表节点的对应关系，先构建只有 next 的新链表<br>然后再遍历原链表，把原链表的 random 对应的哈希表储存的节点赋给新链表的 random</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 哈希表存储原链表节点和新链表节点的对应关系</span></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-10005</span>);</span><br><span class="line">    <span class="comment">// 当前遍历到的节点</span></span><br><span class="line">    Node* cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> np = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val); </span><br><span class="line">            cur-&gt;next = np;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            hash.<span class="built_in">insert</span>(&#123;p, np&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random) &#123;</span><br><span class="line">                cur = hash[p];</span><br><span class="line">                cur-&gt;random = hash[p-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>原链表图形：<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-45-46.png" alt="Snipaste_2022-02-19_18-54-11.png"><br>1、在每个节点的后面加上它的复刻，将原链表和复刻链表连在一起。<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-46-06.png" alt="Snipaste_2022-02-19_18-54-24.png"><br>2、从前往后遍历每一个原链表节点，对于有random指针的节点p，我们让它的<br>p-&gt;next-&gt;random &#x3D; p-&gt;random-&gt;next,这样我们就完成了对原链表random指针的复刻。<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-46-23.png" alt="Snipaste_2022-02-19_18-58-52.png"><br>3、最后我们把原链表和复刻链表拆分出来，并将原链表复原。<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-46-37.png" alt="Snipaste_2022-02-19_18-59-00.png"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> np = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            np-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = np;</span><br><span class="line">            p = np-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-10005</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next = p-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前面破坏了原链表，这里要恢复链表</span></span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/"> 二叉搜索树与双向链表</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p>原地算法，没有新建任何节点</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        pair&lt;Node*, Node*&gt; sides = <span class="built_in">dfs</span>(root);</span><br><span class="line">        sides.first-&gt;left = sides.second;</span><br><span class="line">        sides.second-&gt;right = sides.first;</span><br><span class="line">        <span class="keyword">return</span> sides.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;Node*, Node*&gt; <span class="title">dfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> &#123;root, root&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lside = <span class="built_in">dfs</span>(root-&gt;left), rside = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            lside.second-&gt;right = root, root-&gt;left = lside.second;</span><br><span class="line">            rside.first-&gt;left = root, root-&gt;right = rside.first;</span><br><span class="line">            <span class="keyword">return</span> &#123;lside.first, rside.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lside = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            lside.second-&gt;right = root, root-&gt;left = lside.second;</span><br><span class="line">            <span class="keyword">return</span> &#123;lside.first, root&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> rside = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            rside.first-&gt;left = root, root-&gt;right = rside.first;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, rside.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/submissions/">序列化二叉树</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">dfs_s</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, string &amp;res)</span> </span>&#123; <span class="comment">// 构造前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            res += <span class="string">&quot;null &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">dfs_s</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">dfs_s</span>(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(string data, <span class="type">int</span> &amp;u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == data.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u; <span class="comment">// 记录当前这个数是几位数</span></span><br><span class="line">        <span class="keyword">while</span> (data[k] != <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前字符串是“null”，则回到下一个数字的首部，表示这次构造的是一个null节点，并没孩子节点，所以跳过后面的递归</span></span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">            u = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>; <span class="comment">// val存的是当前的数字</span></span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">&#x27;-&#x27;</span>) &#123; <span class="comment">// 如果数字是负的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u + <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + data[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = -val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数字是正的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; k; i++) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + data[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u = k + <span class="number">1</span>; <span class="comment">// 回到下个数字的首部</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/submissions/">字符串的排列</a></p>
<p><strong>思路：</strong></p>
<p>做一次全排列（DFS+回溯），然后用哈希表去重。最容易想到的办法，但是时间复杂度不太好，相当于暴力做法</p>
<p><strong>时间复杂度：<em>O(n<sup>n</sup>)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="type">bool</span> st[<span class="number">10</span>];</span><br><span class="line">    unordered_set&lt;string&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s, u);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(path) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                hash.<span class="built_in">insert</span>(path);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                path += s[i];</span><br><span class="line">                u++;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s, u);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                u--;</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></p>
<p><strong>思路：</strong></p>
<p>超过一半，快排以后取中间的数即可</p>
<p><strong>时间复杂度：<em>O(nlog<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></p>
<p><strong>思路：</strong></p>
<p>快排，取前 k 个数</p>
<p><strong>时间复杂度：<em>O(nlog<sub>2<sub>n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数</a></p>
<p><strong>思路：</strong></p>
<p>暴解肯定不行，因为 n 最多是 50000，n<sup>2</sup>logn会超时。</p>
<p><strong>这题可以使用大小堆算法：</strong> 维护大根堆和小根堆的时间复杂度都是 O(logn)<br>输入的时候将数字分为两半，小的一半放在大根堆中，大的一半放在小根堆的中。输入的同时保证两堆的大小之差不超过一，如果超过，则将数量多的堆弹出堆顶元素放到另一个堆中。<br>取中位数的时候，奇数返回数量多的堆顶元素；偶数返回两堆的堆顶平均数即可。</p>
<p><strong>时间复杂度：<em>O(logn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大根堆，也就是根节点是最大的</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; max_heap; </span><br><span class="line">    <span class="type">int</span> max_num = <span class="number">0</span>; <span class="comment">// 大根堆中节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆，也就是根节点是最小的</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; min_heap; </span><br><span class="line">    <span class="type">int</span> min_num = <span class="number">0</span>; <span class="comment">// 小根堆中节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为空时，插入大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (max_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">            max_num++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// num 如果小于等于大根堆堆顶，就把他插入大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt;= max_heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">            max_num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">            min_num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果大小根堆数量之差大于 1 那么就把多的弹到另一个堆里面</span></span><br><span class="line">        <span class="keyword">if</span> (max_num - min_num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(max_heap.<span class="built_in">top</span>());</span><br><span class="line">            max_heap.<span class="built_in">pop</span>();</span><br><span class="line">            max_num--;</span><br><span class="line">            min_num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_num - max_num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(min_heap.<span class="built_in">top</span>());</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">            max_num++;</span><br><span class="line">            min_num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((max_num + min_num) % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(max_heap.<span class="built_in">top</span>() + min_heap.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max_num &gt; min_num ? (<span class="type">double</span>)max_heap.<span class="built_in">top</span>() : (<span class="type">double</span>)min_heap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></p>
<p><strong>思路：</strong></p>
<p><strong>动态规划：</strong><br>s这个变量中存储的是 以前一个数结尾的子数组中，和最大的是多少<br>如果s &lt; 0，那么就将s置为0，因为可能存在负数，不能将负收益的s加进来<br>如果s &gt;&#x3D; 0，就让s +&#x3D; x。<br>因为是求最大值，所以res的初值置为 无穷小INT_MIN。同时，每一次迭代，都要更新res，也就是res &#x3D; max(res, s)。最后返回的res就是 最大值。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 此时s是以前一个数结尾的子数组中，和最大的是多少</span></span><br><span class="line">        <span class="type">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里s指的是，以当前数结尾的，子数组的和的最大值</span></span><br><span class="line">            s += x;</span><br><span class="line">            res = <span class="built_in">max</span>(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="1～n-整数中-1-出现的次数"><a href="#1～n-整数中-1-出现的次数" class="headerlink" title="1～n 整数中 1 出现的次数"></a>1～n 整数中 1 出现的次数</h1><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">1～n 整数中 1 出现的次数</a></p>
<p><strong>思路：</strong></p>
<p>按位枚举<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-47-27.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)<sup>2</sup></em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把每一位取出来，例如123，放进数组就是[3, 2, 1]</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最高位开始，枚举每一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// left指的是枚举的那一位前面的数，例如枚举的是abcdef中的c，那么left就是ab;，那么right就是def，如果def是三位，t就是10&lt;sup&gt;3</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = num.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                left = left * <span class="number">10</span> + num[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                right = right * <span class="number">10</span> + num[j];</span><br><span class="line">                t *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先将情况①加进去</span></span><br><span class="line">            ans += left * t;</span><br><span class="line">            <span class="comment">// 加入情况②的(2)</span></span><br><span class="line">            <span class="keyword">if</span> (num[i] == <span class="number">1</span>) ans += right + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 加入情况②的(3)</span></span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt; <span class="number">1</span>) ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 offer</category>
      </categories>
      <tags>
        <tag>剑指 offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeedCode 1 ~ 50</title>
    <url>/2022/03/27/LeedCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%951-50/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p>
<p><strong>思路：</strong><br>用哈希表储存已经遍历过的值，再通过<code>int r = target - nums[i];</code>查看哈希表中是否存在一个值，与<code>nums[i]</code>之和为<code>target</code></p>
<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, hash[r]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> r = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;i, hash[r]&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">9</span>;</span><br><span class="line">    ans = <span class="built_in">twoSum</span>(nums, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p>
<p><strong>思路：</strong><br>遍历一遍即可，注意进位<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 当前尾节点位置</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            t = l1-&gt;val + l2-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            t = l1-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            t = l2-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看看最后是否还有进位</span></span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t);</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表的节点规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 当前尾节点位置</span></span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        t = l1-&gt;val + l2-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">        t = l1-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">        t = l2-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看最后是否还有进位</span></span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t);</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 构造第一个链表，输入-1时停止</span></span><br><span class="line">    <span class="keyword">auto</span> dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur1 = dummy1;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur1-&gt;next = p;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造第二个链表，输入-1时停止</span></span><br><span class="line">    <span class="keyword">auto</span> dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur2 = dummy2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur2-&gt;next = p;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">addTwoNumbers</span>(dummy1-&gt;next, dummy2-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = p; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<p><strong>思路：</strong><br>双指针算法 + 哈希表<br>利用指针<code>i</code>前进，同时哈希表统计是否有重复的字符。如果有重复字符，那么指针<code>j</code>也前进，直到重复字符消失为止，比较统计最大长度。<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">lengthOfLongestSubstring</span>(s);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p>
<p><strong>思路：</strong><br>分别考虑奇数回文子串和偶数回文子串即可<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="comment">// 找出最长的奇数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最长的偶数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="comment">// 找出最长的奇数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最长的偶数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">longestPalindrome</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a>Z 字形变换</h1><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/">Z 字形变换</a></p>
<p><strong>思路：</strong><br>第一行和最后一行，每个数字之间间隔是<code>2n-2</code>：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-18-20-16483439651561.png" alt="在这里插入图片描述"><br>中间行分2个队伍，分别向后相差<code>2n-2</code>，两个队伍的队头之和为<code>2n-2</code>：<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-22-39.png" alt="在这里插入图片描述"><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一行的时候直接返回s即可</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一行和最后一行，每个数字之间间隔是2n - 2</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    ans += s[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中间行分2个队伍j和k，分别向后相差2n-2，两个队伍的队头j和k之和为2n-2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - j; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// j队伍在前</span></span><br><span class="line">                    ans += s[j];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// k队伍在后，总是一个j一个k，这样轮循下去</span></span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ans += s[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一行的时候直接返回s即可</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一行和最后一行，每个数字之间间隔是2n - 2</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                ans += s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 中间行分2个队伍j和k，分别向后相差2n-2，两个队伍的队头j和k之和为2n-2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - j; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// j队伍在前</span></span><br><span class="line">                ans += s[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// k队伍在后，总是一个j一个k，这样轮循下去</span></span><br><span class="line">                <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    ans += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt;  n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">convert</span>(s, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p>
<p><strong>思路：</strong><br>将<code>ans * 10 + res[i]</code> 转化为  <code>ans &lt;= double (INT_MAX - res[i] - 1) / 10</code>即可<br><strong>时间复杂度：<em>O($log<del>10</del>n$)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	        sign = <span class="number">-1</span>;</span><br><span class="line">	        x = -x;</span><br><span class="line">	    &#125;</span><br><span class="line">	    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">	        res.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">	        x /= <span class="number">10</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (ans &lt;= <span class="built_in">double</span> (INT_MAX - res[i] - <span class="number">1</span>) / <span class="number">10</span>) &#123;</span><br><span class="line">	            ans = ans * <span class="number">10</span> + res[i];</span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ans *= sign;</span><br><span class="line">	    <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= <span class="built_in">double</span> (INT_MAX - res[i]) / <span class="number">10</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + res[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">reverse</span>(x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></p>
<p><strong>思路：</strong><br>细心点即可，小心超出long long 的范围<br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 丢弃无用的前导空格</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查下一个字符（假设还未到字符末尾）为正还是负号</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;-&#x27;</span>) k++, sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加符号</span></span><br><span class="line">        ans *= sign;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX) ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; INT_MIN) ans = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 丢弃无用的前导空格</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查下一个字符（假设还未到字符末尾）为正还是负号</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;-&#x27;</span>) k++, sign = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加符号</span></span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; INT_MAX) ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; INT_MIN) ans = INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAtoi</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p>
<p><strong>思路：</strong><br>利用字符串转换函数<code>to_string(x)</code>和字符串翻转函数<code>string(str.rbegin(), str.rend());</code><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="comment">// 字符串翻转函数</span></span><br><span class="line">        string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">return</span> str == str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">    string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="keyword">return</span> str == str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isPalindrome</span>(x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p>
<p><strong>思路：</strong><br>假设左边先到达最优解，证明右边一定会向最优解靠拢<br>也就是说当左边到达最优解时，右边在最优解之前的值，一定都比左边的值要短，从而左边不动，右边向左靠拢，直到经过右边最优解为止<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-23-41.png" alt="在这里插入图片描述"><br><strong>结论，只要左边先到达最优解，那么右边到达最优解之前的值，一定小于左边的最优解</strong><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[l], height[r]) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[l], height[r]) * (r - l));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; height = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxArea</span>(height) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h1><p><a href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> valus[] = &#123;</span><br><span class="line">            <span class="number">1000</span>,</span><br><span class="line">            <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>,</span><br><span class="line">            <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        string reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">            <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= valus[i]) &#123;</span><br><span class="line">                num -= valus[i];</span><br><span class="line">                res += reps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h1><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>, hash[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        hash[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>, hash[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        hash[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>, hash[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        hash[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; hash[s[i]] &lt; hash[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= hash[s[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += hash[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p>
<p><strong>思路：</strong><br>把最短的字符串放在第一个，然后逐位和后面的字符串相应位置比较，如果遇到不同的直接跳出双重循环<br><strong>时间复杂度：<em>O(n<sup>n</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到长度最短的字符串</span></span><br><span class="line">        <span class="type">int</span> minv = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 长度最短的字符串的下标</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].<span class="built_in">size</span>() &lt; minv) &#123;</span><br><span class="line">                minv = strs[i].<span class="built_in">size</span>();</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx) <span class="built_in">swap</span>(strs[<span class="number">0</span>], strs[idx]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                    sign = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == strs.<span class="built_in">size</span>() - <span class="number">1</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到长度最短的字符串</span></span><br><span class="line">    <span class="type">int</span> minv = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 长度最短的字符串的下标</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].<span class="built_in">size</span>() &lt; minv) &#123;</span><br><span class="line">            minv = strs[i].<span class="built_in">size</span>();</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx) <span class="built_in">swap</span>(strs[<span class="number">0</span>], strs[idx]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == strs.<span class="built_in">size</span>() - <span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;<span class="string">&quot;cir&quot;</span>,<span class="string">&quot;car&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">longestCommonPrefix</span>(strs) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></p>
<p><strong>思路：</strong><br><strong>算法：排序+双指针</strong><br>先排序，然后固定i，然后j和k相互靠拢<br>双指针做法，首先想暴力做法怎么做，然后看是否有单调性，有单调性可以考虑双指针，双指针可以优化掉一个次方的时间复杂度，从n<sup>3</sup>优化到n<sup>2</sup><br>而且j越大，k一定越小，这一点就保证了j和k一次最多只扫描了n，当j越大，k已经没必要从最右边开始扫描了，只需要从之前的地方往左就行，因为nums[j]增加，nums[k]必须不变或者变小，才有意义<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-36-23.png" alt="在这里插入图片描述"><br>题目要求不能有重复，如果nums[i]和等于nums[i - 1]的话，那么nums[i]的所有j和k，其实在nums[i - 1]已经全部枚举完了，所以得去除nums[i]&#x3D;&#x3D;nums[i - 1]的j和k，也就是跳过，一直到nums[i]和前面不一样才行<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-25-10.png" alt="在这里插入图片描述"><br>因为是有序的，如果三元组的第一个数不一样，后面肯定不一样<br>然后当i相同时，nums[j]也不能等于nums[j - 1]</p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = <span class="built_in">threeSum</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></p>
<p><strong>思路一：</strong><br>暴力解法<br><strong>时间复杂度：<em>O(n<sup>3</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">	            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">	                sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">	                <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">	                    minSum = sum;</span><br><span class="line">	                    minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">	                    <span class="keyword">if</span> (minv == <span class="number">0</span>) <span class="keyword">return</span> minSum;</span><br><span class="line">	                &#125;</span><br><span class="line">	                k--;</span><br><span class="line">	            &#125;</span><br><span class="line">	            k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> minSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong><br>排序+双指针优化掉一重循环<br>首先将 nums 数组排序，然后固定一重循环枚举起始位置 i ，这样就优化成 2 个数 j, k 之和最接近 target 的问题了<br>然后初始 j &#x3D; i + 1, k &#x3D; nums.size() - 1；如果发现 sum &#x3D;&#x3D; target，则可以直接返回 target<br>若发现 sum &lt; target，则 j++；否则 k–，这样就会向 target 逼近<br>直到 j &gt;&#x3D; k 停止，继续向后增加初始位置 i<br><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">	            sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">	            <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">	                minSum = sum;</span><br><span class="line">	                minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> target;</span><br><span class="line">	            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) j++;</span><br><span class="line">	            <span class="keyword">else</span> k--;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> minSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">                minSum = sum;</span><br><span class="line">                minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">-100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">threeSumClosest</span>(nums, target) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></p>
<p><strong>思路：</strong><br>递归<br><strong>时间复杂度：<em>O(4<sup>n</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str[k].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + str[k][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, u, path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str[k].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + str[k][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="built_in">dfs</span>(digits, u, path);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    vector&lt;string&gt; ans = <span class="built_in">letterCombinations</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (string i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><p><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></p>
<p><strong>思路：</strong><br>排序+双指针优化一层复杂度<br>注意爆 int ，要用 long long 存储四数之和<br><strong>时间复杂度：<em>O(n<sup>3</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; u - <span class="number">1</span> &amp;&amp; (<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] - target &gt;= <span class="number">0</span>) u--;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u] == target) &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span> (k &lt; u - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] - target &gt;= <span class="number">0</span>) u--;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u] == target) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = <span class="built_in">fourSum</span>(nums, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p>
<p><strong>思路：</strong><br>遍历一遍统计节点个数，在遍历一遍删除对应节点<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计链表总共有多少个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = i - n;</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表的倒数第 N 个结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计链表总共有多少个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = i - n;</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试样例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k, k != <span class="number">-1</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(k);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="built_in">removeNthFromEnd</span>(dummy-&gt;next, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p>
<p><strong>思路：</strong><br>用栈，如果是左括号，就压栈，然后<code>continue</code><br>如果是右括号，则看栈顶是不是对应的左括号，如果不是，则压栈<br>如果是右括号，栈为空，则返回<code>false</code><br>如果遍历完毕，栈为空则返回<code>true</code>，否则返回<code>false</code><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isValid</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p>
<p><strong>思路：</strong><br>遍历一遍即可<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                list1 = cur-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                list2 = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1) cur-&gt;next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2) cur-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p>
<p><strong>思路：</strong><br>左括号小于<code>n</code>，就可以加；右括号数量小于左括号数量则可以加<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lc为左括号的数量，rc为右括号的数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, res + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; lc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, res + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lc为左括号的数量，rc为右括号的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, res + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; lc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, res + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;string&gt; ans = <span class="built_in">generateParenthesis</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : ans) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></p>
<p><strong>思路：</strong><br>用临时变量<code>temp</code>储存下一个值，方便调换<br>然后用<code>before</code>存储上一个值<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* h;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next) h = head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* before = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p &amp;&amp; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = p-&gt;next;</span><br><span class="line">            before-&gt;next = temp;</span><br><span class="line">            p-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            before = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* h;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next) h = head-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* before = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p &amp;&amp; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = p-&gt;next;</span><br><span class="line">        before-&gt;next = temp;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">        before = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k, k != <span class="number">-1</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(k);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="built_in">swapPairs</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></p>
<p><strong>思路：</strong><br>双指针<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p><a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p>
<p><strong>思路：</strong><br>双指针<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></p>
<p><strong>思路：</strong><br>kmp算法<br><strong>时间复杂度：<em>O(n + m)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 字符串先补成从1开始</span></span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 求next数组，为什么从 i = 2 开始呢，因为 next[1] = 0</span></span><br><span class="line">        <span class="comment">// next 指的是非平凡的前缀和后缀相等的最大值，不包括本身，所以 next[1] = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 字符串先补成从1开始</span></span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 求next数组，为什么从 i = 2 开始呢，因为 next[1] = 0</span></span><br><span class="line">    <span class="comment">// next 指的是非平凡的前缀和后缀相等的最大值，不包括本身，所以 next[1] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s, p;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strStr</span>(s, p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p><a href="https://leetcode-cn.com/problems/divide-two-integers/">两数相除</a></p>
<p><strong>思路：</strong><br>快速幂+位运算<br><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        vector&lt;LL&gt; exp;</span><br><span class="line">        <span class="type">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) is_minus = <span class="literal">true</span>;</span><br><span class="line">        LL a = <span class="built_in">abs</span>((LL)x), b = <span class="built_in">abs</span>((LL)y);</span><br><span class="line">        <span class="keyword">for</span> (LL i = b; i &lt;= a; i = i + i) exp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = exp.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= exp[i]) &#123;</span><br><span class="line">                a -= exp[i];</span><br><span class="line">                res += <span class="number">1LL</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_minus) res = -res;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) res = INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></p>
<p><strong>思路：</strong></p>
<p>首先逆序扫描一遍数组，找到降序的点（即：图中红色的点）<br>如图：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-30_23-11-48.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k --;</span><br></pre></td></tr></table></figure>

<p>循环结束<code>k</code>的值表示红色的点<code>a</code>的下标。</p>
<p>然后重新逆序遍历，找到最小的比<code>k - 1</code>大的点。由于在图中点<code>a</code>后面的点本身就是排好序了的，所以我们逆序遍历，第一个比<code>k - 1</code>大的点就是最小的比<code>k - 1</code>大的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br></pre></td></tr></table></figure>

<p>然后交换这两个点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>最后将后面（蓝色圈出来部分）下降的折线 捋成上升的形状。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">nextPermutation</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p>
<p><strong>思路：</strong></p>
<p>二分找出分界点</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-30_23-57-39.png" alt="1"></p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                r = l - <span class="number">1</span>, l = <span class="number">0</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == nums[l]) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><strong>思路：</strong></p>
<p>两次二分即可</p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">push_back</span>(r);</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></p>
<p><strong>思路：</strong></p>
<p>二分</p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; target &gt; nums[l]) l++;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    	mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    		l = mid + <span class="number">1</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		r = mid;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; target &gt; nums[l]) l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">searchInsert</span>(nums, target) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">有效的数独</a></p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>&gt;)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[9]为行，col[9]为列</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">9</span>], col[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">            <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++res[board[i][j] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++col[board[j][i] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res[9]为九宫格</span></span><br><span class="line">        <span class="type">int</span> rc[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i += <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(rc, <span class="number">0</span>, <span class="keyword">sizeof</span> rc);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[x + i][y + j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++rc[board[x + i][y + j] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><p><a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></p>
<p><strong>思路：</strong></p>
<p>简单模拟一下即可，双指针</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, j = k; j &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == s[k]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="built_in">to_string</span>(j - k) + s[k];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></p>
<p><strong>思路：</strong></p>
<p>暴力枚举每个数选几个</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, u + <span class="number">1</span>, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, u + <span class="number">1</span>, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = s.<span class="built_in">combinationSum</span>(c, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></p>
<p><strong>思路：</strong></p>
<p>先求每个数最多能出现的次数，然后枚举每个数选几个，并且加上个数限制即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; c.<span class="built_in">size</span>() &amp;&amp; c[k] == c[u]) k++;</span><br><span class="line">        <span class="type">int</span> cnt = k - u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, k, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; c.<span class="built_in">size</span>() &amp;&amp; c[k] == c[u]) k++;</span><br><span class="line">        <span class="type">int</span> cnt = k - u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, k, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = s.<span class="built_in">combinationSum</span>(c, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></p>
<p><strong>思路一：</strong></p>
<p>假设不考虑时间复杂度，排序，去重以后，暴力对比即可</p>
<p><strong>时间复杂度：<em>O(nlogn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; INT_MAX; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>哈希表，把所有数放到哈希表里面，然后再枚举所有正整数</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (hash.<span class="built_in">count</span>(res)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路三：</strong></p>
<p>原地哈希算法：</p>
<p>原地哈希算法主要应用在范围为 [0, len(nums)] 的数组解法中，将数组元素本身作为<code>nums</code> 的下标，即 <code>nums[nums[i]]</code></p>
<p>原地哈希映射：保证1出现在nums[0]的位置上，2出现在nums[1]的位置上，…，n出现在nums[n-1]的位置上，其他的数字不管。例如[3,4,-1,1]将被排序为[1,-1,3,4]</p>
<p>遍历nums，找到第一个不在应在位置上的1到n的数。例如，排序后的[1,-1,3,4]中第一个 nums[i] !&#x3D; i + 1 的是数字2（注意此时i&#x3D;1）。</p>
<p>时间复杂度分析：代码中第二层while循环，每循环一次，会将一个数放在正确的位置上，所以总共最多执行 n 次，所以总时间复杂度 O(n)。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h1><p><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></p>
<p><strong>思路：</strong></p>
<p>将A[i] * B[j] 加到 C[i + j] 里面，最后再一起进位</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20220412220151895.png" alt="image-20220412220151895"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除前导0</span></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">        <span class="comment">// 数字转字符串</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string num1, num2;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<p><strong>思路：</strong></p>
<p>动态规划+贪心</p>
<ol>
<li><p>设状态 f(i) 表示到达 i 所需要的最少步数。</p>
</li>
<li><p>f(0)&#x3D;0，其余待定。定义辅助指针 last 为第一次到达 i 时上一步的位置，last 从 0 开始。</p>
</li>
<li><p>我们会发现f[i]是具有单调性的，也就是f[i + 1] &gt;&#x3D; f[i]。</p>
<p>用反证法：假设f[i + 1] &lt; f[i]，不妨设是从k,(k &lt;&#x3D; i)点跳到i + 1，即：k + nums[k] &gt;&#x3D; i + 1，那么k + nums[k]也必然大于i，此时：f[i + 1] &#x3D; f[i]了。如果nums数组每一项都为1，则：f[i + 1] &gt; f[i]，综上：f[i + 1] &gt;&#x3D; f[i]，与假设矛盾。</p>
</li>
<li><p>根据以上得知，令 f(i)&#x3D;f(last)+1 后，f(i) 就会是最优值。</p>
<p>在动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了，这里无论是取哪一个点跳到i，其最终的结果是一样的，但是取第一个点和取最后一个点所需要的步数可能不相同，所以尽量选择靠前的点，这样步数就可能会减少，贪心的思想。</p>
</li>
<li><p>故可以根据 i 来让last 向后移动，找到最早的可以一步到达 i 的位置，然后根据 f(last) 更新 f(i)。</p>
</li>
</ol>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, last = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据i来更新last。如果last + nums[last]够不到i，那就往后移last</span></span><br><span class="line">            <span class="keyword">while</span> (last + nums[last] &lt; i) last++;</span><br><span class="line">            <span class="comment">// 根据f[last]更新f[i]，last可以一步走到i</span></span><br><span class="line">            f[i] = f[last] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeedCode</category>
      </categories>
      <tags>
        <tag>LeedCode</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2022/04/12/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h1 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<p><strong>思路：</strong></p>
<p>动态规划+贪心</p>
<ol>
<li><p>设状态 f(i) 表示到达 i 所需要的最少步数。</p>
</li>
<li><p>f(0)&#x3D;0，其余待定。定义辅助指针 last 为第一次到达 i 时上一步的位置，last 从 0 开始。</p>
</li>
<li><p>我们会发现f[i]是具有单调性的，也就是f[i + 1] &gt;&#x3D; f[i]。</p>
<p>用反证法：假设f[i + 1] &lt; f[i]，不妨设是从k,(k &lt;&#x3D; i)点跳到i + 1，即：k + nums[k] &gt;&#x3D; i + 1，那么k + nums[k]也必然大于i，此时：f[i + 1] &#x3D; f[i]了。如果nums数组每一项都为1，则：f[i + 1] &gt; f[i]，综上：f[i + 1] &gt;&#x3D; f[i]，与假设矛盾。</p>
</li>
<li><p>根据以上得知，令 f(i)&#x3D;f(last)+1 后，f(i) 就会是最优值。</p>
<p>在动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了，这里无论是取哪一个点跳到i，其最终的结果是一样的，但是取第一个点和取最后一个点所需要的步数可能不相同，所以尽量选择靠前的点，这样步数就可能会减少，贪心的思想。</p>
</li>
<li><p>故可以根据 i 来让last 向后移动，找到最早的可以一步到达 i 的位置，然后根据 f(last) 更新 f(i)。</p>
</li>
</ol>
<span id="more"></span>

<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, last = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据i来更新last。如果last + nums[last]够不到i，那就往后移last</span></span><br><span class="line">            <span class="keyword">while</span> (last + nums[last] &lt; i) last++;</span><br><span class="line">            <span class="comment">// 根据f[last]更新f[i]，last可以一步走到i</span></span><br><span class="line">            f[i] = f[last] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/04/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<p><strong>思路：</strong></p>
<p>动态规划+贪心</p>
<ol>
<li><p>设状态 f(i) 表示到达 i 所需要的最少步数。</p>
</li>
<li><p>f(0)&#x3D;0，其余待定。定义辅助指针 last 为第一次到达 i 时上一步的位置，last 从 0 开始。</p>
</li>
<li><p>我们会发现f[i]是具有单调性的，也就是f[i + 1] &gt;&#x3D; f[i]。</p>
<p>用反证法：假设f[i + 1] &lt; f[i]，不妨设是从k,(k &lt;&#x3D; i)点跳到i + 1，即：k + nums[k] &gt;&#x3D; i + 1，那么k + nums[k]也必然大于i，此时：f[i + 1] &#x3D; f[i]了。如果nums数组每一项都为1，则：f[i + 1] &gt; f[i]，综上：f[i + 1] &gt;&#x3D; f[i]，与假设矛盾。</p>
</li>
<li><p>根据以上得知，令 f(i)&#x3D;f(last)+1 后，f(i) 就会是最优值。</p>
<p>在动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了，这里无论是取哪一个点跳到i，其最终的结果是一样的，但是取第一个点和取最后一个点所需要的步数可能不相同，所以尽量选择靠前的点，这样步数就可能会减少，贪心的思想。</p>
</li>
<li><p>故可以根据 i 来让last 向后移动，找到最早的可以一步到达 i 的位置，然后根据 f(last) 更新 f(i)。</p>
</li>
</ol>
<span id="more"></span>

<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, last = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据i来更新last。如果last + nums[last]够不到i，那就往后移last</span></span><br><span class="line">            <span class="keyword">while</span> (last + nums[last] &lt; i) last++;</span><br><span class="line">            <span class="comment">// 根据f[last]更新f[i]，last可以一步走到i</span></span><br><span class="line">            f[i] = f[last] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯常用技巧</title>
    <url>/2022/04/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜bits/stdc++.h＞</span></span><br></pre></td></tr></table></figure>

<h2 id="加快输入输出"><a href="#加快输入输出" class="headerlink" title="加快输入输出"></a>加快输入输出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main函数中加入以下代码，降低时长</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="常用变量定义"><a href="#常用变量定义" class="headerlink" title="常用变量定义"></a>常用变量定义</h2><p>建议一些变量、数组、标记等定义在全局，这样就避免了初始化，因为放在全局的变量，系统自动初始化成0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">// 1061109567</span></span><br><span class="line"><span class="type">const</span> LL  INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;<span class="comment">// 4557430888798830399</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);<span class="comment">// 3.14159</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);<span class="comment">// 2.71828</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e5</span>+<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0x3f3f3f3f是一个很有用的数值，它是满足以下两个条件的最大整数。</p>
<p>1、整数的两倍不超过 0x7f7f7f7f，即int能表示的最大正整数。</p>
<p>2、整数的每8位（每个字节）都是相同的。(0011 1111 0011 1111 0011 1111 0011 1111)</p>
<p>我们在程序设计中经常需要使用 memset(a, val, sizeof a) 初始化一个数组a，该语句把数值 val（0x00~0xFF）填充到数组a 的每个字节上，所以用memset只能赋值出“每8位都相同”的 int。</p>
<p>当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 memset(a, 0x3f, sizeof(a)) 给数组赋 0x3f3f3f3f的值来代替。</p>
</blockquote>
<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//a[10]的长度其实是40byte，因为每个int是4个byte</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>],  b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">40</span>);<span class="comment">//cstring中的memset(要初始化的数组，初始化的值，要初始化的字节长度(byte))</span></span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);<span class="comment">//sizeof可以用来求数组占用的字节数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[]=<span class="string">&quot;This is a test of the memset function&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before:%s\n&quot;</span>,data);</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="string">&#x27;*&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After:%s\n&quot;</span>,data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    Before:This is a test of the memset function</span><br><span class="line">	After:**** is a test of the memset function</span><br></pre></td></tr></table></figure>

<h2 id="atoi-x2F-stoi-字符串转换为整数"><a href="#atoi-x2F-stoi-字符串转换为整数" class="headerlink" title="atoi&#x2F;stoi 字符串转换为整数"></a>atoi&#x2F;stoi 字符串转换为整数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">atoi</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitset-字符串或者整数转二进制"><a href="#bitset-字符串或者整数转二进制" class="headerlink" title="bitset 字符串或者整数转二进制"></a>bitset 字符串或者整数转二进制</h2><p>用于将字符串或者整数转换成二进制数存储</p>
<p>bitset存储中下标是从右往左 从0开始计数的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储位数足够，前面多余位用0补足</span></span><br><span class="line">    bitset &lt;8&gt;<span class="built_in">a</span>(<span class="number">13</span>);<span class="comment">// 1101</span></span><br><span class="line">    bitset &lt;8&gt;<span class="built_in">b</span>(<span class="built_in">string</span>(<span class="string">&quot;100101&quot;</span>));<span class="comment">// 100101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储位数不够时，数字转换取后几位，字符串转换取前几位</span></span><br><span class="line">    bitset &lt;3&gt;<span class="built_in">c</span>(<span class="number">12</span>);<span class="comment">// 1100</span></span><br><span class="line">    bitset &lt;4&gt;<span class="built_in">d</span>(<span class="built_in">string</span>(<span class="string">&quot;100111&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注 ：bitset的下标是从右往左数的</span></span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">1011</span></span><br><span class="line">    <span class="number">00001101</span></span><br><span class="line">    <span class="number">00100101</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*执行 flip 、set 和 reset函数 后都会覆盖原有值</span></span><br><span class="line">    string str = <span class="string">&quot;10010111&quot;</span>;</span><br><span class="line">    bitset &lt;8&gt; <span class="built_in">m</span>(str);</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">count</span>() &lt;&lt; endl;<span class="comment">// 返回m中1的个数</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 返回m的大小</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">test</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">// 检测下标为2的元素是否为1 若为1 则返回1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">any</span>() &lt;&lt; endl;<span class="comment">// 检测m中是否有1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">none</span>() &lt;&lt; endl;<span class="comment">// 检测m中是否没有1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">all</span>() &lt;&lt; endl;<span class="comment">// 检测m中是否全部为1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">flip</span>() &lt;&lt; endl;<span class="comment">// 所有位都取反</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">flip</span>(<span class="number">0</span>) &lt;&lt; endl;<span class="comment">// 下标为0的位置取反</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">set</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">// 将下标为2的元素置为1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">set</span>() &lt;&lt; endl;<span class="comment">// 所有位都置为1</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">set</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">// 将下标为1的元素置为 0</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">reset</span>() &lt;&lt; endl;<span class="comment">// 将所有位置为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">10010111</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    <span class="number">8</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">01101000</span></span><br><span class="line">    <span class="number">01101001</span></span><br><span class="line">    <span class="number">01101101</span></span><br><span class="line">    <span class="number">11111111</span></span><br><span class="line">    <span class="number">11111101</span></span><br><span class="line">    <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;10010111&quot;</span>;</span><br><span class="line">    bitset &lt;8&gt; <span class="built_in">n</span>(str);</span><br><span class="line">    string s = n.<span class="built_in">to_string</span>();</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将bitset转换为无符号的long</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h = n.<span class="built_in">to_ulong</span>();</span><br><span class="line">    cout &lt;&lt; h &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">10010111</span></span><br><span class="line">    <span class="number">151</span></span><br><span class="line">    <span class="number">151</span></span><br></pre></td></tr></table></figure>

<h2 id="next-permutation-全排列"><a href="#next-permutation-全排列" class="headerlink" title="next_permutation 全排列"></a>next_permutation 全排列</h2><p>prev_permutation前一个排列组合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>输出 n 个数的全排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">关于<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    </span><br><span class="line">其功能是循环从输入流读取n，直到遇到EOF为止，<span class="built_in">scanf</span>()函数返回成功赋值的数据项数，出错时则返回，EOF定义为<span class="number">-1</span>。~是按位取反，<span class="number">-1</span>十六进制补码表示为<span class="number">0xffffffff</span>，f是二进制的<span class="number">1111</span>，取反后就全部变成<span class="number">0</span>了，于是<span class="keyword">while</span>结束。只有返回值为EOF（即<span class="number">-1</span>）时，其取反的的值（即<span class="keyword">while</span>循环的判断条件）才为<span class="number">0</span>，才能结束循环，其它输入情况下（无论是否输入成功）<span class="keyword">while</span>循环的判断条件为非<span class="number">0</span>，即为真。</span><br></pre></td></tr></table></figure>

<h2 id="reverse-翻转函数"><a href="#reverse-翻转函数" class="headerlink" title="reverse 翻转函数"></a>reverse 翻转函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//算法库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">reverse</span>(b, b + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : b) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort 排序函数"></a>sort 排序函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//算法库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入一个随机准则，time(0)是现在到1970-1-1的秒数</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//随机打乱顺序</span></span><br><span class="line">    <span class="built_in">random_shuffle</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reverse-翻转函数-1"><a href="#reverse-翻转函数-1" class="headerlink" title="reverse 翻转函数"></a>reverse 翻转函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(<span class="number">12321</span>);</span><br><span class="line">    <span class="comment">// 翻转以后返回字符串</span></span><br><span class="line">    string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">    cout &lt;&lt; (str == str2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="unique-去重函数"><a href="#unique-去重函数" class="headerlink" title="unique 去重函数"></a>unique 去重函数</h2><p>这是一个<strong>去重</strong>函数 （同时将数组从小到大排序 重复出现的元素放到容器尾部）</p>
<p>unique(num,mun+n)返回的是num去重后的尾地址，之所以说比不真正把重复的元素删除，其实是，该函数把重复的元素移到后面去了，然后依然保存到了原数组中，然后返回去重后最后一个元素的地址，<strong>因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">需要添加头文件：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;abbbccbba&quot;</span>;</span><br><span class="line">    str.<span class="built_in">erase</span>((<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>())), str.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：abcba</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    res.<span class="built_in">erase</span>((<span class="built_in">unique</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>())), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : res) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><p>利用二分查找在已排序的数组中查找元素</p>
<p>lower_bound(begin,end,num) 找到第一个大于或等于num的数字 返回该数字的地址 否则返回end</p>
<p>通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。即 lower_bound(begin,end,num) - begin</p>
<p>upper_bound(begin,end,num) 找到第一个大于num的数字 返回该数字的地址 否则返回end</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">添加头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 通过返回的地址减去起始地址begin,得到找到数字在数组中的下标</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">lower_bound</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), <span class="number">3</span>) - res.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, a);<span class="comment">// 在左边补上空格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-5d\n&quot;</span>, a);<span class="comment">// 在右边补上空格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5.1lf\n&quot;</span>, b);<span class="comment">// 小数长度为5，并且保留一位小数，不够时前面补空格（小数点也算一位）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05.1lf\n&quot;</span>, b);<span class="comment">// 小数长度为5，并且保留一位小数，不够时前面补0（小数点也算一位）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">   <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">  <span class="number">5.0</span></span><br><span class="line"><span class="number">005.0</span></span><br></pre></td></tr></table></figure>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>关于数据范围：大题的题目中会给出相应的数据范围，根据题目的数据范围来选择数据型是int 还是long long 还是其他类型，注意如果是使用long long的话，要用%i64d（i大写）进行输入输出，如果是平常做题过程中使用%lld进行输入输出。（用%i64d（i大写）还是%lld根据情况而定，如果Windows评测机采用%i64d（i大写）；如果Linux评测机采用%lld）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">蓝桥杯输入/出 <span class="type">long</span> <span class="type">long</span>数据需要使用的是</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%I64d&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>蓝色桥杯最大栈空间为256MB，经过换算， 你最大可以<strong>开 1 * 10的7次方左右的数组空间</strong>。也就是<strong>1千万</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="number">0</span>～<span class="number">4294967295</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">int</span> <span class="number">-2147483648</span>～<span class="number">2147483647</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="number">0</span>～<span class="number">4294967295</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">long</span> <span class="number">-2147483648</span>～<span class="number">2147483647</span> <span class="comment">// 9及以下位数都可装</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>的最大值：<span class="number">9223372036854775807</span> <span class="comment">// 18及以下位数都可装 19位也差不多</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>的最小值：<span class="number">-9223372036854775808</span> <span class="comment">// 18及以下位数都可装 19位也差不多</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>的最大值：<span class="number">18446744073709551615</span> <span class="comment">//20位</span></span><br><span class="line"><span class="comment">// 下面用的可能没有接触过， 但存在， 有上面的就够了， 下面和上面的long long 是一样的。</span></span><br><span class="line">__int64的最大值：<span class="number">9223372036854775807</span>__</span><br><span class="line"></span><br><span class="line">int64的最小值：<span class="number">-9223372036854775808</span></span><br><span class="line"><span class="type">unsigned</span> __int64的最大值：<span class="number">18446744073709551615</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> </span><br><span class="line"><span class="comment">// 当需要多次使用一个表达式的值的时候， 可以存起来。 这样可以减少计算次数。</span></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n * b * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改为</span></span><br><span class="line"><span class="type">int</span> n  = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> t = n * b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="comment">// 计算一个数组 / 或者字符串长度的时候， 最后一直存着，以免多次计算。 </span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> </span><br><span class="line"><span class="comment">// 位运算符的应用</span></span><br><span class="line"><span class="comment">// 如:</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> i =  n* <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =  n / <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 可以更改为</span></span><br><span class="line"><span class="type">int</span> i = n &lt;&lt; <span class="number">1</span>; <span class="comment">// 相信我会快。</span></span><br><span class="line"><span class="type">int</span> c =  n &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">// 对于for循环同样使用。</span></span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">while</span>(i &amp; <span class="number">1</span>)&#123; <span class="comment">// 用位运算代替</span></span><br><span class="line">--i;<span class="comment">// 前自减/增 比 后自减/增快。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = i--;</span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="type">int</span> x = i;</span><br><span class="line">--i;<span class="comment">// 这样结果一样， 但编译后，会少一条汇编指令。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法</title>
    <url>/2022/03/31/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>二分模板一共有两个，分别适用于不同情况。</p>
<p>算法思路：假设目标值在闭区间<code>[l, r]</code>中， 每次将区间长度缩小一半，当<code>l = r</code>时，我们就找到了目标值。</p>
<p><strong>版本1</strong><br>当我们将区间<code>[l, r]</code>划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时，其更新操作是<code>r = mid</code>或者<code>l = mid + 1</code>;，计算<code>mid</code>时不需要加1。</p>
<p><strong>C++ 代码模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>版本2</strong><br>当我们将区间<code>[l, r]</code>划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时，其更新操作是<code>r = mid - 1</code>或者<code>l = mid</code>;，此时为了防止死循环，计算<code>mid</code>时需要加1。</p>
<p><strong>C++ 代码模板：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p>
<p><strong>思路：</strong></p>
<p>二分找出分界点</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-30_23-57-39.png" alt="1"></p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                r = l - <span class="number">1</span>, l = <span class="number">0</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == nums[l]) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><strong>思路：</strong></p>
<p>两次二分即可</p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">push_back</span>(r);</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></p>
<p><strong>思路：</strong></p>
<p>二分</p>
<p><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; target &gt; nums[l]) l++;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    	mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    		l = mid + <span class="number">1</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		r = mid;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; target &gt; nums[l]) l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">searchInsert</span>(nums, target) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2022/03/30/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h1><p><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></p>
<p><strong>思路：</strong></p>
<p>将A[i] * B[j] 加到 C[i + j] 里面，最后再一起进位</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com//image-20220412220151895.png" alt="image-20220412220151895"></p>
<span id="more"></span>

<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除前导0</span></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">        <span class="comment">// 数字转字符串</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string num1, num2;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序-nlog2n"><a href="#快速排序-nlog2n" class="headerlink" title="快速排序(nlog2n)"></a>快速排序(nlog<sub>2</sub>n)</h2><p><strong>快排思想：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20211211182445802.png" alt="image-20211211182445802"></p>
<span id="more"></span>

<p><strong>暴力做法：</strong></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20211211182640852.png" alt="image-20211211182640852"></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20211212234117053.png" alt="image-20211212234117053"></p>
<p><strong>优美做法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span> <span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这里是j, j + 1那么上面一定不能取到x = q[r];否则会有边界问题可以是x = q[(l + r) / 2];</span></span><br><span class="line">    <span class="comment">//也可以是x = q[l];但是这个没有x = q[(l + r) / 2];快</span></span><br><span class="line">    <span class="comment">//如果这里是i - 1, i那么上面一定不能取到x = q[l];可以是x = q[(l + r + 1) / 2];</span></span><br><span class="line">    <span class="comment">//也可以是x = q[r];但是这个没有x = q[(l + r + 1) / 2];快</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序-nlogn"><a href="#归并排序-nlogn" class="headerlink" title="归并排序(nlogn)"></a>归并排序(nlogn)</h2><p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20211211205754380.png" alt="image-20211211205754380"></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20211211210530147.png" alt="image-20211211210530147"></p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/image-20211212234145331.png" alt="image-20211212234145331"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp算法</title>
    <url>/2022/03/30/kmp%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></p>
<p><strong>思路：</strong><br>kmp算法<br><strong>时间复杂度：<em>O(n + m)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 字符串先补成从1开始</span></span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 求next数组，为什么从 i = 2 开始呢，因为 next[1] = 0</span></span><br><span class="line">        <span class="comment">// next 指的是非平凡的前缀和后缀相等的最大值，不包括本身，所以 next[1] = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 字符串先补成从1开始</span></span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 求next数组，为什么从 i = 2 开始呢，因为 next[1] = 0</span></span><br><span class="line">    <span class="comment">// next 指的是非平凡的前缀和后缀相等的最大值，不包括本身，所以 next[1] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s, p;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strStr</span>(s, p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表</title>
    <url>/2022/03/30/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="单向链表的构造"><a href="#单向链表的构造" class="headerlink" title="单向链表的构造"></a>单向链表的构造</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体，定义链表的节点规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表节点的值n</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 构造虚拟头节点dummy</span></span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 当前尾节点位置</span></span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动输入要构造的节点的值n，并且当输入-1时代表终止</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// p为新构造的节点</span></span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        <span class="comment">// 上一个节点的next即为p</span></span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        <span class="comment">// 将cur后移</span></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p>
<p><strong>思路：</strong><br>遍历一遍即可，注意进位<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 当前尾节点位置</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            t = l1-&gt;val + l2-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            t = l1-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            t = l2-&gt;val + t;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 节点向后移</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看看最后是否还有进位</span></span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t);</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表的节点规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 当前尾节点位置</span></span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        t = l1-&gt;val + l2-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">        t = l1-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">        t = l2-&gt;val + t;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 节点向后移</span></span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看最后是否还有进位</span></span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t);</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 构造第一个链表，输入-1时停止</span></span><br><span class="line">    <span class="keyword">auto</span> dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur1 = dummy1;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur1-&gt;next = p;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造第二个链表，输入-1时停止</span></span><br><span class="line">    <span class="keyword">auto</span> dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur2 = dummy2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(n);</span><br><span class="line">        cur2-&gt;next = p;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">addTwoNumbers</span>(dummy1-&gt;next, dummy2-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = p; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p>
<p><strong>思路：</strong><br>遍历一遍统计节点个数，在遍历一遍删除对应节点<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计链表总共有多少个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = i - n;</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表的倒数第 N 个结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计链表总共有多少个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy-&gt;next; p; p = p-&gt;next) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = i - n;</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试样例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k, k != <span class="number">-1</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(k);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="built_in">removeNthFromEnd</span>(dummy-&gt;next, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p>
<p><strong>思路：</strong><br>遍历一遍即可<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                list1 = cur-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                list2 = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1) cur-&gt;next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2) cur-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></p>
<p><strong>思路：</strong><br>用临时变量<code>temp</code>储存下一个值，方便调换<br>然后用<code>before</code>存储上一个值<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* h;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next) h = head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* before = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p &amp;&amp; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = p-&gt;next;</span><br><span class="line">            before-&gt;next = temp;</span><br><span class="line">            p-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            before = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* h;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next) h = head-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* before = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p &amp;&amp; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = p-&gt;next;</span><br><span class="line">        before-&gt;next = temp;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">        before = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k, k != <span class="number">-1</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(k);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="built_in">swapPairs</span>(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = head; i; i = i-&gt;next) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2022/03/30/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<p><strong>思路：</strong><br>双指针算法 + 哈希表<br>利用指针<code>i</code>前进，同时哈希表统计是否有重复的字符。如果有重复字符，那么指针<code>j</code>也前进，直到重复字符消失为止，比较统计最大长度。<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">lengthOfLongestSubstring</span>(s);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p>
<p><strong>思路：</strong><br>分别考虑奇数回文子串和偶数回文子串即可<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="comment">// 找出最长的奇数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最长的偶数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="comment">// 找出最长的奇数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最长的偶数回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            l--, r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            res = r - l - <span class="number">1</span>;</span><br><span class="line">            ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">longestPalindrome</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></p>
<p><strong>思路：</strong><br><strong>算法：排序+双指针</strong><br>先排序，然后固定i，然后j和k相互靠拢<br>双指针做法，首先想暴力做法怎么做，然后看是否有单调性，有单调性可以考虑双指针，双指针可以优化掉一个次方的时间复杂度，从n<sup>3</sup>优化到n<sup>2</sup><br>而且j越大，k一定越小，这一点就保证了j和k一次最多只扫描了n，当j越大，k已经没必要从最右边开始扫描了，只需要从之前的地方往左就行，因为nums[j]增加，nums[k]必须不变或者变小，才有意义<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-36-23.png" alt="在这里插入图片描述"><br>题目要求不能有重复，如果nums[i]和等于nums[i - 1]的话，那么nums[i]的所有j和k，其实在nums[i - 1]已经全部枚举完了，所以得去除nums[i]&#x3D;&#x3D;nums[i - 1]的j和k，也就是跳过，一直到nums[i]和前面不一样才行<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-25-10.png" alt="在这里插入图片描述"><br>因为是有序的，如果三元组的第一个数不一样，后面肯定不一样<br>然后当i相同时，nums[j]也不能等于nums[j - 1]</p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k--;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = <span class="built_in">threeSum</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></p>
<p><strong>思路一：</strong><br>暴力解法<br><strong>时间复杂度：<em>O(n<sup>3</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">	            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">	                sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">	                <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">	                    minSum = sum;</span><br><span class="line">	                    minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">	                    <span class="keyword">if</span> (minv == <span class="number">0</span>) <span class="keyword">return</span> minSum;</span><br><span class="line">	                &#125;</span><br><span class="line">	                k--;</span><br><span class="line">	            &#125;</span><br><span class="line">	            k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> minSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong><br>排序+双指针优化掉一重循环<br>首先将 nums 数组排序，然后固定一重循环枚举起始位置 i ，这样就优化成 2 个数 j, k 之和最接近 target 的问题了<br>然后初始 j &#x3D; i + 1, k &#x3D; nums.size() - 1；如果发现 sum &#x3D;&#x3D; target，则可以直接返回 target<br>若发现 sum &lt; target，则 j++；否则 k–，这样就会向 target 逼近<br>直到 j &gt;&#x3D; k 停止，继续向后增加初始位置 i<br><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">	            sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">	            <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">	                minSum = sum;</span><br><span class="line">	                minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> target;</span><br><span class="line">	            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) j++;</span><br><span class="line">	            <span class="keyword">else</span> k--;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> minSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (minv &gt; <span class="built_in">abs</span>(sum - target)) &#123;</span><br><span class="line">                minSum = sum;</span><br><span class="line">                minv = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">-100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">threeSumClosest</span>(nums, target) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><p><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></p>
<p><strong>思路：</strong><br>排序+双指针优化一层复杂度<br>注意爆 int ，要用 long long 存储四数之和<br><strong>时间复杂度：<em>O(n<sup>3</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; u - <span class="number">1</span> &amp;&amp; (<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] - target &gt;= <span class="number">0</span>) u--;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u] == target) &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span> (k &lt; u - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k] + nums[u - <span class="number">1</span>] - target &gt;= <span class="number">0</span>) u--;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) nums[i] + nums[j] + nums[k] + nums[u] == target) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = <span class="built_in">fourSum</span>(nums, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></p>
<p><strong>思路：</strong><br>双指针<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p><a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p>
<p><strong>思路：</strong><br>双指针<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><p><a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></p>
<p><strong>思路：</strong></p>
<p>简单模拟一下即可，双指针</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, j = k; j &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == s[k]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="built_in">to_string</span>(j - k) + s[k];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2022/03/30/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p>
<p><strong>思路：</strong><br>用哈希表储存已经遍历过的值，再通过<code>int r = target - nums[i];</code>查看哈希表中是否存在一个值，与<code>nums[i]</code>之和为<code>target</code></p>
<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, hash[r]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> r = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;i, hash[r]&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">9</span>;</span><br><span class="line">    ans = <span class="built_in">twoSum</span>(nums, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<p><strong>思路：</strong><br>双指针算法 + 哈希表<br>利用指针<code>i</code>前进，同时哈希表统计是否有重复的字符。如果有重复字符，那么指针<code>j</code>也前进，直到重复字符消失为止，比较统计最大长度。<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hash[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">lengthOfLongestSubstring</span>(s);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></p>
<p><strong>思路一：</strong></p>
<p>假设不考虑时间复杂度，排序，去重以后，暴力对比即可</p>
<p><strong>时间复杂度：<em>O(nlogn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; INT_MAX; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>哈希表，把所有数放到哈希表里面，然后再枚举所有正整数</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (hash.<span class="built_in">count</span>(res)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路三：</strong></p>
<p>原地哈希算法：</p>
<p>原地哈希算法主要应用在范围为 [0, len(nums)] 的数组解法中，将数组元素本身作为<code>nums</code> 的下标，即 <code>nums[nums[i]]</code></p>
<p>原地哈希映射：保证1出现在nums[0]的位置上，2出现在nums[1]的位置上，…，n出现在nums[n-1]的位置上，其他的数字不管。例如[3,4,-1,1]将被排序为[1,-1,3,4]</p>
<p>遍历nums，找到第一个不在应在位置上的1到n的数。例如，排序后的[1,-1,3,4]中第一个 nums[i] !&#x3D; i + 1 的是数字2（注意此时i&#x3D;1）。</p>
<p>时间复杂度分析：代码中第二层while循环，每循环一次，会将一个数放在正确的位置上，所以总共最多执行 n 次，所以总时间复杂度 O(n)。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂算法</title>
    <url>/2022/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p><a href="https://leetcode-cn.com/problems/divide-two-integers/">两数相除</a></p>
<p><strong>思路：</strong><br>快速幂+位运算<br><strong>时间复杂度：<em>O(log<sub>2</sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        vector&lt;LL&gt; exp;</span><br><span class="line">        <span class="type">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) is_minus = <span class="literal">true</span>;</span><br><span class="line">        LL a = <span class="built_in">abs</span>((LL)x), b = <span class="built_in">abs</span>((LL)y);</span><br><span class="line">        <span class="keyword">for</span> (LL i = b; i &lt;= a; i = i + i) exp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = exp.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= exp[i]) &#123;</span><br><span class="line">                a -= exp[i];</span><br><span class="line">                res += <span class="number">1LL</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_minus) res = -res;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) res = INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs算法</title>
    <url>/2022/03/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95dfs/</url>
    <content><![CDATA[<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></p>
<p><strong>思路：</strong><br>递归<br><strong>时间复杂度：<em>O(4<sup>n</sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str[k].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + str[k][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, u, path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str[k].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + str[k][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="built_in">dfs</span>(digits, u, path);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    vector&lt;string&gt; ans = <span class="built_in">letterCombinations</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (string i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p>
<p><strong>思路：</strong><br>左括号小于<code>n</code>，就可以加；右括号数量小于左括号数量则可以加<br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lc为左括号的数量，rc为右括号的数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, res + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; lc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, res + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lc为左括号的数量，rc为右括号的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, res + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; lc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, res + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;string&gt; ans = <span class="built_in">generateParenthesis</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : ans) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></p>
<p><strong>思路：</strong></p>
<p>暴力枚举每个数选几个</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, u + <span class="number">1</span>, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, u + <span class="number">1</span>, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = s.<span class="built_in">combinationSum</span>(c, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></p>
<p><strong>思路：</strong></p>
<p>先求每个数最多能出现的次数，然后枚举每个数选几个，并且加上个数限制即可</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; c.<span class="built_in">size</span>() &amp;&amp; c[k] == c[u]) k++;</span><br><span class="line">        <span class="type">int</span> cnt = k - u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, k, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(c, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;c, <span class="type">int</span> u, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == c.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; c.<span class="built_in">size</span>() &amp;&amp; c[k] == c[u]) k++;</span><br><span class="line">        <span class="type">int</span> cnt = k - u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(c, k, target - c[u] * i);</span><br><span class="line">            path.<span class="built_in">push_back</span>(c[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; c[u] * i &lt;= target &amp;&amp; i &lt;= cnt; i++) &#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans = s.<span class="built_in">combinationSum</span>(c, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟</title>
    <url>/2022/03/30/%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a>Z 字形变换</h1><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/">Z 字形变换</a></p>
<p><strong>思路：</strong><br>第一行和最后一行，每个数字之间间隔是<code>2n-2</code>：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-18-20-16483439651561.png" alt="在这里插入图片描述"></p>
<span id="more"></span>

<p>中间行分2个队伍，分别向后相差<code>2n-2</code>，两个队伍的队头之和为<code>2n-2</code>：<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-22-39.png" alt="在这里插入图片描述"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一行的时候直接返回s即可</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一行和最后一行，每个数字之间间隔是2n - 2</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    ans += s[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中间行分2个队伍j和k，分别向后相差2n-2，两个队伍的队头j和k之和为2n-2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - j; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// j队伍在前</span></span><br><span class="line">                    ans += s[j];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// k队伍在后，总是一个j一个k，这样轮循下去</span></span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        ans += s[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一行的时候直接返回s即可</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一行和最后一行，每个数字之间间隔是2n - 2</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                ans += s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 中间行分2个队伍j和k，分别向后相差2n-2，两个队伍的队头j和k之和为2n-2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - j; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// j队伍在前</span></span><br><span class="line">                ans += s[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// k队伍在后，总是一个j一个k，这样轮循下去</span></span><br><span class="line">                <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    ans += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt;  n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">convert</span>(s, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p>
<p><strong>思路：</strong><br>将<code>ans * 10 + res[i]</code> 转化为  <code>ans &lt;= double (INT_MAX - res[i] - 1) / 10</code>即可<br><strong>时间复杂度：<em>O(log<sub>10<sub>n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	        sign = <span class="number">-1</span>;</span><br><span class="line">	        x = -x;</span><br><span class="line">	    &#125;</span><br><span class="line">	    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">	        res.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">	        x /= <span class="number">10</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (ans &lt;= <span class="built_in">double</span> (INT_MAX - res[i] - <span class="number">1</span>) / <span class="number">10</span>) &#123;</span><br><span class="line">	            ans = ans * <span class="number">10</span> + res[i];</span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ans *= sign;</span><br><span class="line">	    <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= <span class="built_in">double</span> (INT_MAX - res[i]) / <span class="number">10</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + res[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">reverse</span>(x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></p>
<p><strong>思路：</strong><br>细心点即可，小心超出long long 的范围<br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 丢弃无用的前导空格</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查下一个字符（假设还未到字符末尾）为正还是负号</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;-&#x27;</span>) k++, sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加符号</span></span><br><span class="line">        ans *= sign;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX) ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; INT_MIN) ans = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 丢弃无用的前导空格</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查下一个字符（假设还未到字符末尾）为正还是负号</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;-&#x27;</span>) k++, sign = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加符号</span></span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; INT_MAX) ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; INT_MIN) ans = INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAtoi</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p>
<p><strong>思路：</strong><br>利用字符串转换函数<code>to_string(x)</code>和字符串翻转函数<code>string(str.rbegin(), str.rend());</code><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="comment">// 字符串翻转函数</span></span><br><span class="line">        string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">return</span> str == str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">    string str2 = <span class="built_in">string</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="keyword">return</span> str == str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isPalindrome</span>(x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p>
<p><strong>思路：</strong><br>假设左边先到达最优解，证明右边一定会向最优解靠拢<br>也就是说当左边到达最优解时，右边在最优解之前的值，一定都比左边的值要短，从而左边不动，右边向左靠拢，直到经过右边最优解为止<br><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-27_09-23-41.png" alt="在这里插入图片描述"><br><strong>结论，只要左边先到达最优解，那么右边到达最优解之前的值，一定小于左边的最优解</strong><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[l], height[r]) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[l], height[r]) * (r - l));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; height = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxArea</span>(height) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h1><p><a href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> valus[] = &#123;</span><br><span class="line">            <span class="number">1000</span>,</span><br><span class="line">            <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>,</span><br><span class="line">            <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        string reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">            <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= valus[i]) &#123;</span><br><span class="line">                num -= valus[i];</span><br><span class="line">                res += reps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h1><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>, hash[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        hash[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>, hash[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        hash[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>, hash[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        hash[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; hash[s[i]] &lt; hash[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= hash[s[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += hash[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p>
<p><strong>思路：</strong><br>把最短的字符串放在第一个，然后逐位和后面的字符串相应位置比较，如果遇到不同的直接跳出双重循环<br><strong>时间复杂度：<em>O(n<sup>n<sup>)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到长度最短的字符串</span></span><br><span class="line">        <span class="type">int</span> minv = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 长度最短的字符串的下标</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].<span class="built_in">size</span>() &lt; minv) &#123;</span><br><span class="line">                minv = strs[i].<span class="built_in">size</span>();</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx) <span class="built_in">swap</span>(strs[<span class="number">0</span>], strs[idx]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                    sign = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == strs.<span class="built_in">size</span>() - <span class="number">1</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到长度最短的字符串</span></span><br><span class="line">    <span class="type">int</span> minv = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 长度最短的字符串的下标</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].<span class="built_in">size</span>() &lt; minv) &#123;</span><br><span class="line">            minv = strs[i].<span class="built_in">size</span>();</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx) <span class="built_in">swap</span>(strs[<span class="number">0</span>], strs[idx]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == strs.<span class="built_in">size</span>() - <span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;<span class="string">&quot;cir&quot;</span>,<span class="string">&quot;car&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">longestCommonPrefix</span>(strs) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p>
<p><strong>思路：</strong><br>用栈，如果是左括号，就压栈，然后<code>continue</code><br>如果是右括号，则看栈顶是不是对应的左括号，如果不是，则压栈<br>如果是右括号，栈为空，则返回<code>false</code><br>如果遍历完毕，栈为空则返回<code>true</code>，否则返回<code>false</code><br><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">isValid</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></p>
<p><strong>思路：</strong></p>
<p>首先逆序扫描一遍数组，找到降序的点（即：图中红色的点）<br>如图：</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com/Snipaste_2022-03-30_23-11-48.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k --;</span><br></pre></td></tr></table></figure>

<p>循环结束<code>k</code>的值表示红色的点<code>a</code>的下标。</p>
<p>然后重新逆序遍历，找到最小的比<code>k - 1</code>大的点。由于在图中点<code>a</code>后面的点本身就是排好序了的，所以我们逆序遍历，第一个比<code>k - 1</code>大的点就是最小的比<code>k - 1</code>大的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br></pre></td></tr></table></figure>

<p>然后交换这两个点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>最后将后面（蓝色圈出来部分）下降的折线 捋成上升的形状。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：<em>O(n)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[t] &lt;= nums[k - <span class="number">1</span>]) t--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[k - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">nextPermutation</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">有效的数独</a></p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>&gt;)</em></strong><br><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[9]为行，col[9]为列</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">9</span>], col[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">            <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++res[board[i][j] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++col[board[j][i] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res[9]为九宫格</span></span><br><span class="line">        <span class="type">int</span> rc[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i += <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(rc, <span class="number">0</span>, <span class="keyword">sizeof</span> rc);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[x + i][y + j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; ++rc[board[x + i][y + j] - <span class="string">&#x27;1&#x27;</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><p><a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></p>
<p><strong>思路：</strong></p>
<p>简单模拟一下即可，双指针</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, j = k; j &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == s[k]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="built_in">to_string</span>(j - k) + s[k];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></p>
<p><strong>思路一：</strong></p>
<p>假设不考虑时间复杂度，排序，去重以后，暴力对比即可</p>
<p><strong>时间复杂度：<em>O(nlogn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; INT_MAX; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>哈希表，把所有数放到哈希表里面，然后再枚举所有正整数</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (hash.<span class="built_in">count</span>(res)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>思路三：</strong></p>
<p>原地哈希算法：</p>
<p>原地哈希算法主要应用在范围为 [0, len(nums)] 的数组解法中，将数组元素本身作为<code>nums</code> 的下标，即 <code>nums[nums[i]]</code></p>
<p>原地哈希映射：保证1出现在nums[0]的位置上，2出现在nums[1]的位置上，…，n出现在nums[n-1]的位置上，其他的数字不管。例如[3,4,-1,1]将被排序为[1,-1,3,4]</p>
<p>遍历nums，找到第一个不在应在位置上的1到n的数。例如，排序后的[1,-1,3,4]中第一个 nums[i] !&#x3D; i + 1 的是数字2（注意此时i&#x3D;1）。</p>
<p>时间复杂度分析：代码中第二层while循环，每循环一次，会将一个数放在正确的位置上，所以总共最多执行 n 次，所以总时间复杂度 O(n)。</p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>空间复杂度：<em>O(1)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h1><p><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></p>
<p><strong>思路：</strong></p>
<p>将A[i] * B[j] 加到 C[i + j] 里面，最后再一起进位</p>
<p><img src="https://typora1321.oss-cn-beijing.aliyuncs.com//image-20220412220151895.png" alt="image-20220412220151895"></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除前导0</span></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">        <span class="comment">// 数字转字符串</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="comment">// 将A[i] * B[j] 加到 C[i + j] 里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; C[k] == <span class="number">0</span>) k--;</span><br><span class="line">    <span class="comment">// 数字转字符串</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) ans += C[k--] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string num1, num2;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>周赛册</title>
    <url>/2022/03/26/%E5%91%A8%E8%B5%9B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="数组中紧跟-key-之后出现最频繁的数字"><a href="#数组中紧跟-key-之后出现最频繁的数字" class="headerlink" title="数组中紧跟 key 之后出现最频繁的数字"></a>数组中紧跟 key 之后出现最频繁的数字</h1><p><a href="https://leetcode-cn.com/problems/most-frequent-number-following-key-in-an-array/">数组中紧跟 key 之后出现最频繁的数字</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == nums[i] &amp;&amp; i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                hash[nums[i + <span class="number">1</span>]]++;</span><br><span class="line">                <span class="keyword">if</span> (hash[nums[i + <span class="number">1</span>]] &gt; res) &#123;</span><br><span class="line">                    res = hash[nums[i + <span class="number">1</span>]];</span><br><span class="line">                    ans = nums[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mostFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == nums[i] &amp;&amp; i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            hash[nums[i + <span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums[i + <span class="number">1</span>]] &gt; res) &#123;</span><br><span class="line">                res = hash[nums[i + <span class="number">1</span>]];</span><br><span class="line">                ans = nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> key = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">mostFrequent</span>(nums, key) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="将杂乱无章的数字排序"><a href="#将杂乱无章的数字排序" class="headerlink" title="将杂乱无章的数字排序"></a>将杂乱无章的数字排序</h1><p><a href="https://leetcode-cn.com/problems/sort-the-jumbled-numbers/">将杂乱无章的数字排序</a></p>
<p><strong>时间复杂度：<em>O(n * m)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nums2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortJumbled</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; mapping, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">            string zfc = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zfc.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                res2 = res2 * <span class="number">10</span> + zfc[j] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 加密以前的</span></span><br><span class="line">                <span class="type">int</span> resPlus = mapping[zfc[j] - <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 加密过程</span></span><br><span class="line">                res = res * <span class="number">10</span> + resPlus; <span class="comment">// 加密以后的</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash[i] = res2;</span><br><span class="line">            nums2.<span class="built_in">push_back</span>(&#123;res, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums2) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(hash[x.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>ACM模式代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nums2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortJumbled</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; mapping, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">            string zfc = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zfc.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                res2 = res2 * <span class="number">10</span> + zfc[j] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 加密以前的</span></span><br><span class="line">                <span class="type">int</span> resPlus = mapping[zfc[j] - <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 加密过程</span></span><br><span class="line">                res = res * <span class="number">10</span> + resPlus; <span class="comment">// 加密以后的</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash[i] = res2;</span><br><span class="line">            nums2.<span class="built_in">push_back</span>(&#123;res, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums2) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(hash[x.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mapping = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">991</span>,<span class="number">338</span>,<span class="number">38</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans = solution.<span class="built_in">sortJumbled</span>(mapping, nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : ans) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="有向无环图中一个节点的所有祖先"><a href="#有向无环图中一个节点的所有祖先" class="headerlink" title="有向无环图中一个节点的所有祖先"></a>有向无环图中一个节点的所有祖先</h1><p><a href="https://leetcode-cn.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/">有向无环图中一个节点的所有祖先</a></p>
<p><strong>思路：记忆化dfs(时间及其慢)，bfs(推荐)</strong></p>
<p><strong>dfs最坏时间复杂度：<em>O(n<sup>n</sup>)</em></strong></p>
<p><strong>核心代码(dfs)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 储存父亲的哈希表（不是祖宗）</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除重复祖宗的哈希表</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; reRes;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getAncestors</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            <span class="comment">// edge[1]的父亲是edge[0]</span></span><br><span class="line">            fa[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            hash.<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            reRes.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">jyh</span>(n);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, i, jyh);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : reRes) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">            ans[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; fa, <span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; jyh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jyh[i].<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; fa[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            reRes.<span class="built_in">insert</span>(fa[i][j]);</span><br><span class="line">            jyh[i].<span class="built_in">push_back</span>(fa[i][j]);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, fa[i][j], jyh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>ACM模式代码(dfs)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 储存父亲的哈希表（不是祖宗）</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除重复祖宗的哈希表</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; reRes;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getAncestors</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            <span class="comment">// edge[1]的父亲是edge[0]</span></span><br><span class="line">            fa[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            hash.<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            reRes.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">jyh</span>(n);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, i, jyh);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : reRes) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">            ans[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; fa, <span class="type">int</span> i, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; jyh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jyh[i].<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; fa[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            reRes.<span class="built_in">insert</span>(fa[i][j]);</span><br><span class="line">            jyh[i].<span class="built_in">push_back</span>(fa[i][j]);</span><br><span class="line">            <span class="built_in">dfs</span>(fa, fa[i][j], jyh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">8</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges = &#123;&#123;<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">7</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = solution.<span class="built_in">getAncestors</span>(n, edges);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; p[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; p[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j != p[i].<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != p.<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;],&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合字符串"><a href="#组合字符串" class="headerlink" title="组合字符串"></a>组合字符串</h1><p><a href="https://www.acwing.com/problem/content/4311/">组合字符串</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> s1_len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> s2_len = s2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1sta = <span class="number">1</span>, s2sta = <span class="number">0</span>;</span><br><span class="line">    s3 += s1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (; s1sta &lt; s1_len &amp;&amp; s2sta &lt; s2_len; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (s1[s1sta] &lt; s2[s2sta] &amp;&amp; s1sta &lt; s1_len &amp;&amp; s2sta &lt; s2_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            s3 += s1[s1sta];</span><br><span class="line">            s1sta++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s1[s1sta] &gt;= s2[s2sta] &amp;&amp; s1sta &lt; s1_len &amp;&amp; s2sta &lt; s2_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            s3 += s2[s2sta];</span><br><span class="line">            s2sta++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (s1sta &gt; <span class="number">0</span> &amp;&amp; s2sta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1sta == <span class="number">0</span>) s3 += s1[s1sta];</span><br><span class="line">    <span class="keyword">if</span> (s2sta == <span class="number">0</span>) s3 += s2[s2sta];</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="消灭老鼠"><a href="#消灭老鼠" class="headerlink" title="消灭老鼠"></a>消灭老鼠</h1><p><a href="https://www.acwing.com/problem/content/4312/">消灭老鼠</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">double</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> n, x0, y0;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x0 &gt;&gt; y0;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="type">double</span> k;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x - x0 == <span class="number">0</span>) k = <span class="number">124184</span>;</span><br><span class="line">        <span class="keyword">else</span> k = (y - y0) / (x - x0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(k)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        hash.<span class="built_in">insert</span>(k);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h1><p><a href="https://www.acwing.com/problem/content/4314/">最小值</a></p>
<p><strong>时间复杂度：<em>O(n)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">    <span class="type">double</span> minv = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, a / b * m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, minv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="出现次数"><a href="#出现次数" class="headerlink" title="出现次数"></a>出现次数</h1><p><a href="https://www.acwing.com/problem/content/4315/">出现次数</a></p>
<p><strong>解法一：前缀和</strong></p>
<p><strong>时间复杂度：<em>O(n * m)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> S[<span class="number">1010</span>]; <span class="comment">// 前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s; <span class="comment">// 因为n, m, l, r 都从1开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// S[i]就代表在 i 之前的，并且长度为 m 的子串中，有多少个和 t 相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 求前缀和</span></span><br><span class="line">        S[i] = S[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i - m + <span class="number">1</span>, m) == t) S[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="type">int</span> r0 = l + m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r0 &gt; r) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; S[r] - S[r0 - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：暴搜</strong></p>
<p><strong>最大时间复杂度：<em>O(n * m * q)</em></strong></p>
<p>单独每个数据都能过，但是一起就TLE了</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    string s, t;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ii;</span><br><span class="line">        <span class="type">int</span> jj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l - <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= r - <span class="number">1</span>; i++, j = <span class="number">0</span>) &#123;</span><br><span class="line">            ii = i, jj = j;</span><br><span class="line">            <span class="keyword">if</span> (r - i &lt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i + m - <span class="number">1</span>] != t[m - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (ii &lt; r &amp;&amp; jj &lt; m &amp;&amp; s[ii] == t[jj]) &#123;</span><br><span class="line">                    res++; <span class="comment">// 代表res个相同</span></span><br><span class="line">                    <span class="keyword">if</span> (res == m) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        res = <span class="number">0</span>;<span class="comment">// 代表res个相同</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ii++, jj++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数圈圈"><a href="#数圈圈" class="headerlink" title="数圈圈"></a>数圈圈</h1><p><a href="https://www.acwing.com/problem/content/4379/">数圈圈</a></p>
<p><strong>时间复杂度：<em>O(logn)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> c[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> j[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">           <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        num += j[n % <span class="number">16</span>];</span><br><span class="line">        n /= <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="农田灌溉"><a href="#农田灌溉" class="headerlink" title="农田灌溉"></a>农田灌溉</h1><p><a href="https://www.acwing.com/problem/content/4380/">农田灌溉</a></p>
<p><strong>时间复杂度：<em>O(n<sup>2</sup>)</em></strong></p>
<p><strong>核心代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> c[<span class="number">220</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            cin &gt;&gt; i;</span><br><span class="line">            c[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= n; a++)</span><br><span class="line">            <span class="keyword">if</span> (c[a] == <span class="number">1</span>) &#123;</span><br><span class="line">                maxlen = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = n; a &gt;= <span class="number">1</span>; a--)</span><br><span class="line">            <span class="keyword">if</span> (c[a] == <span class="number">1</span>) &#123;</span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, n - a + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((j - i) % <span class="number">2</span> == <span class="number">0</span>) len2 = (j - i) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> len2 = (j - i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                        len = <span class="built_in">max</span>(len, len2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, len);</span><br><span class="line">        cout &lt;&lt; maxlen &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode &amp; Acwing 周赛</tag>
      </tags>
  </entry>
</search>
